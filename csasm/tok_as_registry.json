{
  "namespaces": [
    {
      "namespace": "ui::staffcredit"
    },
    {
      "namespace": "ui::puzzle"
    },
    {
      "namespace": "ui::model"
    },
    {
      "namespace": "ui::submarine"
    },
    {
      "namespace": "ui::battlelab"
    },
    {
      "namespace": "ui::battlelab_vs"
    },
    {
      "namespace": "ui::stampcard"
    },
    {
      "namespace": "ui::seamap"
    },
    {
      "namespace": "ui::guidemap"
    },
    {
      "namespace": "ui::save"
    },
    {
      "namespace": "ui::announce"
    },
    {
      "namespace": "ui::timer"
    },
    {
      "namespace": "ui::hud"
    },
    {
      "namespace": "sys::prepo"
    },
    {
      "namespace": "ui::museum"
    },
    {
      "namespace": "hand::submarine"
    },
    {
      "namespace": "save"
    },
    {
      "namespace": "hand"
    },
    {
      "namespace": "eft"
    },
    {
      "namespace": "hit"
    },
    {
      "namespace": "skip"
    },
    {
      "namespace": "pouch::record"
    },
    {
      "namespace": "pouch"
    },
    {
      "namespace": "snd::effect"
    },
    {
      "namespace": "btl::amulet"
    },
    {
      "namespace": "btl::ui::talk"
    },
    {
      "namespace": "btl::mobj"
    },
    {
      "namespace": "btl::ui::hand"
    },
    {
      "namespace": "hand::script"
    },
    {
      "namespace": "btl::record"
    },
    {
      "namespace": "btl::collision"
    },
    {
      "namespace": "btl::drop"
    },
    {
      "namespace": "btl::event"
    },
    {
      "namespace": "snd::battle"
    },
    {
      "namespace": "snd::fade"
    },
    {
      "namespace": "btl::MR"
    },
    {
      "namespace": "btl::set"
    },
    {
      "namespace": "gfx"
    },
    {
      "namespace": "as"
    },
    {
      "namespace": "snd::vib"
    },
    {
      "namespace": "snd::slot"
    },
    {
      "namespace": "snd::se"
    },
    {
      "namespace": "snd::ff"
    },
    {
      "namespace": "snd::envbgm"
    },
    {
      "namespace": "snd::env"
    },
    {
      "namespace": "snd::dispos"
    },
    {
      "namespace": "snd::bgm"
    },
    {
      "namespace": "snd"
    },
    {
      "namespace": "dbg::text"
    },
    {
      "namespace": "btl::weapon"
    },
    {
      "namespace": "btl::util"
    },
    {
      "namespace": "btl::unit::parts"
    },
    {
      "namespace": "btl::unit"
    },
    {
      "namespace": "btl::ui"
    },
    {
      "namespace": "btl::seq"
    },
    {
      "namespace": "btl::range"
    },
    {
      "namespace": "btl::message"
    },
    {
      "namespace": "btl::map"
    },
    {
      "namespace": "btl::item"
    },
    {
      "namespace": "btl::formation"
    },
    {
      "namespace": "btl::effect"
    },
    {
      "namespace": "btl::config"
    },
    {
      "namespace": "btl::cheer"
    },
    {
      "namespace": "btl::camera"
    },
    {
      "namespace": "btl::ac"
    },
    {
      "namespace": "btl"
    }
  ],
  "object_types": [
    {
      "namespace": "ui::puzzle",
      "object_name": "History",
      "size": 0,
      "flags": 262145
    },
    {
      "namespace": "eft",
      "object_name": "Handle",
      "size": 16,
      "flags": 770
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "size": 136,
      "flags": 7938
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "size": 16,
      "flags": 7938
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "size": 16,
      "flags": 7938
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "size": 8,
      "flags": 7938
    },
    {
      "namespace": "Switch",
      "object_name": "CS",
      "size": 24,
      "flags": 7938
    },
    {
      "namespace": "Switch",
      "object_name": "CF",
      "size": 24,
      "flags": 7938
    },
    {
      "namespace": "Switch",
      "object_name": "GS",
      "size": 24,
      "flags": 7938
    },
    {
      "namespace": "Switch",
      "object_name": "GF",
      "size": 24,
      "flags": 7938
    },
    {
      "namespace": "gfx",
      "object_name": "SpotLight",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "gfx",
      "object_name": "PointLight",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "size": 48,
      "flags": 7938
    },
    {
      "namespace": "as",
      "object_name": "ContextHandle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "as",
      "object_name": "ScriptHandle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "size": 16,
      "flags": 131842
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "size": 4,
      "flags": 73474
    },
    {
      "namespace": "snd",
      "object_name": "ActorHandle",
      "size": 16,
      "flags": 7938
    },
    {
      "namespace": "snd",
      "object_name": "SlotHandle",
      "size": 16,
      "flags": 7938
    },
    {
      "namespace": "snd",
      "object_name": "VoiceHandle",
      "size": 16,
      "flags": 7938
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "size": 448,
      "flags": 7938
    },
    {
      "namespace": "msg",
      "object_name": "MessageHandle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "size": 128,
      "flags": 7938
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "size": 16,
      "flags": 7938
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "size": 64,
      "flags": 139010
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "size": 64,
      "flags": 139010
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "size": 40,
      "flags": 7938
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "size": 40,
      "flags": 7938
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "size": 40,
      "flags": 7938
    },
    {
      "namespace": "math",
      "object_name": "RoundedNonuniformSpline",
      "size": 24,
      "flags": 7938
    },
    {
      "namespace": "dbg",
      "object_name": "DS",
      "size": 24,
      "flags": 7938
    },
    {
      "namespace": "dbg",
      "object_name": "DF",
      "size": 24,
      "flags": 7938
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "size": 0,
      "flags": 1
    },
    {
      "namespace": "dbg",
      "object_name": "DebugCanvas",
      "size": 136,
      "flags": 7938
    },
    {
      "namespace": "sobj",
      "object_name": "HandleList",
      "size": 0,
      "flags": 1
    },
    {
      "namespace": "sobj",
      "object_name": "HandleIterator",
      "size": 16,
      "flags": 7938
    },
    {
      "namespace": "mobj",
      "object_name": "HandleList",
      "size": 0,
      "flags": 1
    },
    {
      "namespace": "mobj",
      "object_name": "HandleIterator",
      "size": 16,
      "flags": 7938
    },
    {
      "namespace": "item",
      "object_name": "HandleList",
      "size": 0,
      "flags": 1
    },
    {
      "namespace": "item",
      "object_name": "HandleIterator",
      "size": 16,
      "flags": 7938
    },
    {
      "namespace": "party",
      "object_name": "HandleList",
      "size": 0,
      "flags": 1
    },
    {
      "namespace": "party",
      "object_name": "HandleIterator",
      "size": 16,
      "flags": 7938
    },
    {
      "namespace": "hariko",
      "object_name": "HandleList",
      "size": 0,
      "flags": 1
    },
    {
      "namespace": "hariko",
      "object_name": "HandleIterator",
      "size": 16,
      "flags": 7938
    },
    {
      "namespace": "npc",
      "object_name": "HandleList",
      "size": 0,
      "flags": 1
    },
    {
      "namespace": "npc",
      "object_name": "HandleIterator",
      "size": 16,
      "flags": 7938
    },
    {
      "namespace": "navigator",
      "object_name": "Handle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "sobj",
      "object_name": "Handle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "lobj",
      "object_name": "Handle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "mobj",
      "object_name": "Handle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "gmap",
      "object_name": "Handle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "item",
      "object_name": "Handle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "party",
      "object_name": "Handle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "hariko",
      "object_name": "Handle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "npc",
      "object_name": "Handle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "player",
      "object_name": "Handle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "cases",
      "object_name": "ObjHandle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "size": 12,
      "flags": 7938
    },
    {
      "namespace": "btl",
      "object_name": "EffectHandle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "btl",
      "object_name": "MapHandle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "btl",
      "object_name": "MobjHandle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "btl",
      "object_name": "ItemHandle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "btl",
      "object_name": "PartsHandle",
      "size": 32,
      "flags": 7938
    },
    {
      "namespace": "btl",
      "object_name": "UnitHandle",
      "size": 32,
      "flags": 7938
    }
  ],
  "object_properties": [
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "const s32 TypeMax",
      "offset": 8
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "u8 a",
      "offset": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "u8 b",
      "offset": 2
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "u8 g",
      "offset": 1
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "u8 r",
      "offset": 0
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "f32 m_viewDist",
      "offset": 156
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "f32 m_viewAngle",
      "offset": 152
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "bool m_enemy",
      "offset": 89
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "bool m_invisible",
      "offset": 88
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "f32 m_rot",
      "offset": 84
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "math::Vec3 m_pos",
      "offset": 72
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "DebugWindow& m_parent_debug_window",
      "offset": 56
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "u32 m_WindowId",
      "offset": 4
    }
  ],
  "object_behaviours": [
    {
      "namespace": "ui::puzzle",
      "object_name": "History",
      "declaration": "History@ f(as_s32 index)",
      "behaviour": 3,
      "calling_convention": 0
    },
    {
      "namespace": "eft",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "eft",
      "object_name": "Handle",
      "declaration": "void f(const Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "eft",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "void f(f32 x, f32 y, f32 z, f32 w)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "void f(const f32& pv)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "void f(const Vec2 vec2)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "void f(f32 x, f32 y, f32 z)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "void f(const f32& pv)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "void f(const Vec3 vec3)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "void f(f32 x, f32 y)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "void f(const f32& pv)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "CS",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "CS",
      "declaration": "void f(const CS& v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "CS",
      "declaration": "void f(int v, const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "CS",
      "declaration": "void f(const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "CS",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "CF",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "CF",
      "declaration": "void f(const CF& v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "CF",
      "declaration": "void f(bool v, const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "CF",
      "declaration": "void f(const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "CF",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "GS",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "GS",
      "declaration": "void f(const GS& v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "GS",
      "declaration": "void f(int v, const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "GS",
      "declaration": "void f(const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "GS",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "GF",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "GF",
      "declaration": "void f(const GF& v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "GF",
      "declaration": "void f(bool v, const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "GF",
      "declaration": "void f(const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "Switch",
      "object_name": "GF",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "gfx",
      "object_name": "SpotLight",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "gfx",
      "object_name": "SpotLight",
      "declaration": "void f(const SpotLight&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "gfx",
      "object_name": "SpotLight",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "gfx",
      "object_name": "PointLight",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "gfx",
      "object_name": "PointLight",
      "declaration": "void f(const PointLight&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "gfx",
      "object_name": "PointLight",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f(?&in v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f(any& v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f(const Variable& v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f(bool v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f(const string& v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f(f32 v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f(u32 v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f(int v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f(u16 v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f(s16 v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f(u8 v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f(s8 v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "ContextHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "ContextHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "ScriptHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "as",
      "object_name": "ScriptHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "void f(const Color4u8& value)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "void f(f32 red, f32 green, f32 blue, f32 alpha = 1.0f)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "void f(const Color4f& value)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "void f(u8 red, u8 green, u8 blue, u8 alpha = util::Color4u8::ElementMax)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "snd",
      "object_name": "ActorHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "snd",
      "object_name": "ActorHandle",
      "declaration": "void f(const ActorHandle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "snd",
      "object_name": "ActorHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "snd",
      "object_name": "SlotHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "snd",
      "object_name": "SlotHandle",
      "declaration": "void f(const string& name)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "snd",
      "object_name": "SlotHandle",
      "declaration": "void f(const SlotHandle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "snd",
      "object_name": "SlotHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "snd",
      "object_name": "VoiceHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "snd",
      "object_name": "VoiceHandle",
      "declaration": "void f(const string& name)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "snd",
      "object_name": "VoiceHandle",
      "declaration": "void f(const VoiceHandle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "snd",
      "object_name": "VoiceHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "msg",
      "object_name": "MessageHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "msg",
      "object_name": "MessageHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "void f(math::Vec3 pos1, math::Vec3 pos2, float _r)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "void f(math::Vec3 _pos, float _r)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "void f(f32 x, f32 y, f32 z, f32 w)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "void f(const f32& pv)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "void f(const Vec4& axisX, const Vec4& axisY, const Vec4& axisZ, const Vec4& axisW)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "void f(f32 m00, f32 m01, f32 m02, f32 m03, f32 m10, f32 m11, f32 m12, f32 m13, f32 m20, f32 m21, f32 m22, f32 m23, f32 m30, f32 m31, f32 m32, f32 m33)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "void f(const f32& pv)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void f(const Vec3& axisX, const Vec3& axisY, const Vec3& axisZ, const Vec3& axisW)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void f(f32 m00, f32 m01, f32 m02, f32 m10, f32 m11, f32 m12, f32 m20, f32 m21, f32 m22, f32 m30, f32 m31, f32 m32)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void f(const f32& pv)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "declaration": "void f(int curve_type, int easing_type, array<math::Vec3>& easing_param, as_f32 ext_param)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "declaration": "void f(int curve_type, int easing_type, array<math::Vec3>& easing_param)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "declaration": "void f(int curve_type, int easing_type)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "declaration": "void f(int curve_type, int easing_type, array<math::Vec2>& easing_param, as_f32 ext_param)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "declaration": "void f(int curve_type, int easing_type, array<math::Vec2>& easing_param)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "declaration": "void f(int curve_type, int easing_type)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "declaration": "void f(int curve_type, int easing_type, array<as_f32>& easing_param, as_f32 ext_param)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "declaration": "void f(int curve_type, int easing_type, array<as_f32>& easing_param)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "declaration": "void f(int curve_type, int easing_type)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "RoundedNonuniformSpline",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "math",
      "object_name": "RoundedNonuniformSpline",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DS",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DS",
      "declaration": "void f(const DS& v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DS",
      "declaration": "void f(int v, const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DS",
      "declaration": "void f(const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DS",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DF",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DF",
      "declaration": "void f(const DF& v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DF",
      "declaration": "void f(bool v, const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DF",
      "declaration": "void f(const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DF",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void f()",
      "behaviour": 6,
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void f()",
      "behaviour": 5,
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "DebugWindow@ f(const string& window_name)",
      "behaviour": 3,
      "calling_convention": 0
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "DebugWindow@ f()",
      "behaviour": 3,
      "calling_convention": 0
    },
    {
      "namespace": "dbg",
      "object_name": "DebugCanvas",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DebugCanvas",
      "declaration": "void f(s32 canvas_x, s32 canvas_y, f32 canvas_scale_left, f32 canvas_scale_right, f32 canvas_scale_botom, f32 canvas_scale_top, bool over_write = true)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DebugCanvas",
      "declaration": "void f(s32 canvas_x, s32 canvas_y)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "dbg",
      "object_name": "DebugCanvas",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "sobj",
      "object_name": "HandleList",
      "declaration": "void f()",
      "behaviour": 6,
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleList",
      "declaration": "void f()",
      "behaviour": 5,
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleList",
      "declaration": "HandleList@ f()",
      "behaviour": 3,
      "calling_convention": 0
    },
    {
      "namespace": "sobj",
      "object_name": "HandleIterator",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "sobj",
      "object_name": "HandleIterator",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "mobj",
      "object_name": "HandleList",
      "declaration": "void f()",
      "behaviour": 6,
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleList",
      "declaration": "void f()",
      "behaviour": 5,
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleList",
      "declaration": "HandleList@ f()",
      "behaviour": 3,
      "calling_convention": 0
    },
    {
      "namespace": "mobj",
      "object_name": "HandleIterator",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "mobj",
      "object_name": "HandleIterator",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "item",
      "object_name": "HandleList",
      "declaration": "void f()",
      "behaviour": 6,
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleList",
      "declaration": "void f()",
      "behaviour": 5,
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleList",
      "declaration": "HandleList@ f()",
      "behaviour": 3,
      "calling_convention": 0
    },
    {
      "namespace": "item",
      "object_name": "HandleIterator",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "item",
      "object_name": "HandleIterator",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "party",
      "object_name": "HandleList",
      "declaration": "void f()",
      "behaviour": 6,
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleList",
      "declaration": "void f()",
      "behaviour": 5,
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleList",
      "declaration": "HandleList@ f()",
      "behaviour": 3,
      "calling_convention": 0
    },
    {
      "namespace": "party",
      "object_name": "HandleIterator",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "party",
      "object_name": "HandleIterator",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "hariko",
      "object_name": "HandleList",
      "declaration": "void f()",
      "behaviour": 6,
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleList",
      "declaration": "void f()",
      "behaviour": 5,
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleList",
      "declaration": "HandleList@ f()",
      "behaviour": 3,
      "calling_convention": 0
    },
    {
      "namespace": "hariko",
      "object_name": "HandleIterator",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "hariko",
      "object_name": "HandleIterator",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "HandleList",
      "declaration": "void f()",
      "behaviour": 6,
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleList",
      "declaration": "void f()",
      "behaviour": 5,
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleList",
      "declaration": "HandleList@ f()",
      "behaviour": 3,
      "calling_convention": 0
    },
    {
      "namespace": "npc",
      "object_name": "HandleIterator",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "HandleIterator",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "navigator",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "navigator",
      "object_name": "Handle",
      "declaration": "void f(const Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "navigator",
      "object_name": "Handle",
      "declaration": "void f(const chr::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "navigator",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "sobj",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "sobj",
      "object_name": "Handle",
      "declaration": "void f(const Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "sobj",
      "object_name": "Handle",
      "declaration": "void f(const chr::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "sobj",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "lobj",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "lobj",
      "object_name": "Handle",
      "declaration": "void f(const Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "lobj",
      "object_name": "Handle",
      "declaration": "void f(const chr::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "lobj",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "mobj",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "mobj",
      "object_name": "Handle",
      "declaration": "void f(const Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "mobj",
      "object_name": "Handle",
      "declaration": "void f(const chr::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "mobj",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "gmap",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "gmap",
      "object_name": "Handle",
      "declaration": "void f(const Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "gmap",
      "object_name": "Handle",
      "declaration": "void f(const chr::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "gmap",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "item",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "item",
      "object_name": "Handle",
      "declaration": "void f(const Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "item",
      "object_name": "Handle",
      "declaration": "void f(const chr::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "item",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "party",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "party",
      "object_name": "Handle",
      "declaration": "void f(const Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "party",
      "object_name": "Handle",
      "declaration": "void f(const chr::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "party",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "hariko",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "hariko",
      "object_name": "Handle",
      "declaration": "void f(const Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "hariko",
      "object_name": "Handle",
      "declaration": "void f(const chr::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "hariko",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "Handle",
      "declaration": "void f(const Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "Handle",
      "declaration": "void f(const chr::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "player",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "player",
      "object_name": "Handle",
      "declaration": "void f(const Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "player",
      "object_name": "Handle",
      "declaration": "void f(const chr::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "player",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const btl::PartsHandle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const btl::UnitHandle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const hariko::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const sobj::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const lobj::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const mobj::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const gmap::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const item::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const navigator::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const party::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const npc::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const player::Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f(const Handle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "cases",
      "object_name": "ObjHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "cases",
      "object_name": "ObjHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "void f(int a, int d)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "void f(const math::Vec3& v)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "EffectHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "EffectHandle",
      "declaration": "void f(const string& name)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "EffectHandle",
      "declaration": "void f(const EffectHandle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "EffectHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "MapHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "MapHandle",
      "declaration": "void f(const MapHandle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "MapHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "MobjHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "MobjHandle",
      "declaration": "void f(const string& name)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "MobjHandle",
      "declaration": "void f(const MobjHandle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "MobjHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "ItemHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "ItemHandle",
      "declaration": "void f(const string& name)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "ItemHandle",
      "declaration": "void f(const ItemHandle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "ItemHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "PartsHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "PartsHandle",
      "declaration": "void f(const string& name)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "PartsHandle",
      "declaration": "void f(const PartsHandle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "PartsHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "UnitHandle",
      "declaration": "void f()",
      "behaviour": 2,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "UnitHandle",
      "declaration": "void f(const string& name)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "UnitHandle",
      "declaration": "void f(const UnitHandle&)",
      "behaviour": 0,
      "calling_convention": 4
    },
    {
      "namespace": "btl",
      "object_name": "UnitHandle",
      "declaration": "void f()",
      "behaviour": 0,
      "calling_convention": 4
    }
  ],
  "object_methods": [
    {
      "namespace": "ui::puzzle",
      "object_name": "History",
      "declaration": "as_s32 GetStepNum ()",
      "calling_convention": 3
    },
    {
      "namespace": "ui::puzzle",
      "object_name": "History",
      "declaration": "as_s32 GetStep (as_s32 count)",
      "calling_convention": 3
    },
    {
      "namespace": "ui::puzzle",
      "object_name": "History",
      "declaration": "as_s32 GetImage(as_s32 x, as_s32 y)",
      "calling_convention": 3
    },
    {
      "namespace": "eft",
      "object_name": "Handle",
      "declaration": "bool isValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "eft",
      "object_name": "Handle",
      "declaration": "bool opEquals(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "eft",
      "object_name": "Handle",
      "declaration": "Handle &opAssign(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "bool NoticeDescending(s32 type, s32 begin_index=0, s32 num_index=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "bool NoticeAscending(s32 type, s32 begin_index=0, s32 num_index=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "bool Notice(s32 type, s32 begin_index=0, s32 num_index=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "s32 TypeSize(s32 type)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "s32 Size()",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "u32 GetID(s32 type, s32 index)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "u32 GetID(s32 type, NoticeCallback ref func, s32 begin_index=0, s32 num_index=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "NoticeCallback ref GetFunc(s32 type, u32 id)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "NoticeCallback ref GetFunc(s32 type, s32 index)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "s32 GetIndex(s32 type, as_u32 id)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "s32 GetIndex(s32 type, NoticeCallback ref func, s32 begin_index=0, s32 num_index=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "bool SetPriorityIndex(s32 type, s32 index, s32 priority_level)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "bool SetPriorityID(s32 type, u32 id, s32 priority_level)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "bool SetPriorityFunc(s32 type, NoticeCallback ref func, s32 priority_level, s32 begin_index=0, s32 num_index=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "bool RemoveAll()",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "bool RemoveTypeAll(s32 type)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "bool RemoveIndex(s32 type, s32 index)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "bool RemoveID(s32 type, u32 id)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "bool RemoveFunc(s32 type, NoticeCallback ref func, s32 begin_index=0, s32 num_index=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "u32 AddFuncInsert(s32 type, s32 index, NoticeCallback ref func, s32 priority_level=util::notice::PriorityLevel_Normal)",
      "calling_convention": 3
    },
    {
      "namespace": "util::notice",
      "object_name": "Manager",
      "declaration": "u32 AddFunc(s32 type, NoticeCallback ref func, s32 priority_level=util::notice::PriorityLevel_Normal)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "as_f32 Angle(const Vec4& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "as_f32 LengthSquared() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "as_f32 Length() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "as_f32 Dot(const Vec4& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "bool Normalize()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "Vec4 &opDivAssign(f32)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "Vec4 &opMulAssign(f32)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "Vec4 &opSubAssign(const Vec4 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "Vec4 &opAddAssign(const Vec4 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "Vec4 opDiv(f32 f) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "Vec4 opMul(f32 f) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "Vec4 opSub(const Vec4 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "Vec4 opAdd(const Vec4 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "Vec4 opNeg() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "bool opEquals(const Vec4 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "Vec4 &opAssign(const Vec4 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "void Set(as_f32 x, as_f32 y, as_f32 z, as_f32 w)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "void set_w(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "void set_z(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "void set_y(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "void set_x(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "f32 get_w() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "f32 get_z() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "f32 get_y() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec4",
      "declaration": "f32 get_x() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 YZ_Angle(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 YZ_LengthSquared() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 YZ_Length() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 YZ_Cross(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 YZ_Dot(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "bool YZ_Normalize()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 YZ() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 XY_Angle(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 XY_LengthSquared() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 XY_Length() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 XY_Cross(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 XY_Dot(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "bool XY_Normalize()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 XY() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 XZ_Angle(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 XZ_LengthSquared() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 XZ_Length() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 XZ_Cross(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 XZ_Dot(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "bool XZ_Normalize()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 XZ() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 Angle(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 LengthSquared() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 Length() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 Cross(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "as_f32 Dot(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "bool Normalize()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 &opDivAssign(f32)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 &opMulAssign(f32)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 &opSubAssign(const Vec3 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 &opAddAssign(const Vec3 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 opDiv(f32 f) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 opMul(f32 f) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 opSub(const Vec3 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 opAdd(const Vec3 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 opNeg() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "bool opEquals(const Vec3 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 &opAssign(const Vec2 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "Vec3 &opAssign(const Vec3 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "void Set(as_f32 x, as_f32 y, as_f32 z)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "void set_z(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "void set_y(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "void set_x(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "f32 get_z() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "f32 get_y() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec3",
      "declaration": "f32 get_x() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "as_f32 Angle(const Vec2& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "as_f32 LengthSquared() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "as_f32 Length() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "as_f32 Cross(const Vec2& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "as_f32 Dot(const Vec2& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "bool Normalize()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "Vec2 &opDivAssign(f32)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "Vec2 &opMulAssign(f32)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "Vec2 &opSubAssign(const Vec2 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "Vec2 &opAddAssign(const Vec2 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "Vec2 opDiv(f32 f) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "Vec2 opMul(f32 f) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "Vec2 opSub(const Vec2 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "Vec2 opAdd(const Vec2 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "Vec2 opNeg() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "bool opEquals(const Vec2 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "Vec2 &opAssign(const Vec3 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "Vec2 &opAssign(const Vec2 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "void Set(as_f32 x, as_f32 y)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "void set_y(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "void set_x(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "f32 get_y() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Vec2",
      "declaration": "f32 get_x() const",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "CS",
      "declaration": "bool IsValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "CS",
      "declaration": "void SetName(const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "CS",
      "declaration": "const string& GetName() const",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "CS",
      "declaration": "void set_v(int v)",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "CS",
      "declaration": "int get_v() const",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "CF",
      "declaration": "bool IsValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "CF",
      "declaration": "void SetName(const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "CF",
      "declaration": "const string& GetName() const",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "CF",
      "declaration": "void set_v(bool v)",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "CF",
      "declaration": "bool get_v() const",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "GS",
      "declaration": "bool IsValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "GS",
      "declaration": "void SetName(const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "GS",
      "declaration": "const string& GetName() const",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "GS",
      "declaration": "void set_v(int v)",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "GS",
      "declaration": "int get_v() const",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "GF",
      "declaration": "bool IsValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "GF",
      "declaration": "void SetName(const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "GF",
      "declaration": "const string& GetName() const",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "GF",
      "declaration": "void set_v(bool v)",
      "calling_convention": 3
    },
    {
      "namespace": "Switch",
      "object_name": "GF",
      "declaration": "bool get_v() const",
      "calling_convention": 3
    },
    {
      "namespace": "gfx",
      "object_name": "SpotLight",
      "declaration": "bool isValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "gfx",
      "object_name": "SpotLight",
      "declaration": "SpotLight &opAssign(const SpotLight&)",
      "calling_convention": 3
    },
    {
      "namespace": "gfx",
      "object_name": "PointLight",
      "declaration": "bool isValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "gfx",
      "object_name": "PointLight",
      "declaration": "PointLight &opAssign(const PointLight&)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "Variable &opAssign(const any&)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "Variable &opAssign(const Variable&)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "Variable &opAssign(const bool)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "Variable &opAssign(const string&)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "Variable &opAssign(const f32)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "Variable &opAssign(const u32)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "Variable &opAssign(const int)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void setAny(const any& v)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void setVariable(const Variable& v)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void setBool(const bool v)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void setString(const string& v)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void setFloat(const as_f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void setHex(const as_u32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "void setInt(const as_s32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "bool isAny() const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "bool isBool() const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "bool isString() const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "bool isFloat() const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "bool isHex() const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "bool isInt() const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "any& getAny() const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "bool getBool() const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "string& getString() const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "as_f32 getFloat() const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "as_u32 getHex() const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "Variable",
      "declaration": "as_s32 getInt() const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "ContextHandle",
      "declaration": "Variable& getLW(int no) const",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "ContextHandle",
      "declaration": "ContextHandle &opAssign(const ContextHandle &)",
      "calling_convention": 3
    },
    {
      "namespace": "as",
      "object_name": "ScriptHandle",
      "declaration": "ScriptHandle &opAssign(const ScriptHandle &)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "bool IsTransparent() const",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "void Clamp(as_f32 a, as_f32 b)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "void Clamp()",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "Color4f ToLinear() const",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "Color4f ToSrgb() const",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "Color4f CorrectGamma(as_f32 gamma) const",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "void SetLerp(const Color4f& a, const Color4f& b, as_f32 t)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "bool opEquals(const Color4f &)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "Color4f &opAssign(const Color4f &)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "void Set(as_f32 red, as_f32 green, as_f32 blue, as_f32 alpha)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "void set_a(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "void set_b(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "void set_g(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "void set_r(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "f32 get_a() const",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "f32 get_b() const",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "f32 get_g() const",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4f",
      "declaration": "f32 get_r() const",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "bool IsTransparent() const",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "Color4u8 ToLinear() const",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "Color4u8 ToSrgb() const",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "Color4u8 CorrectGamma(as_f32 gamma) const",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "void SetLerp(const Color4u8& a, const Color4u8& b, as_f32 t)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "bool opEquals(const Color4u8 &)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "Color4u8 &opAssign(const Color4u8 &)",
      "calling_convention": 3
    },
    {
      "namespace": "util",
      "object_name": "Color4u8",
      "declaration": "void Set(as_u8 red, as_u8 green, as_u8 blue, as_u8 alpha)",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "ActorHandle",
      "declaration": "bool isInvalid() const",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "ActorHandle",
      "declaration": "bool isValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "ActorHandle",
      "declaration": "void clear()",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "ActorHandle",
      "declaration": "bool opEquals(const ActorHandle&)",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "ActorHandle",
      "declaration": "ActorHandle &opAssign(const ActorHandle&)",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "SlotHandle",
      "declaration": "bool isInvalid() const",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "SlotHandle",
      "declaration": "bool isValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "SlotHandle",
      "declaration": "void clear()",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "SlotHandle",
      "declaration": "bool opEquals(const SlotHandle&)",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "SlotHandle",
      "declaration": "SlotHandle &opAssign(const SlotHandle&)",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "VoiceHandle",
      "declaration": "bool isInvalid() const",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "VoiceHandle",
      "declaration": "bool isValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "VoiceHandle",
      "declaration": "void clear()",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "VoiceHandle",
      "declaration": "bool opEquals(const VoiceHandle&)",
      "calling_convention": 3
    },
    {
      "namespace": "snd",
      "object_name": "VoiceHandle",
      "declaration": "VoiceHandle &opAssign(const VoiceHandle&)",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "void set_m_func_ESCAPE(string&)",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "void set_m_func_EXIT(string&)",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "void set_m_func_ACTION(string&)",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "void set_m_func_TALK(string&)",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "void set_m_func_MAIN(string&)",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "void set_m_func_ENTRY(string&)",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "void set_m_func_INIT(string&)",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "void set_m_btlSetId(string&)",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "void set_m_npc_Id(string&)",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "void set_m_name(string&)",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "string get_m_func_ESCAPE() const",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "string get_m_func_EXIT() const",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "string get_m_func_ACTION() const",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "string get_m_func_TALK() const",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "string get_m_func_MAIN() const",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "string get_m_func_ENTRY() const",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "string get_m_func_INIT() const",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "string get_m_btlSetId() const",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "string get_m_npc_Id() const",
      "calling_convention": 4
    },
    {
      "namespace": "npc",
      "object_name": "DisposData",
      "declaration": "string get_m_name() const",
      "calling_convention": 4
    },
    {
      "namespace": "msg",
      "object_name": "MessageHandle",
      "declaration": "MessageHandle &opAssign(const MessageHandle &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "float GetAnsLen() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "math::Vec3 GetAnsVec() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "math::Vec3 GetAnsPos() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "math::Vec3 GetUnitVec()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "float GetLen()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "float GetR() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "float GetLenSquared() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "math::Vec3 GetVec() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "math::Vec3 GetEndPos() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "math::Vec3 GetPos() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "math::Vec3 Line_Pos_Length(math::Vec3 b_pos)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "float Length(HitCapsuleShape &b)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "bool Hit(HitCapsuleShape &b)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "void SetParam(math::Vec3 pos1, math::Vec3 pos2, float _r)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "HitCapsuleShape",
      "declaration": "void SetParam(math::Vec3 _pos, float _r)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "void ToEulerianAngle(as_f32& yaw, as_f32& pitch, as_f32& roll) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Vec3 ToEulerianAngle() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Vec3 ToAxisAngle() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "as_f32 LengthSquared() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "as_f32 Length() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "as_f32 Dot(const Quat& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "bool Normalize()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Vec3 Rotate(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "void Inverse()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "void Conjugate()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Quat &opDivAssign(const Quat &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Quat &opMulAssign(const Quat &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Quat &opSubAssign(const Quat &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Quat &opAddAssign(const Quat &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Quat opDiv(const Quat &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Quat opMul(const Quat &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Quat opSub(const Quat &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Quat opAdd(const Quat &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Quat opNeg() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "bool opEquals(const Quat &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "Quat &opAssign(const Quat &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "void Set(as_f32 x, as_f32 y, as_f32 z, as_f32 w)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "void set_w(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "void set_z(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "void set_y(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "void set_x(f32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "f32 get_w() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "f32 get_z() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "f32 get_y() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Quat",
      "declaration": "f32 get_x() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 &opDivAssign(f32)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 &opMulAssign(f32)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 &opMulAssign(const Mtx44 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 &opSubAssign(const Mtx44 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 &opAddAssign(const Mtx44 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 opDiv(f32 f) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 opMul(f32 f) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 opMul(const Mtx43 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 opMul(const Mtx44 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 opSub(const Mtx44 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 opAdd(const Mtx44 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 opNeg() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "bool opEquals(const Mtx44 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Mtx44 &opAssign(const Mtx44 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Vec3 TransformCoord(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Vec4 Transform(const Vec4& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "bool InverseTranspose()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "bool Inverse()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "void Transpose()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "void Set(const Vec4& x, const Vec4& y, const Vec4& z, const Vec4& w)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "void set_axis_w(const Vec4& v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "void set_axis_z(const Vec4& v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "void set_axis_y(const Vec4& v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "void set_axis_x(const Vec4& v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Vec4 get_axis_w() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Vec4 get_axis_z() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Vec4 get_axis_y() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx44",
      "declaration": "Vec4 get_axis_x() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx43 &opDivAssign(f32)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx43 &opMulAssign(f32)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx43 &opMulAssign(const Mtx43 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx43 &opSubAssign(const Mtx43 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx43 &opAddAssign(const Mtx43 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx43 opDiv(f32 f) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx43 opMul(f32 f) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx44 opMul(const Mtx44 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx43 opMul(const Mtx43 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx43 opSub(const Mtx43 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx43 opAdd(const Mtx43 &) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx43 opNeg() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "bool opEquals(const Mtx43 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Mtx43 &opAssign(const Mtx43 &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Vec3 TransformNormal(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Vec3 Transform(const Vec3& v) const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "bool InverseTranspose()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "bool Inverse()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void Transpose()",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void SetRotate(const Vec3& v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void SetRotate(const Quat& v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void SetTranslate(const Vec3& v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void SetScale(const Vec3& v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void Set(const Vec3& x, const Vec3& y, const Vec3& z, const Vec3& w)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void set_axis_w(const Vec3& v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void set_axis_z(const Vec3& v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void set_axis_y(const Vec3& v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "void set_axis_x(const Vec3& v)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Vec3 get_axis_w() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Vec3 get_axis_z() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Vec3 get_axis_y() const",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "Mtx43",
      "declaration": "Vec3 get_axis_x() const",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "declaration": "as_f32 GetLength()",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "declaration": "void ClearExtParam()",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "declaration": "void SetExtParam(as_f32 ext_param)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "declaration": "void SetParam(int curve_type, int easing_type, array<math::Vec3>& easing_param, as_f32 ext_param)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "declaration": "void SetParam(int curve_type, int easing_type, array<math::Vec3>& easing_param)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "declaration": "void SetParam(int curve_type, int easing_type)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec3EasingParam",
      "declaration": "Vec3EasingParam &opAssign(const Vec3EasingParam &)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "declaration": "as_f32 GetLength()",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "declaration": "void ClearExtParam()",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "declaration": "void SetExtParam(as_f32 ext_param)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "declaration": "void SetParam(int curve_type, int easing_type, array<math::Vec2>& easing_param, as_f32 ext_param)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "declaration": "void SetParam(int curve_type, int easing_type, array<math::Vec2>& easing_param)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "declaration": "void SetParam(int curve_type, int easing_type)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "Vec2EasingParam",
      "declaration": "Vec2EasingParam &opAssign(const Vec2EasingParam &)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "declaration": "as_f32 GetLength()",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "declaration": "void ClearExtParam()",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "declaration": "void SetExtParam(as_f32 ext_param)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "declaration": "void SetParam(int curve_type, int easing_type, array<as_f32>& easing_param, as_f32 ext_param)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "declaration": "void SetParam(int curve_type, int easing_type, array<as_f32>& easing_param)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "declaration": "void SetParam(int curve_type, int easing_type)",
      "calling_convention": 3
    },
    {
      "namespace": "math::bezier",
      "object_name": "EasingParam",
      "declaration": "EasingParam &opAssign(const EasingParam &)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "RoundedNonuniformSpline",
      "declaration": "f32 getDistance(void)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "RoundedNonuniformSpline",
      "declaration": "Vec3 getVelocity(as_f32 time)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "RoundedNonuniformSpline",
      "declaration": "Vec3 getAcceleration(as_f32 time)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "RoundedNonuniformSpline",
      "declaration": "Vec3 getPosition(as_f32 time)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "RoundedNonuniformSpline",
      "declaration": "void build(void)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "RoundedNonuniformSpline",
      "declaration": "void addNode(const Vec3& pos)",
      "calling_convention": 3
    },
    {
      "namespace": "math",
      "object_name": "RoundedNonuniformSpline",
      "declaration": "RoundedNonuniformSpline &opAssign(const RoundedNonuniformSpline &)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DS",
      "declaration": "bool IsValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DS",
      "declaration": "void SetName(const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DS",
      "declaration": "const string& GetName() const",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DS",
      "declaration": "void set_v(int v)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DS",
      "declaration": "int get_v() const",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DF",
      "declaration": "bool IsValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DF",
      "declaration": "void SetName(const string& b, s32 ia=-1, s32 ib=-1, s32 ic=-1)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DF",
      "declaration": "const string& GetName() const",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DF",
      "declaration": "void set_v(bool v)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DF",
      "declaration": "bool get_v() const",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "bool IsScriptRoot() const",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "u32 GenerateWindowID()",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "string GetButtonPath(const string& button_name) const",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "string GetFullPath() const",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "bool IsCreateWindow()",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void DeleteWindow()",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "as_u32 AddChildWindow(const string& window_name, DebugWindowCallback ref func, any ref func_arg = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_Const_P ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_P ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_Const_D ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_D ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_Const_P ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_P ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_Const_D ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_D ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_Const_P ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_P ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_Const_D ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_D ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_Const_P ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_P ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_Const_D ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_D ref setter, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_Const_P ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_P ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_Const_D ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_D ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_Const_P ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_P ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_Const_D ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_D ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_Const_P ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_P ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_Const_D ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_D ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_Const_P ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_P ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_Const_D ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_D ref setter, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, math::Vec3& value, EditableCheckerDebugWindow_D ref editableChecker = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddFColorEdit(const string& button_name, math::Vec3& value, bool& is_editable)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_Const_P ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_P ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_Const_D ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_D ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_Const_P ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_P ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_Const_D ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_D ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_Const_P ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_P ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_Const_D ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_D ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_Const_P ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_P ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_Const_D ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_D ref setter, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_P ref getter, SetterDebugWindowF32_Const_P ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_P ref getter, SetterDebugWindowF32_P ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_P ref getter, SetterDebugWindowF32_Const_D ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_P ref getter, SetterDebugWindowF32_D ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_P ref getter, SetterDebugWindowF32_Const_P ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_P ref getter, SetterDebugWindowF32_P ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_P ref getter, SetterDebugWindowF32_Const_D ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_P ref getter, SetterDebugWindowF32_D ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_D ref getter, SetterDebugWindowF32_Const_P ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_D ref getter, SetterDebugWindowF32_P ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_D ref getter, SetterDebugWindowF32_Const_D ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_D ref getter, SetterDebugWindowF32_D ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_D ref getter, SetterDebugWindowF32_Const_P ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_D ref getter, SetterDebugWindowF32_P ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_D ref getter, SetterDebugWindowF32_Const_D ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_D ref getter, SetterDebugWindowF32_D ref setter, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_P ref getter, SetterDebugWindowS32_Const_P ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_P ref getter, SetterDebugWindowS32_P ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_P ref getter, SetterDebugWindowS32_Const_D ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_P ref getter, SetterDebugWindowS32_D ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_P ref getter, SetterDebugWindowS32_Const_P ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_P ref getter, SetterDebugWindowS32_P ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_P ref getter, SetterDebugWindowS32_Const_D ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_P ref getter, SetterDebugWindowS32_D ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_D ref getter, SetterDebugWindowS32_Const_P ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_D ref getter, SetterDebugWindowS32_P ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_D ref getter, SetterDebugWindowS32_Const_D ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_D ref getter, SetterDebugWindowS32_D ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_D ref getter, SetterDebugWindowS32_Const_P ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_D ref getter, SetterDebugWindowS32_P ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_D ref getter, SetterDebugWindowS32_Const_D ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_D ref getter, SetterDebugWindowS32_D ref setter, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_P ref getter, SetterDebugWindowVec3_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_P ref getter, SetterDebugWindowVec3_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_Const_D ref getter, SetterDebugWindowVec3_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowVec3_D ref getter, SetterDebugWindowVec3_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_P ref getter, SetterDebugWindowF32_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_P ref getter, SetterDebugWindowF32_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_P ref getter, SetterDebugWindowF32_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_P ref getter, SetterDebugWindowF32_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_P ref getter, SetterDebugWindowF32_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_P ref getter, SetterDebugWindowF32_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_P ref getter, SetterDebugWindowF32_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_P ref getter, SetterDebugWindowF32_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_D ref getter, SetterDebugWindowF32_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_D ref getter, SetterDebugWindowF32_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_D ref getter, SetterDebugWindowF32_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_Const_D ref getter, SetterDebugWindowF32_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_D ref getter, SetterDebugWindowF32_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_D ref getter, SetterDebugWindowF32_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_D ref getter, SetterDebugWindowF32_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowF32_D ref getter, SetterDebugWindowF32_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_P ref getter, SetterDebugWindowS32_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_P ref getter, SetterDebugWindowS32_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_P ref getter, SetterDebugWindowS32_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_P ref getter, SetterDebugWindowS32_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_P ref getter, SetterDebugWindowS32_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_P ref getter, SetterDebugWindowS32_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_P ref getter, SetterDebugWindowS32_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_P ref getter, SetterDebugWindowS32_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_D ref getter, SetterDebugWindowS32_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_D ref getter, SetterDebugWindowS32_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_D ref getter, SetterDebugWindowS32_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_Const_D ref getter, SetterDebugWindowS32_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_D ref getter, SetterDebugWindowS32_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_D ref getter, SetterDebugWindowS32_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_D ref getter, SetterDebugWindowS32_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowS32_D ref getter, SetterDebugWindowS32_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_Const_P ref getter, SetterDebugWindowBool_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_Const_P ref getter, SetterDebugWindowBool_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_Const_P ref getter, SetterDebugWindowBool_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_Const_P ref getter, SetterDebugWindowBool_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_P ref getter, SetterDebugWindowBool_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_P ref getter, SetterDebugWindowBool_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_P ref getter, SetterDebugWindowBool_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_P ref getter, SetterDebugWindowBool_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_Const_D ref getter, SetterDebugWindowBool_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_Const_D ref getter, SetterDebugWindowBool_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_Const_D ref getter, SetterDebugWindowBool_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_Const_D ref getter, SetterDebugWindowBool_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_D ref getter, SetterDebugWindowBool_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_D ref getter, SetterDebugWindowBool_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_D ref getter, SetterDebugWindowBool_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, GetterDebugWindowBool_D ref getter, SetterDebugWindowBool_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, math::Vec3& value, math::Vec3 min, math::Vec3 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, f32& value, f32 min, f32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, s32& value, s32 min, s32 max)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, math::Vec3& value)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, f32& value)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, s32& value)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddEdit(const string& button_name, bool& value)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_Const_P ref getter, GetterDebugWindowS32_Const_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_Const_P ref getter, GetterDebugWindowS32_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_Const_P ref getter, GetterDebugWindowS32_Const_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_Const_P ref getter, GetterDebugWindowS32_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_P ref getter, GetterDebugWindowS32_Const_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_P ref getter, GetterDebugWindowS32_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_P ref getter, GetterDebugWindowS32_Const_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_P ref getter, GetterDebugWindowS32_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_Const_D ref getter, GetterDebugWindowS32_Const_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_Const_D ref getter, GetterDebugWindowS32_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_Const_D ref getter, GetterDebugWindowS32_Const_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_Const_D ref getter, GetterDebugWindowS32_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_D ref getter, GetterDebugWindowS32_Const_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_D ref getter, GetterDebugWindowS32_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_D ref getter, GetterDebugWindowS32_Const_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, GetterDebugWindowS32_D ref getter, GetterDebugWindowS32_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_Const_P ref getter, GetterDebugWindowS32_Const_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_Const_P ref getter, GetterDebugWindowS32_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_Const_P ref getter, GetterDebugWindowS32_Const_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_Const_P ref getter, GetterDebugWindowS32_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_P ref getter, GetterDebugWindowS32_Const_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_P ref getter, GetterDebugWindowS32_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_P ref getter, GetterDebugWindowS32_Const_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_P ref getter, GetterDebugWindowS32_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_Const_D ref getter, GetterDebugWindowS32_Const_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_Const_D ref getter, GetterDebugWindowS32_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_Const_D ref getter, GetterDebugWindowS32_Const_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_Const_D ref getter, GetterDebugWindowS32_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_D ref getter, GetterDebugWindowS32_Const_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_D ref getter, GetterDebugWindowS32_P ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_D ref getter, GetterDebugWindowS32_Const_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, GetterDebugWindowS32_D ref getter, GetterDebugWindowS32_D ref max_getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowVec3_Const_P ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowVec3_P ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowVec3_Const_D ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowVec3_D ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowF32_Const_P ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowF32_P ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowF32_Const_D ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowF32_D ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowS32_Const_P ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowS32_P ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowS32_Const_D ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowS32_D ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowBool_Const_P ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowBool_P ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowBool_Const_D ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, GetterDebugWindowBool_D ref getter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, const string& fmt, s32& value, s32& max_value)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddUsage(const string& button_name, s32& value, s32& max_value)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, math::Vec3& value)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, f32& value)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, s32& value)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddWatch(const string& button_name, bool& value)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddBr(const string& path_name = \"\")",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddSeparatorLong(const string& path_name = \"\")",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddSeparator(const string& path_name = \"\")",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddLabelEx(const string& button_name, util::Color4f color=util::Color4f::Gray(), f32 scale = 1.0f)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddLabel(const string& button_name)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_Const_P ref getter, SetterDebugWindowS32_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_Const_P ref getter, SetterDebugWindowS32_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_Const_P ref getter, SetterDebugWindowS32_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_Const_P ref getter, SetterDebugWindowS32_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_P ref getter, SetterDebugWindowS32_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_P ref getter, SetterDebugWindowS32_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_P ref getter, SetterDebugWindowS32_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_P ref getter, SetterDebugWindowS32_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_Const_D ref getter, SetterDebugWindowS32_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_Const_D ref getter, SetterDebugWindowS32_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_Const_D ref getter, SetterDebugWindowS32_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_Const_D ref getter, SetterDebugWindowS32_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_D ref getter, SetterDebugWindowS32_Const_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_D ref getter, SetterDebugWindowS32_P ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_D ref getter, SetterDebugWindowS32_Const_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, GetterDebugWindowS32_D ref getter, SetterDebugWindowS32_D ref setter)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddRadioButton(const string& button_name, s32 index, s32& value)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddSimpleButton(const string& button_name, SimpleCallback ref simple_func)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "void AddButton(const string& button_name, DebugWindowCallback ref func, any ref func_arg = null)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugWindow",
      "declaration": "string GetWindowName() const",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugCanvas",
      "declaration": "void Print(string title)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugCanvas",
      "declaration": "void Test(TestCallback ref func, f32 begin_t, f32 end_t, s32 t_num)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugCanvas",
      "declaration": "void SetPos(f32 x, f32 y)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugCanvas",
      "declaration": "void Clear()",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugCanvas",
      "declaration": "void SetScale(f32 canvas_scale_left, f32 canvas_scale_right, f32 canvas_scale_botom, f32 canvas_scale_top)",
      "calling_convention": 3
    },
    {
      "namespace": "dbg",
      "object_name": "DebugCanvas",
      "declaration": "void SetParam(s32 canvas_x, s32 canvas_y, f32 canvas_scale_left = 0.0f, f32 canvas_scale_right = 100.0f, f32 canvas_scale_botom = 0.0f, f32 canvas_scale_top = 100.0f, bool over_write = true)",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleList",
      "declaration": "sobj::Handle back()",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleList",
      "declaration": "sobj::Handle front()",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleList",
      "declaration": "as_s32 size() const",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleList",
      "declaration": "bool empty() const",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleList",
      "declaration": "HandleIterator end()",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleList",
      "declaration": "HandleIterator begin()",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleIterator",
      "declaration": "sobj::Handle GetHandle()",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPostDec()",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPreDec()",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPostInc()",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPreInc()",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleIterator",
      "declaration": "bool opEquals(const HandleIterator &)",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opAssign(const HandleIterator &)",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleList",
      "declaration": "mobj::Handle back()",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleList",
      "declaration": "mobj::Handle front()",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleList",
      "declaration": "as_s32 size() const",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleList",
      "declaration": "bool empty() const",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleList",
      "declaration": "HandleIterator end()",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleList",
      "declaration": "HandleIterator begin()",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleIterator",
      "declaration": "mobj::Handle GetHandle()",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPostDec()",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPreDec()",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPostInc()",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPreInc()",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleIterator",
      "declaration": "bool opEquals(const HandleIterator &)",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opAssign(const HandleIterator &)",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleList",
      "declaration": "item::Handle back()",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleList",
      "declaration": "item::Handle front()",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleList",
      "declaration": "as_s32 size() const",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleList",
      "declaration": "bool empty() const",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleList",
      "declaration": "HandleIterator end()",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleList",
      "declaration": "HandleIterator begin()",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleIterator",
      "declaration": "item::Handle GetHandle()",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPostDec()",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPreDec()",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPostInc()",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPreInc()",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleIterator",
      "declaration": "bool opEquals(const HandleIterator &)",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opAssign(const HandleIterator &)",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleList",
      "declaration": "party::Handle back()",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleList",
      "declaration": "party::Handle front()",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleList",
      "declaration": "as_s32 size() const",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleList",
      "declaration": "bool empty() const",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleList",
      "declaration": "HandleIterator end()",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleList",
      "declaration": "HandleIterator begin()",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleIterator",
      "declaration": "party::Handle GetHandle()",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPostDec()",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPreDec()",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPostInc()",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPreInc()",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleIterator",
      "declaration": "bool opEquals(const HandleIterator &)",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opAssign(const HandleIterator &)",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleList",
      "declaration": "hariko::Handle back()",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleList",
      "declaration": "hariko::Handle front()",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleList",
      "declaration": "as_s32 size() const",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleList",
      "declaration": "bool empty() const",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleList",
      "declaration": "HandleIterator end()",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleList",
      "declaration": "HandleIterator begin()",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleIterator",
      "declaration": "hariko::Handle GetHandle()",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPostDec()",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPreDec()",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPostInc()",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPreInc()",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleIterator",
      "declaration": "bool opEquals(const HandleIterator &)",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opAssign(const HandleIterator &)",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleList",
      "declaration": "npc::Handle back()",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleList",
      "declaration": "npc::Handle front()",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleList",
      "declaration": "as_s32 size() const",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleList",
      "declaration": "bool empty() const",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleList",
      "declaration": "HandleIterator end()",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleList",
      "declaration": "HandleIterator begin()",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleIterator",
      "declaration": "npc::Handle GetHandle()",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPostDec()",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPreDec()",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPostInc()",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opPreInc()",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleIterator",
      "declaration": "bool opEquals(const HandleIterator &)",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "HandleIterator",
      "declaration": "HandleIterator &opAssign(const HandleIterator &)",
      "calling_convention": 3
    },
    {
      "namespace": "navigator",
      "object_name": "Handle",
      "declaration": "chr::Handle opImplConv()",
      "calling_convention": 3
    },
    {
      "namespace": "navigator",
      "object_name": "Handle",
      "declaration": "bool IsValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "navigator",
      "object_name": "Handle",
      "declaration": "bool opEquals(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "navigator",
      "object_name": "Handle",
      "declaration": "Handle &opAssign(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "Handle",
      "declaration": "chr::Handle opImplConv()",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "Handle",
      "declaration": "bool IsValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "Handle",
      "declaration": "bool opEquals(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "sobj",
      "object_name": "Handle",
      "declaration": "Handle &opAssign(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "lobj",
      "object_name": "Handle",
      "declaration": "chr::Handle opImplConv()",
      "calling_convention": 3
    },
    {
      "namespace": "lobj",
      "object_name": "Handle",
      "declaration": "bool IsValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "lobj",
      "object_name": "Handle",
      "declaration": "bool opEquals(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "lobj",
      "object_name": "Handle",
      "declaration": "Handle &opAssign(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "Handle",
      "declaration": "chr::Handle opImplConv()",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "Handle",
      "declaration": "bool IsValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "Handle",
      "declaration": "bool opEquals(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "mobj",
      "object_name": "Handle",
      "declaration": "Handle &opAssign(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "gmap",
      "object_name": "Handle",
      "declaration": "chr::Handle opImplConv()",
      "calling_convention": 3
    },
    {
      "namespace": "gmap",
      "object_name": "Handle",
      "declaration": "bool IsValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "gmap",
      "object_name": "Handle",
      "declaration": "bool opEquals(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "gmap",
      "object_name": "Handle",
      "declaration": "Handle &opAssign(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "Handle",
      "declaration": "chr::Handle opImplConv()",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "Handle",
      "declaration": "bool IsValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "Handle",
      "declaration": "bool opEquals(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "item",
      "object_name": "Handle",
      "declaration": "Handle &opAssign(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "Handle",
      "declaration": "chr::Handle opImplConv()",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "Handle",
      "declaration": "bool IsValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "Handle",
      "declaration": "bool opEquals(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "party",
      "object_name": "Handle",
      "declaration": "Handle &opAssign(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "Handle",
      "declaration": "chr::Handle opImplConv()",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "Handle",
      "declaration": "bool IsValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "Handle",
      "declaration": "bool opEquals(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "hariko",
      "object_name": "Handle",
      "declaration": "Handle &opAssign(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "Handle",
      "declaration": "chr::Handle opImplConv()",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "Handle",
      "declaration": "bool IsValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "Handle",
      "declaration": "bool opEquals(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "npc",
      "object_name": "Handle",
      "declaration": "Handle &opAssign(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "player",
      "object_name": "Handle",
      "declaration": "chr::Handle opImplConv()",
      "calling_convention": 3
    },
    {
      "namespace": "player",
      "object_name": "Handle",
      "declaration": "bool IsValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "player",
      "object_name": "Handle",
      "declaration": "bool opEquals(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "player",
      "object_name": "Handle",
      "declaration": "Handle &opAssign(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "bool IsValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "bool opEquals(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "chr",
      "object_name": "Handle",
      "declaration": "Handle &opAssign(const Handle &)",
      "calling_convention": 3
    },
    {
      "namespace": "cases",
      "object_name": "ObjHandle",
      "declaration": "bool isValid(void) const",
      "calling_convention": 3
    },
    {
      "namespace": "cases",
      "object_name": "ObjHandle",
      "declaration": "ObjHandle &opAssign(const ObjHandle &)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "as_s32 getRingNo() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "as_s32 getSlideNo() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "void setSlideNo(as_s32 no)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "void setRingNo(as_s32 no)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "void setSlideRingNo(as_s32 sno, as_s32 rno)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "RangePos moveDepth(int d) const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "RangePos move(int a, int d, float dir=0.0f) const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "void set(const math::Vec3& pos)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "void origin()",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "as_f32 getDist() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "as_f32 getDir() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "math::Vec3 getPos() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "as_s32 getIndex() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "void setDepth(as_s32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "void setAngle(as_s32 v)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "as_s32 getDepth() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "as_s32 getAngle() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "bool opEquals(const RangePos&) const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "RangePos",
      "declaration": "RangePos &opAssign(const RangePos&)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "EffectHandle",
      "declaration": "bool isInvalid() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "EffectHandle",
      "declaration": "bool isValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "EffectHandle",
      "declaration": "void clear()",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "EffectHandle",
      "declaration": "EffectHandle &opAssign(const EffectHandle&)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "MapHandle",
      "declaration": "bool isInvalid() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "MapHandle",
      "declaration": "bool isValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "MapHandle",
      "declaration": "void clear()",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "MapHandle",
      "declaration": "MapHandle &opAssign(const MapHandle&)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "MobjHandle",
      "declaration": "bool isInvalid() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "MobjHandle",
      "declaration": "bool isValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "MobjHandle",
      "declaration": "void clear()",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "MobjHandle",
      "declaration": "MobjHandle &opAssign(const MobjHandle&)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "ItemHandle",
      "declaration": "ItemHandle &opAssign(const ItemHandle&)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "PartsHandle",
      "declaration": "bool isInvalid() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "PartsHandle",
      "declaration": "bool isValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "PartsHandle",
      "declaration": "void clear()",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "PartsHandle",
      "declaration": "bool opEquals(const PartsHandle&)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "PartsHandle",
      "declaration": "PartsHandle &opAssign(const PartsHandle&)",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "UnitHandle",
      "declaration": "bool isInvalid() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "UnitHandle",
      "declaration": "bool isValid() const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "UnitHandle",
      "declaration": "void clear()",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "UnitHandle",
      "declaration": "bool opEquals(const UnitHandle&) const",
      "calling_convention": 3
    },
    {
      "namespace": "btl",
      "object_name": "UnitHandle",
      "declaration": "UnitHandle &opAssign(const UnitHandle&)",
      "calling_convention": 3
    }
  ],
  "global_functions": [
    {
      "namespace": "ui::staffcredit",
      "declaration": "void DebugCreditVisible(bool f)"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "bool GetUseDebugText()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "void SetUseDebugText(bool f)"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "bool GetUseDebugRegion()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "void SetUseDebugRegion(bool f)"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "int GetRegion()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "void ChangeDebugRegion(int region)"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "void Reload()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "void End()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "void Begin()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "void SetPlayTimeFrame(float frame)"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "float GetStaffCreditTime()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "float GetCenterSpace()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "float GetScrollSpeed()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "bool Next()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "void CorrectCurrentCredit()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "float GetCurrentCreditStartFrame()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "int GetCurrentCreditId()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "int GetCurrentCreditAnimeChannel()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "int GetCurrentCreditMoveType()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "int GetCurrentCreditAlign()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "float GetCurrentCreditBaseX()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "float GetCurrentCreditAppearRate()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "float GetCurrentCreditScale()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "float GetCurrentCreditRotZ()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "float GetCurrentCreditSpeed()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "float GetCurrentCreditLifeTime()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "math::Vec2 GetCurrentCreditEnd()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "math::Vec2 GetCurrentCreditStart()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "float GetCurrentCreditStartTime()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "int GetCurrentCreditLocation()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "::string GetCurrentCreditAnime()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "::string GetCurrentCreditNameLabel()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "::string GetCurrentCreditLabel()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "::string GetCurrentCreditName()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "int GetCurrentCreditType()"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "void Create()"
    },
    {
      "namespace": "party",
      "declaration": "void ChangeEffectSESet(Handle handle, string party_id)"
    },
    {
      "namespace": "party",
      "declaration": "void EnableJump(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "void DisableJump(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "void JumpDir(Handle handle, f32 dir)"
    },
    {
      "namespace": "party",
      "declaration": "void WarpFollow(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "void SetShipMode(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "void SetCheckToHitMapSide(Handle handle, bool enable)"
    },
    {
      "namespace": "party",
      "declaration": "void SetCheckToHitMapUpper(Handle handle, bool enable)"
    },
    {
      "namespace": "party",
      "declaration": "void SetCheckToHitMapLower(Handle handle, bool enable)"
    },
    {
      "namespace": "party",
      "declaration": "bool IsStay(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "bool IsActioinBusy(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "void StopActionScript(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "void ResetAction(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "void SwitchAction(Handle handle, const string& func_name)"
    },
    {
      "namespace": "party",
      "declaration": "void SetAffect(Handle handle, int affect_type, int msec)"
    },
    {
      "namespace": "party",
      "declaration": "void EnableStepEffectWhileStop(Handle handle, bool enable)"
    },
    {
      "namespace": "party",
      "declaration": "s32 GetPartyNum()"
    },
    {
      "namespace": "party",
      "declaration": "Handle GetParty(int idx)"
    },
    {
      "namespace": "party",
      "declaration": "bool IsStop(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "bool IsStop()"
    },
    {
      "namespace": "party",
      "declaration": "void Restart(Handle handle, string name)"
    },
    {
      "namespace": "party",
      "declaration": "void Restart(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "void Restart()"
    },
    {
      "namespace": "party",
      "declaration": "void StopWait(Handle handle, string name, bool wait_ground = true)"
    },
    {
      "namespace": "party",
      "declaration": "void StopWait(Handle handle, bool wait_ground = true)"
    },
    {
      "namespace": "party",
      "declaration": "void StopWait(bool wait_ground = true)"
    },
    {
      "namespace": "party",
      "declaration": "void Stop(Handle handle, string name, bool wait_ground = false)"
    },
    {
      "namespace": "party",
      "declaration": "void Stop(Handle handle, bool wait_ground = false)"
    },
    {
      "namespace": "party",
      "declaration": "void Stop(bool wait_ground = false)"
    },
    {
      "namespace": "party",
      "declaration": "void EnableStopResolve(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "void EnableStopFall(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "void ResetLostLevel(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "chr::Handle GetTargetChr(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "math::Vec3 GetValidHomePos(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "math::Vec3 CalcHomePos(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "void Delete(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "void RemoveParty(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "bool CheckInParty(string name)"
    },
    {
      "namespace": "party",
      "declaration": "void AddParty(Handle handle)"
    },
    {
      "namespace": "party",
      "declaration": "Handle Entry(const string& party_id, bool add_party = false)"
    },
    {
      "namespace": "ui::numpad",
      "declaration": "as::string Open()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "int GetPathNum()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "int GetPath(int index)"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "int GetStepNumAll()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "bool IsSuccess()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "bool IsAccess()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "bool IsHint()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "bool IsGoal()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "const as::string GetSelectKeyItem()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "bool IsDecide()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "int GetPanelPattern(int id)"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "int GetAnswerImage(int x, int y)"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "int GetImage(int x, int y)"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "int GetHeight()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "int GetWidth()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "void End()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "void ResetHistory()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "void Restart(int hintLevel=0)"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "bool IsClose()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "void WaitAnimeEnd()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "void Hide()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "void Show()"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "void Open(bool answerPanel=true, bool finished=false)"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "void Ready3x3(as_s32 stepMax2nd=8)"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "void Ready2x2(as_s32 stepMax2nd=8)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void Close(as_u64& work)"
    },
    {
      "namespace": "ui::model",
      "declaration": "math::Vec3 GetLocatorPos(as_u64& work, const as::string& node)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void CreateLocator(as_u64& work, const as::string& node)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetupCoin(as_u64& work, int num)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void ChangeLayer(as_u64& work)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void Hide(as_u64& work, const as::string& node)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void Show(as_u64& work, const as::string& node)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void ChangeImage(as_u64& work, const as::string& label)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void WaitAnimeEnd(as_u64& work)"
    },
    {
      "namespace": "ui::model",
      "declaration": "bool HasAnime(as_u64& work, const as::string& name)"
    },
    {
      "namespace": "ui::model",
      "declaration": "float GetAnimeFrameNum(as_u64& work, int index = 0)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetAnimeFrame(as_u64& work, float frame)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetAnimeSpeed(as_u64& work, float step)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void ChangeAnime(as_u64& work, const as::string& anime, int index=0, bool force=false)"
    },
    {
      "namespace": "ui::model",
      "declaration": "int CalcTextWidth(as_u64& work, const as::string& node, const as::string& msgLabel)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetText(as_u64& work, const as::string& node, const as::string& msgLabel, const as::string& value1, int value2)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetText(as_u64& work, const as::string& node, const as::string& msgLabel, int value1, int value2)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetText(as_u64& work, const as::string& node, const as::string& msgLabel, int value)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetText(as_u64& work, const as::string& node, const as::string& msgLabel)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetTextDrawFlagLeft(as_u64& work, const as::string& node)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetTextCursor(as_u64& work, const as::string& node, float x, float y)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetTextColorLaboGreen(as_u64& work, const as::string& node)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetTextLineHeight(as_u64& work, const as::string& node, int height)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetRot(as_u64& work, math::Vec3& rotate)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetRot(as_u64& work, float x, float y, float z)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetScale(as_u64& work, math::Vec3& scale)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetPos(as_u64& work, math::Vec3& pos)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void SetPos(as_u64& work, float x, float y, float z=0)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void Hide(as_u64& work)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void Show(as_u64& work)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void CreateTo3DScene(as_u64& work, const as::string& modelID)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void CreateToMonitorScene(as_u64& work, const as::string& modelID)"
    },
    {
      "namespace": "ui::model",
      "declaration": "as_u64 Create(const as::string& modelID, bool priority=false)"
    },
    {
      "namespace": "ui::model",
      "declaration": "void Create(as_u64& work, const as::string& modelID, bool priority=false)"
    },
    {
      "namespace": "ui::submarine",
      "declaration": "void SetDir(float dir_x, float dir_y)"
    },
    {
      "namespace": "ui::submarine",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::submarine",
      "declaration": "void Open()"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "void ShowRankingFrame(bool show=true)"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "void ShowScore(int index, bool show=true)"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "void ShowExplain(bool show=true)"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "void SetSelectLevel(int level)"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "int GetSelectLevel()"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "int GetSelectMode()"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "void SetMode(int mode, bool result=false)"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "void Wait()"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "void NewRecord(bool show, bool isUpdate=true)"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "void SetTrialScore(int rank, int clearNum=0)"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "void SetDrillScore(int level, int clearNum, int clearTime=0)"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "void SetDrillPlayableLevel(int level)"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "void Open()"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "void ShowScore(int rank, bool show=true)"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "void SetCurrentScore(int time)"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "void NewRecord(bool show)"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "void SetBarLabel(const as::string& msgLabel)"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "void SetMenuOffset(math::Vec3& offset)"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "void ShowExplain(bool show=true)"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "void ShowFrame(bool show=true)"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "void Clear()"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "int GetSelect()"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "int Wait()"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "void SetCursor(int index)"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "void Add(const as::string& msgLabel, bool enable=true, int time1st=0, int time2nd=0, int time3rd=0)"
    },
    {
      "namespace": "ui::battlelab_vs",
      "declaration": "void Open()"
    },
    {
      "namespace": "ui::stampcard",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::stampcard",
      "declaration": "void Wait()"
    },
    {
      "namespace": "ui::stampcard",
      "declaration": "void Stamp(int id)"
    },
    {
      "namespace": "ui::stampcard",
      "declaration": "void Open()"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "void SetPos(const math::Vec3& pos)"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "void Hide()"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "void Show()"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "void SetResultNG(int category=-1, int level=-1)"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "void SetResultOK(int category=-1, int level=-1)"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "int getSelectLevel()"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "int getSelectCategory()"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "bool isDecide()"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "void SelectStart(bool randomMode = false)"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "void SetParam(int cursorStayFrame, int cursorSlideMax, int cursorSlideMin, int cursorShiftMax, int cursorShiftMin, int cursorShiftStayFrame, int exSelectScore, int limitedCursorCount, int unlimitedCursorCount, int decideWaitFrame, ::array<int>& delayTbl)"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "void SetTargetScore(int targetScore=100, bool visible=true)"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "void SetQuizPoint(int category, int level, int point)"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "void ResetSelect()"
    },
    {
      "namespace": "ui::quizboard",
      "declaration": "void Open(int level1Score=10, int level2Score=30, int level3Score=50)"
    },
    {
      "namespace": "ui::slideshow",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::slideshow",
      "declaration": "void SetScale(float xScale, float yScale)"
    },
    {
      "namespace": "ui::slideshow",
      "declaration": "void SetPos(float x, float y)"
    },
    {
      "namespace": "ui::slideshow",
      "declaration": "void ChangeAnime(const as::string& label)"
    },
    {
      "namespace": "ui::slideshow",
      "declaration": "void ChangeImage(const as::string& label)"
    },
    {
      "namespace": "ui::slideshow",
      "declaration": "void Open(const as::string& label=\"W3G2_SlideShow\")"
    },
    {
      "namespace": "ui::seamap",
      "declaration": "void SetArrow(as_u64& work, bool arrowMode, int degree=0)"
    },
    {
      "namespace": "ui::seamap",
      "declaration": "void WaitAnimeEnd(as_u64& work, const as::string& lct)"
    },
    {
      "namespace": "ui::seamap",
      "declaration": "void ChangeAnime(as_u64& work, const as::string& lct, const as::string& anime)"
    },
    {
      "namespace": "ui::seamap",
      "declaration": "void SetVisible(as_u64& work, const as::string& anime, bool visible)"
    },
    {
      "namespace": "ui::seamap",
      "declaration": "void Discover(as_u64& work, const as::string& name)"
    },
    {
      "namespace": "ui::seamap",
      "declaration": "bool IsSalvaged(const as::string& name)"
    },
    {
      "namespace": "ui::seamap",
      "declaration": "void ZoomRestore(as_u64& work)"
    },
    {
      "namespace": "ui::seamap",
      "declaration": "void Zoom(as_u64& work, const as::string& name, bool enableFocus=true)"
    },
    {
      "namespace": "ui::seamap",
      "declaration": "void Close(as_u64& work)"
    },
    {
      "namespace": "ui::seamap",
      "declaration": "void Wait(as_u64& work)"
    },
    {
      "namespace": "ui::seamap",
      "declaration": "void Open(as_u64& work, bool shipVisible=true, bool soundMute=false)"
    },
    {
      "namespace": "ui::seamap",
      "declaration": "void Open(bool shipVisible=true, bool soundMute=false)"
    },
    {
      "namespace": "ui::guidemap",
      "declaration": "void Close(as_u64& work)"
    },
    {
      "namespace": "ui::guidemap",
      "declaration": "void Wait(as_u64& work)"
    },
    {
      "namespace": "ui::guidemap",
      "declaration": "void Open(as_u64& work, int arrowIndex=0, bool enableSE=true)"
    },
    {
      "namespace": "ui::guidemap",
      "declaration": "void Open(int arrowIndex=0, bool enableSE=true)"
    },
    {
      "namespace": "ui::save",
      "declaration": "void Hide()"
    },
    {
      "namespace": "ui::save",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::save",
      "declaration": "void SetPosition(float x, float y)"
    },
    {
      "namespace": "ui::save",
      "declaration": "void Open(float x, float y, bool skipInAnime=false)"
    },
    {
      "namespace": "ui::readyfire",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::readyfire",
      "declaration": "void Fire()"
    },
    {
      "namespace": "ui::readyfire",
      "declaration": "void Out()"
    },
    {
      "namespace": "ui::readyfire",
      "declaration": "void Ready()"
    },
    {
      "namespace": "ui::readygo",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::readygo",
      "declaration": "void Go()"
    },
    {
      "namespace": "ui::readygo",
      "declaration": "void Ready()"
    },
    {
      "namespace": "ui::event",
      "declaration": "int DiscSelector(::array<as::string>& array)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "int AmuletSelect(const as::string& shopDataName, float priceRate=1.0f)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "bool IsDiscountAmulet(const as::string& item_id)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "bool IsSoldOut(const as::string& shopKind)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "bool Buy(const as::string& shopKind, int index, float priceRate=1.0f)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "bool AddCheck(const as::string& itemId)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "bool BuyItem(const as::string& itemId)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "bool BuyCheck(const as::string& shopKind, int index, float priceRate, bool& coinCheck, bool& pouchCheck)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "int ShopGetItemIndex(const as::string& shopKind, int index)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "int Select(const as::string& shopDataName, float priceRate=1.0f)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "void ItemEntry(const as::string& shopKind)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "void ItemDelete(const as::string& shopKind)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "void Resale(const as::string& shopKind, const as::string& itemID)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "int SelectList(::array<as::string>& list)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "bool GetList(const as::string& shopKind, ::array<as::string>& list)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "void GetNewItemList(const as::string& shopKind, ::array<as::string>& list)"
    },
    {
      "namespace": "ui::shop",
      "declaration": "void SetCamera(const as::string& shopKind)"
    },
    {
      "namespace": "ui::achieve",
      "declaration": "bool CheckCompleteBlock()"
    },
    {
      "namespace": "ui::achieve",
      "declaration": "bool CheckCompleteCollectable()"
    },
    {
      "namespace": "ui::achieve",
      "declaration": "bool CheckCompleteHole()"
    },
    {
      "namespace": "ui::achieve",
      "declaration": "bool CheckCompleteKinopio()"
    },
    {
      "namespace": "ui::achieve",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::achieve",
      "declaration": "void Open(const as::string& courseLabel, const as::string& eventLabel, const as::string& colorAnime=\"Color_Kinopio\")"
    },
    {
      "namespace": "ui::announce",
      "declaration": "void Enable()"
    },
    {
      "namespace": "ui::announce",
      "declaration": "void Disable()"
    },
    {
      "namespace": "ui::announce",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::announce",
      "declaration": "void EntryNoWaitTime(as::string& id)"
    },
    {
      "namespace": "ui::announce",
      "declaration": "void EntryDelay(as::string& id)"
    },
    {
      "namespace": "ui::announce",
      "declaration": "void Entry(as::string& id)"
    },
    {
      "namespace": "ui::labo_timer",
      "declaration": "void CountDownMode()"
    },
    {
      "namespace": "ui::labo_timer",
      "declaration": "void CountUpMode()"
    },
    {
      "namespace": "ui::labo_timer",
      "declaration": "int GetRawTime()"
    },
    {
      "namespace": "ui::labo_timer",
      "declaration": "int GetTime()"
    },
    {
      "namespace": "ui::labo_timer",
      "declaration": "void Stop()"
    },
    {
      "namespace": "ui::labo_timer",
      "declaration": "bool IsEnd()"
    },
    {
      "namespace": "ui::labo_timer",
      "declaration": "void Start()"
    },
    {
      "namespace": "ui::labo_timer",
      "declaration": "void Reset(int sec)"
    },
    {
      "namespace": "ui::labo_timer",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::labo_timer",
      "declaration": "void Open(int layout=ui::timer::Layout_Top)"
    },
    {
      "namespace": "ui::timer",
      "declaration": "int GetTime()"
    },
    {
      "namespace": "ui::timer",
      "declaration": "void Stop()"
    },
    {
      "namespace": "ui::timer",
      "declaration": "bool IsEnd()"
    },
    {
      "namespace": "ui::timer",
      "declaration": "void Start()"
    },
    {
      "namespace": "ui::timer",
      "declaration": "void Reset(int sec)"
    },
    {
      "namespace": "ui::timer",
      "declaration": "void Close()"
    },
    {
      "namespace": "ui::timer",
      "declaration": "void Open(int layout=ui::timer::Layout_Default)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void WaitItemSelect()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void OpenItemSelect(bool forTutorial=false)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void ForceOpenItemTimer(bool flag, int type=0)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "float GetItemTimerAnimeFrame(int restSec, int maxSec)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void SetItemTimerRedLine(int sec)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void SetItemTimerLabel(const as::string& msgLabel)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void MaxKpUp(int maxKp)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void ChangeAnime1upKinoko(const as::string& anime=\"\")"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void MaxHpUp(int maxHp)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void CloseBar()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void SetBarLabelKey(const as::string& msgLabel, bool alignRight=false)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void SetBarLabel(const as::string& msgLabel, bool alignRight=false)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void OpenBar()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void OpenReadyGo()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void CloseCaption()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void OpenCaption(const as::string& msgLabel)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "const as::string GetCaptionCourseName()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void EnableCoinSE()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void SetAutoCloseAlertHP(bool autoClose=true)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void SetForceAlertHP(bool force=true)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void FixHP(bool flag)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void DisableHeart()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void EnableHeart(bool damageEffect=false, bool shipMode=false)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void EnableKP()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void Refresh()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void DisableKP()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void WaitHP()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void ForceOpenHP(bool flag)"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void CtrlAuto()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void CtrlForceOpenCoinKP()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void CtrlForceOpenKP()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void CtrlForceOpenHP()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void EarlyOpenCoin()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void CtrlForceOpenCoin()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void CtrlForceClose()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void CtrlForceOpen()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "int GetDebugBellDistance()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "int GetDebugBell()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void CloseBell()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void OpenBell(const as::string& colorAnime=\"Icon_Kinopio\")"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void CloseBalloon()"
    },
    {
      "namespace": "ui::hud",
      "declaration": "void OpenBalloon(const as::string& button_label, const as::string& msg_label, math::Vec3& offset = math::Vec3::Zero())"
    },
    {
      "namespace": "font",
      "declaration": "void ReplaceFont(int idx, const string& path)"
    },
    {
      "namespace": "sys::prepo",
      "declaration": "void Event_HatenaBlocks(const ::array<as::string>& list)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void ResetViewingItemId()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void LoadViewingItemProperty(const as::string& id)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void SetViewingItemId(const as::string& id)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void SetCollectableRendererParam(math::Vec3 origin, math::Vec3 pos, math::Vec3 up, math::Vec3 at)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void SetChangeLayerRenderPass(chr::Handle handle)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void SetKinopioPointForDebug()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void CompleteKinopioForDebug()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void CompleteEnemyForDebug()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void CompleteCollectableForDebug()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void FullOpenForDebug()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void HideSoundCaption()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "::string GetWallColor(int page)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "::string GetWallName(int page)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "bool IsVisibleCategory(const as::string& category)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "bool IsCompleteEnemy()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "bool IsCompleteKinopio()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "bool IsCompleteCollectable()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "bool IsCompleteSound()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "bool IsCompleteArt()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "bool IsComplete(int type)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "bool IsExistNewItem(int type)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "math::Vec3 GetBoundingCenter(chr::Handle handle)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void GetAABB(chr::Handle handle, const as::string& name, math::Vec3& min, math::Vec3& max)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void SetKinopioParam(chr::Handle handle, int group, const as::string& name = \"\")"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void SetEnemyParam(chr::Handle handle, int group, const as::string& name = \"\")"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void SetCollectableParam(chr::Handle handle, int group, const as::string& name = \"\")"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void SetSoundParam(chr::Handle handle, int group)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void SetArtParam(chr::Handle handle, int group, const as::string& name = \"\")"
    },
    {
      "namespace": "ui::museum",
      "declaration": "bool IsDetailView()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "int GetCurrentPage()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void WaitEvent()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void Begin(int page)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void Sequence()"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void SetEvent(int type, const as::string& name)"
    },
    {
      "namespace": "ui::museum",
      "declaration": "void Create(int type)"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void BindCamera(chr::Handle handle, float dist)"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "bool IsCatchable()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void Restart()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void Pause()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "bool IsCollectionMode()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "bool IsSearchMode()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void HideArm()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void ShowArm()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void CancelCatch()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void SetValveMode(chr::Handle handle, const string& pick_parent)"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void SetKeyMode(chr::Handle handle, const string& left_lct, const string& right_lct)"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "math::Vec3 GetHandPos()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "math::Quat GetQuat()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void DisableControl()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void EnableControl()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void DisableTreasure()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void EnableTreasure()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void GetTreasureBoxList(array<string>& list)"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void SetCollectionMode()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void SetSearchMode()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "math::Vec2 GetJoyconPos()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void Calib()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void SetMaxArmLength(float length)"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void SetArmPos(const math::Vec3& left_pos, const math::Vec3& right_pos)"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void End()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "bool IsBusy()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void Begin()"
    },
    {
      "namespace": "hand::submarine",
      "declaration": "void Init()"
    },
    {
      "namespace": "mov",
      "declaration": "void SetVolume(float vol)"
    },
    {
      "namespace": "mov",
      "declaration": "void Wait()"
    },
    {
      "namespace": "mov",
      "declaration": "void Stop()"
    },
    {
      "namespace": "mov",
      "declaration": "void Play(string path, bool disable_audio, chr::Handle handle, string texture)"
    },
    {
      "namespace": "mov",
      "declaration": "void Play(string path)"
    },
    {
      "namespace": "mov",
      "declaration": "void WaitPreload()"
    },
    {
      "namespace": "mov",
      "declaration": "bool IsReadyPreload(string path)"
    },
    {
      "namespace": "mov",
      "declaration": "void RequestPreload(string path)"
    },
    {
      "namespace": "save",
      "declaration": "void HidePhoto( )"
    },
    {
      "namespace": "save",
      "declaration": "void ShowPhoto( )"
    },
    {
      "namespace": "save",
      "declaration": "void SetPhotoBackGround(as::string bgname)"
    },
    {
      "namespace": "save",
      "declaration": "void CapturePhotoAndWait(int slot, mobj::Handle handle, const string& texname)"
    },
    {
      "namespace": "save",
      "declaration": "void CapturePhotoAndWait(int slot)"
    },
    {
      "namespace": "save",
      "declaration": "void ReplaceCapture(int slot, mobj::Handle handle, const string& texname)"
    },
    {
      "namespace": "save",
      "declaration": "void LoadCapture()"
    },
    {
      "namespace": "save",
      "declaration": "void SaveCapture(int slot)"
    },
    {
      "namespace": "save",
      "declaration": "void SaveByGameover()"
    },
    {
      "namespace": "save",
      "declaration": "void OverwriteSaveData(array<string>& gs_flags, array<string>& gf_flags)"
    },
    {
      "namespace": "save",
      "declaration": "bool PopReadFlag()"
    },
    {
      "namespace": "save",
      "declaration": "void PushReadFlag()"
    },
    {
      "namespace": "save",
      "declaration": "void Revert()"
    },
    {
      "namespace": "save",
      "declaration": "void Save(int timing)"
    },
    {
      "namespace": "save",
      "declaration": "void SaveOnly()"
    },
    {
      "namespace": "save",
      "declaration": "void ShootThumbnail()"
    },
    {
      "namespace": "save",
      "declaration": "bool IsFromEventSave()"
    },
    {
      "namespace": "save",
      "declaration": "bool IsFromAutoSave()"
    },
    {
      "namespace": "save",
      "declaration": "bool IsFromBlockSave()"
    },
    {
      "namespace": "hand",
      "declaration": "void SetDepth(float depth)"
    },
    {
      "namespace": "hand",
      "declaration": "int GetKeyType()"
    },
    {
      "namespace": "hand",
      "declaration": "void SetBalloonPos(float x, float y)"
    },
    {
      "namespace": "hand",
      "declaration": "void HideBalloon()"
    },
    {
      "namespace": "hand",
      "declaration": "void ShowBalloonNoInAnime(int balloon_text, int balloon_anime)"
    },
    {
      "namespace": "hand",
      "declaration": "void ShowBalloon(int balloon_text, int balloon_anime)"
    },
    {
      "namespace": "hand",
      "declaration": "void SetLookDir(int dir)"
    },
    {
      "namespace": "hand",
      "declaration": "void SetForceFailTarget(const string& id, bool onoff)"
    },
    {
      "namespace": "hand",
      "declaration": "void SetIntplCenterPos(const string& id, bool onoff)"
    },
    {
      "namespace": "hand",
      "declaration": "void Unbind()"
    },
    {
      "namespace": "hand",
      "declaration": "void Unhold()"
    },
    {
      "namespace": "hand",
      "declaration": "float GetLampProgressRatio()"
    },
    {
      "namespace": "hand",
      "declaration": "void SetLampProgressScale(float scale)"
    },
    {
      "namespace": "hand",
      "declaration": "void ClearMoveArea()"
    },
    {
      "namespace": "hand",
      "declaration": "void SetMoveArea(const math::Vec3& size, const math::Vec3& offset)"
    },
    {
      "namespace": "hand",
      "declaration": "void ClearVibrationArea()"
    },
    {
      "namespace": "hand",
      "declaration": "void SetVibrationArea(chr::Handle handle, const math::Vec3& scale, const math::Vec3& offset, const string& label)"
    },
    {
      "namespace": "hand",
      "declaration": "void SetVibrationArea(chr::Handle handle, const string& label)"
    },
    {
      "namespace": "hand",
      "declaration": "void SetVibrationArea(const string& label)"
    },
    {
      "namespace": "hand",
      "declaration": "void ShowLeft()"
    },
    {
      "namespace": "hand",
      "declaration": "void ShowRight()"
    },
    {
      "namespace": "hand",
      "declaration": "void EnableBalloon()"
    },
    {
      "namespace": "hand",
      "declaration": "void DisableBalloon()"
    },
    {
      "namespace": "hand",
      "declaration": "void Calib()"
    },
    {
      "namespace": "hand",
      "declaration": "void DisableControl()"
    },
    {
      "namespace": "hand",
      "declaration": "void EnableControl()"
    },
    {
      "namespace": "hand",
      "declaration": "void DisableTarget(const string& id)"
    },
    {
      "namespace": "hand",
      "declaration": "void EnableTarget(const string& id)"
    },
    {
      "namespace": "hand",
      "declaration": "float GetCatchRate()"
    },
    {
      "namespace": "hand",
      "declaration": "bool IsTouchUp()"
    },
    {
      "namespace": "hand",
      "declaration": "bool IsTouchRight()"
    },
    {
      "namespace": "hand",
      "declaration": "float GetValveRotate()"
    },
    {
      "namespace": "hand",
      "declaration": "bool IsStrikeSuccess()"
    },
    {
      "namespace": "hand",
      "declaration": "float GetStrikeSuccessThreshold()"
    },
    {
      "namespace": "hand",
      "declaration": "float GetStrikePow()"
    },
    {
      "namespace": "hand",
      "declaration": "math::Vec3 GetHandPos()"
    },
    {
      "namespace": "hand",
      "declaration": "void SetArmLimitLength(float length)"
    },
    {
      "namespace": "hand",
      "declaration": "bool IsControllable()"
    },
    {
      "namespace": "hand",
      "declaration": "bool IsVisible()"
    },
    {
      "namespace": "hand",
      "declaration": "void ContinueStateForStrike(bool disable_same_target=false)"
    },
    {
      "namespace": "hand",
      "declaration": "void ContinueState()"
    },
    {
      "namespace": "hand",
      "declaration": "void WaitEvent(const string& id)"
    },
    {
      "namespace": "hand",
      "declaration": "void Wait()"
    },
    {
      "namespace": "hand",
      "declaration": "bool IsBusy()"
    },
    {
      "namespace": "hand",
      "declaration": "void Disappear()"
    },
    {
      "namespace": "hand",
      "declaration": "void AppearStepEnd()"
    },
    {
      "namespace": "hand",
      "declaration": "void SetAppearStep(float step)"
    },
    {
      "namespace": "hand",
      "declaration": "void AppearStep()"
    },
    {
      "namespace": "hand",
      "declaration": "void AppearAnimeEnd()"
    },
    {
      "namespace": "hand",
      "declaration": "void AppearAnimeBegin()"
    },
    {
      "namespace": "hand",
      "declaration": "void Appear()"
    },
    {
      "namespace": "hand",
      "declaration": "void SetHandMode(int mode)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetVisibleAll(const string& name, bool visible)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetSkip(bool is_skip)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetSystemFlag(Handle handle, as_u32 sys_flag=0xfffffffe)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetColor1(Handle handle, float r, float g, float b, float a)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetColor0(Handle handle, float r, float g, float b, float a)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetParticleLifeScale(Handle handle, float ratio)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetEmissionIntervalScale(Handle handle, float ratio)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetEmissionRatioScale(Handle handle, float ratio)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetSoundSignal(Handle handle, bool enable)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetForwardFrame(Handle handle, int frame)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetDelayFrame(Handle handle, int frame)"
    },
    {
      "namespace": "eft",
      "declaration": "void WaitReadyCategory(int category)"
    },
    {
      "namespace": "eft",
      "declaration": "bool IsReadyCategory(int category)"
    },
    {
      "namespace": "eft",
      "declaration": "void UnloadCategory(int category)"
    },
    {
      "namespace": "eft",
      "declaration": "int LoadCategory(const string& name)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetForceCalculation(Handle handle, bool calc)"
    },
    {
      "namespace": "eft",
      "declaration": "void ClearBind(Handle handle, bool replace=true)"
    },
    {
      "namespace": "eft",
      "declaration": "void Fade(Handle handle)"
    },
    {
      "namespace": "eft",
      "declaration": "void KillSkip()"
    },
    {
      "namespace": "eft",
      "declaration": "void Kill(Handle handle)"
    },
    {
      "namespace": "eft",
      "declaration": "bool IsAnimeEnd(Handle handle, int idx=0)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetAnimeSpeed(Handle handle, float speed, int idx)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetAnimeFrame(Handle handle, float frame, int idx)"
    },
    {
      "namespace": "eft",
      "declaration": "void AppendAnime(Handle handle, const string& name, int idx=0)"
    },
    {
      "namespace": "eft",
      "declaration": "void AttachAnime(Handle handle, const string& name, int idx=0)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetScale(Handle handle, const math::Vec3& scl)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetRotation(Handle handle, const math::Vec3& rot)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetPos(Handle handle, const math::Vec3& pos)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetVisible(Handle handle, bool show)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetVisibleEmitter(Handle handle, const string& name, bool show)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetColor(Handle handle, const math::Vec3& color)"
    },
    {
      "namespace": "eft",
      "declaration": "void SetName(Handle handle, const string& name)"
    },
    {
      "namespace": "eft",
      "declaration": "Handle AutoEntry(const string& label, chr::Handle handle, const string& bone, float s, const math::Vec3& diff)"
    },
    {
      "namespace": "eft",
      "declaration": "Handle AutoEntry(const string& label, chr::Handle handle, const string& bone=\"\", float s=1.0f, float dx=0.0f, float dy=0.0f, float dz=0.0f)"
    },
    {
      "namespace": "eft",
      "declaration": "Handle EntryNoSound(const string& label, const math::Vec3& pos, float s=1.0f, const math::Vec3& rot = math::Vec3::Zero())"
    },
    {
      "namespace": "eft",
      "declaration": "Handle EntryNoSound(const string& label, float x, float y, float z, float s=1.0f, float rx=0.0f, float ry=0.0f, float rz=0.0f)"
    },
    {
      "namespace": "eft",
      "declaration": "Handle Entry(const string& label, const math::Vec3& pos, float s=1.0f, const math::Vec3& rot = math::Vec3::Zero())"
    },
    {
      "namespace": "eft",
      "declaration": "Handle Entry(const string& label, float x, float y, float z, float s=1.0f, float rx=0.0f, float ry=0.0f, float rz=0.0f)"
    },
    {
      "namespace": "eft",
      "declaration": "Handle GetHandle(const string& name)"
    },
    {
      "namespace": "hit",
      "declaration": "math::Vec3 GetSafetyZone(int i)"
    },
    {
      "namespace": "hit",
      "declaration": "int GetSafetyZoneNum()"
    },
    {
      "namespace": "hit",
      "declaration": "math::Vec3 GetSafetyZone()"
    },
    {
      "namespace": "hit",
      "declaration": "bool SearchSafetyZoneForBoots(const math::Vec3& base_pos, float length)"
    },
    {
      "namespace": "hit",
      "declaration": "int SearchSafetyZoneForBoots(const math::Vec3& base_pos, float length, const math::Vec3& dir_vec)"
    },
    {
      "namespace": "hit",
      "declaration": "bool SearchSafetyZone(const math::Vec3& base_pos, float length)"
    },
    {
      "namespace": "hit",
      "declaration": "bool CheckHitWaterSurface(chr::Handle handle)"
    },
    {
      "namespace": "hit",
      "declaration": "string GetHitMeshName(chr::Handle mesh_owner, int hitplace)"
    },
    {
      "namespace": "hit",
      "declaration": "string GetHitMeshName(const string& mesh_owner, int hitplace)"
    },
    {
      "namespace": "hit",
      "declaration": "bool IsHitCollision(chr::Handle mesh_owner, const string& mesh_name, int hitplace)"
    },
    {
      "namespace": "hit",
      "declaration": "bool IsHitCollision(const string& mesh_owner, const string& mesh_name, int hitplace)"
    },
    {
      "namespace": "hit",
      "declaration": "bool CheckLineSegment_TargetFlag(math::Vec3& out_normal, math::Vec3& out_hit_pos, const math::Vec3& start, const math::Vec3& end, as_u64 target_flag, as_u64 ignore_flag = 0)"
    },
    {
      "namespace": "hit",
      "declaration": "f32 CheckLineSegmentLen_NoThroughHole(const math::Vec3& start, const math::Vec3& end, as_u64 ignore_flag = 0)"
    },
    {
      "namespace": "hit",
      "declaration": "bool CheckLineSegment_NoThroughHole(string& name, string& mesh_name, math::Vec3& out_normal, math::Vec3& hit_pos, as_s32& material, const math::Vec3& start, const math::Vec3& end, as_u64 ignore_flag = 0)"
    },
    {
      "namespace": "hit",
      "declaration": "bool CheckLineSegment_NoThroughHole(math::Vec3& out_normal, math::Vec3& out_hit_pos, const math::Vec3& start, const math::Vec3& end, as_u64 ignore_flag = 0)"
    },
    {
      "namespace": "hit",
      "declaration": "f32 CheckLineSegmentLen(const math::Vec3& start, const math::Vec3& end, as_u64 ignore_flag)"
    },
    {
      "namespace": "hit",
      "declaration": "f32 CheckLineSegmentLen(const math::Vec3& start, const math::Vec3& end)"
    },
    {
      "namespace": "hit",
      "declaration": "bool CheckLineSegment(string& name, string& mesh_name, math::Vec3& out_normal, math::Vec3& hit_pos, as_s32& material, const math::Vec3& start, const math::Vec3& end, as_u64 ignore_flag = 0)"
    },
    {
      "namespace": "hit",
      "declaration": "bool CheckLineSegment(math::Vec3& out_normal, math::Vec3& out_hit_pos, const math::Vec3& start, const math::Vec3& end, as_u64 ignore_flag = 0)"
    },
    {
      "namespace": "hit",
      "declaration": "bool IsHitChrHandle(chr::Handle handle)"
    },
    {
      "namespace": "hit",
      "declaration": "bool IsHitChrHandle(int hitplace, chr::Handle handle)"
    },
    {
      "namespace": "hit",
      "declaration": "bool IsHitChr( string col_name, bool begin_match = false )"
    },
    {
      "namespace": "hit",
      "declaration": "bool IsHitChr( int hitplace, string col_name, bool begin_match = false )"
    },
    {
      "namespace": "hit",
      "declaration": "bool IsHitChr( int hitplace, string col_name,  int targetHitObjType, bool begin_match = false )"
    },
    {
      "namespace": "hit",
      "declaration": "u32 GetFootMaterial(chr::Handle handle)"
    },
    {
      "namespace": "hit",
      "declaration": "math::Vec3 GetHammerHitNormal()"
    },
    {
      "namespace": "hit",
      "declaration": "math::Vec3 GetHammerHitPos()"
    },
    {
      "namespace": "hit",
      "declaration": "string GetHammerHitNode()"
    },
    {
      "namespace": "hit",
      "declaration": "bool IsPlayerHeadHitAny()"
    },
    {
      "namespace": "hit",
      "declaration": "bool IsHammerSwingAny()"
    },
    {
      "namespace": "hit",
      "declaration": "bool IsHammerHitAny()"
    },
    {
      "namespace": "hit",
      "declaration": "bool IsHammerHitNode(string& mesh_name)"
    },
    {
      "namespace": "hit",
      "declaration": "u32 ConvertReactionFlg(int hit_place)"
    },
    {
      "namespace": "skip",
      "declaration": "void ClearPrevSkip()"
    },
    {
      "namespace": "skip",
      "declaration": "void SetPrevSkip()"
    },
    {
      "namespace": "skip",
      "declaration": "bool IsPrevSkip()"
    },
    {
      "namespace": "util::soliloquy",
      "declaration": "bool IsMasterPause()"
    },
    {
      "namespace": "util::soliloquy",
      "declaration": "bool IsPause()"
    },
    {
      "namespace": "util::soliloquy",
      "declaration": "void ResumePause()"
    },
    {
      "namespace": "util::soliloquy",
      "declaration": "void Pause()"
    },
    {
      "namespace": "util::soliloquy",
      "declaration": "void Init()"
    },
    {
      "namespace": "sobj",
      "declaration": "bool IsNearHide(sobj::Handle handle)"
    },
    {
      "namespace": "sobj",
      "declaration": "void ClearFollow(sobj::Handle handle)"
    },
    {
      "namespace": "sobj",
      "declaration": "void SetFollow(sobj::Handle handle, const ::string& my_lct, chr::Handle target, const ::string& target_lct, bool only_translate=false)"
    },
    {
      "namespace": "sobj",
      "declaration": "void SetFollow(sobj::Handle handle, chr::Handle target)"
    },
    {
      "namespace": "sobj",
      "declaration": "void SetFollow(sobj::Handle handle, chr::Handle target, const ::string& lct_name, bool only_translate=false)"
    },
    {
      "namespace": "sobj",
      "declaration": "void WaitIsReady(Handle handle)"
    },
    {
      "namespace": "sobj",
      "declaration": "Handle Entry(const string &name, const math::Vec3 &pos, const math::Vec3 &rot, const string &folder_name, const string &file_name, const bool enable_shadow)"
    },
    {
      "namespace": "lobj",
      "declaration": "Handle Entry(const string &name, const string &folder_name, const string &file_name)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "void GetRestKNPAll(as_s32& rest, as_s32& max)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "void GetRestKNPWorldFromMap(const string& map_id, as_s32& rest, as_s32& max)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "void GetRestKNPWorld(const string& world_id, as_s32& rest, as_s32& max)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "void GetRestKNPCourseFromMap(const string& map_id, as_s32& rest, as_s32& max)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "void GetRestKNPCourse(const string& world_id, const string& course_id, as_s32& rest, as_s32& max)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "void GetRestKNPMap(const string& map_id, as_s32& rest, as_s32& max)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "void GetRestFirstNpcID(const string& npc_id, as_s32& rest, as_s32& max, as_s32& headcount)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "s32 IsRescuedNpcID(const string& npc_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "void GetFirstNpcIDArray(array<string>& list)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "void InitRescuedTally()"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool IsModeDelete(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool IsModeEvent(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool IsModeNormal(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool IsPhase(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool CheckGoaway(chr::Handle handle)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool CheckGoaway(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool TryPhaseDelete(chr::Handle handle)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool TryPhaseDelete(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "as_s32 CheckSubIndex(chr::Handle handle)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "as_s32 CheckSubIndex(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool CheckPhase(chr::Handle handle, s32 phase)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool CheckPhase(const string& name_id, s32 phase)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool CheckPhaseFirst(chr::Handle handle)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool CheckPhaseFirst(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool SetPhase(chr::Handle handle, s32 phase)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool SetPhase(const string& name_id, s32 phase)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "as_s32 GetSelfBundleNum(chr::Handle handle)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "as_s32 GetSelfBundleNum(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "string FindKnpIDStr(chr::Handle handle, as_s32 phase, as_s32 subindex=0)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "string FindKnpIDStr(const string& name_id, as_s32 phase, as_s32 subindex=0)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "string GetAttribute_GoawayStr()"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "string GetAttributeStr(s32 attribute)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "string GetPhase_LastStr()"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "string GetPhase_FirstStr()"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "string GetPhaseStr(s32 phase)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool IsDisableSlow(chr::Handle handle)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool IsDisableSlow(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool IsDisableEffect(chr::Handle handle)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool IsDisableEffect(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool IsDisableVoice(chr::Handle handle)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool IsDisableVoice(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool IsDisableCoin(chr::Handle handle)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "bool IsDisableCoin(const string& name_id)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "string GetNpcID(chr::Handle handle)"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "string GetNpcID(const string& name_id)"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigParty()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsHandheld()"
    },
    {
      "namespace": "hid",
      "declaration": "void DisableSixAxisSensor()"
    },
    {
      "namespace": "hid",
      "declaration": "void EnableSixAxisSensor()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsEnableSixAxisSensor()"
    },
    {
      "namespace": "hid",
      "declaration": "math::Vec3 GetDirectionZ()"
    },
    {
      "namespace": "hid",
      "declaration": "math::Vec3 GetDirectionY()"
    },
    {
      "namespace": "hid",
      "declaration": "math::Vec3 GetDirectionX()"
    },
    {
      "namespace": "hid",
      "declaration": "math::Vec3 GetAngularVelocity()"
    },
    {
      "namespace": "hid",
      "declaration": "math::Vec3 GetAcceleration()"
    },
    {
      "namespace": "hid",
      "declaration": "math::Vec3 GetAngularVelocityR()"
    },
    {
      "namespace": "hid",
      "declaration": "math::Vec3 GetAccelerationR()"
    },
    {
      "namespace": "hid",
      "declaration": "math::Vec3 GetAngularVelocityL()"
    },
    {
      "namespace": "hid",
      "declaration": "math::Vec3 GetAccelerationL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseRsRight()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigRsRight()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatRsRight()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonRsRight()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseRsLeft()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigRsLeft()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatRsLeft()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonRsLeft()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseRsDown()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigRsDown()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatRsDown()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonRsDown()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseRsUp()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigRsUp()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatRsUp()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonRsUp()"
    },
    {
      "namespace": "hid",
      "declaration": "float getRStickY()"
    },
    {
      "namespace": "hid",
      "declaration": "float getRStickX()"
    },
    {
      "namespace": "hid",
      "declaration": "float getRStickDir()"
    },
    {
      "namespace": "hid",
      "declaration": "float getLStickY()"
    },
    {
      "namespace": "hid",
      "declaration": "float getLStickX()"
    },
    {
      "namespace": "hid",
      "declaration": "float getLStickDir()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseLsRight()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigLsRight()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatLsRight()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonLsRight()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseLsLeft()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigLsLeft()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatLsLeft()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonLsLeft()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseLsDown()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigLsDown()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatLsDown()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonLsDown()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseLsUp()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigLsUp()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatLsUp()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonLsUp()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseRight()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigRight()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatRight()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonRight()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseLeft()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigLeft()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatLeft()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonLeft()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseDown()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigDown()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatDown()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonDown()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseUp()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigUp()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatUp()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonUp()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseTouch()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigTouch()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatTouch()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonTouch()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseR()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigR()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatR()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonR()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseZR()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigZR()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatZR()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonZR()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseZL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigZL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatZL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonZL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseSelect()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigSelect()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatSelect()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonSelect()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseStart()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigStart()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatStart()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonStart()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleasePlus()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigPlus()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatPlus()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonPlus()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseMinus()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigMinus()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatMinus()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonMinus()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseStickR()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigStickR()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatStickR()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonStickR()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseStickL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigStickL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatStickL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonStickL()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseY()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigY()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatY()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonY()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseX()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigX()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatX()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonX()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseB()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigB()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatB()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonB()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsReleaseA()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsTrigA()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsRepeatA()"
    },
    {
      "namespace": "hid",
      "declaration": "bool IsButtonA()"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "const Vec4& UnitW()"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "const Vec4& UnitZ()"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "const Vec4& UnitY()"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "const Vec4& UnitX()"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "const Vec4& One()"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "const Vec4& Zero()"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "as_f32 Angle(const Vec4& a, const Vec4& b)"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "Vec4 Lerp(const Vec4& a, const Vec4& b, as_f32 t)"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "Vec4 Minimize(const Vec4& a, const Vec4& b)"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "Vec4 Maximize(const Vec4& a, const Vec4& b)"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "Vec4 Normalize(const Vec4& value)"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "as_f32 DistanceSquared(const Vec4& a, const Vec4& b)"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "as_f32 Distance(const Vec4& a, const Vec4& b)"
    },
    {
      "namespace": "math::Vec4",
      "declaration": "as_f32 Dot(const Vec4& a, const Vec4& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "const Vec3& UnitZ()"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "const Vec3& UnitY()"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "const Vec3& UnitX()"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "const Vec3& One()"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "const Vec3& Zero()"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 YZ_Angle(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 YZ_TransformCoord(const Vec3& value, const Mtx44& transform)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 YZ_TransformNormal(const Vec3& value, const Mtx43& transform)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 YZ_Transform(const Vec3& value, const Mtx43& transform)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 YZ_Lerp(const Vec3& a, const Vec3& b, as_f32 t)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 YZ_Minimize(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 YZ_Maximize(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 YZ_Cross(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 YZ_Normalize(const Vec3& value)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 YZ_DistanceSquared(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 YZ_Distance(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 YZ_Dot(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 YZ(as_f32 y, as_f32 z)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 XY_Angle(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XY_TransformCoord(const Vec3& value, const Mtx44& transform)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XY_TransformNormal(const Vec3& value, const Mtx43& transform)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XY_Transform(const Vec3& value, const Mtx43& transform)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XY_Lerp(const Vec3& a, const Vec3& b, as_f32 t)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XY_Minimize(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XY_Maximize(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XY_Cross(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XY_Normalize(const Vec3& value)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 XY_DistanceSquared(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 XY_Distance(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 XY_Dot(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XY(as_f32 x, as_f32 y)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 XZ_Angle(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XZ_TransformCoord(const Vec3& value, const Mtx44& transform)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XZ_TransformNormal(const Vec3& value, const Mtx43& transform)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XZ_Transform(const Vec3& value, const Mtx43& transform)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XZ_Lerp(const Vec3& a, const Vec3& b, as_f32 t)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XZ_Minimize(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XZ_Maximize(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XZ_Cross(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XZ_Normalize(const Vec3& value)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 XZ_DistanceSquared(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 XZ_Distance(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 XZ_Dot(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 XZ(as_f32 x, as_f32 z)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 Angle(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 TransformCoord(const Vec3& value, const Mtx44& transform)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 TransformNormal(const Vec3& value, const Mtx43& transform)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 Transform(const Vec3& value, const Mtx43& transform)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 Rotate(const Vec3& value, const Vec3 &rotation)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 Rotate(const Vec3& value, const Quat &rotation)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 Lerp(const Vec3& a, const Vec3& b, as_f32 t)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 Minimize(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 Maximize(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 Cross(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "Vec3 Normalize(const Vec3& value)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 DistanceSquared(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 Distance(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec3",
      "declaration": "as_f32 Dot(const Vec3& a, const Vec3& b)"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "const Vec2& UnitY()"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "const Vec2& UnitX()"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "const Vec2& One()"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "const Vec2& Zero()"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "as_f32 Angle(const Vec2& a, const Vec2& b)"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "Vec2 Rotate(const Vec2& value, const as_f32 rotation)"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "Vec2 Lerp(const Vec2& a, const Vec2& b, as_f32 t)"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "Vec2 Minimize(const Vec2& a, const Vec2& b)"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "Vec2 Maximize(const Vec2& a, const Vec2& b)"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "Vec2 Normalize(const Vec2& value)"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "as_f32 DistanceSquared(const Vec2& a, const Vec2& b)"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "as_f32 Distance(const Vec2& a, const Vec2& b)"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "as_f32 Cross(const Vec2& a, const Vec2& b)"
    },
    {
      "namespace": "math::Vec2",
      "declaration": "as_f32 Dot(const Vec2& a, const Vec2& b)"
    },
    {
      "namespace": "sys",
      "declaration": "void SetUserInactivityDetectionTimeExtended(bool isExtended)"
    },
    {
      "namespace": "sys",
      "declaration": "void ReturnTitle()"
    },
    {
      "namespace": "sys",
      "declaration": "string GetLanguageIETF()"
    },
    {
      "namespace": "sys",
      "declaration": "void SetAllPrefetchSetup(bool is_all)"
    },
    {
      "namespace": "sys",
      "declaration": "void SetDelayPrefetchSetup(bool is_delay)"
    },
    {
      "namespace": "sys",
      "declaration": "bool IsReadyPrefetch()"
    },
    {
      "namespace": "sys",
      "declaration": "void Prefetch(string mapId)"
    },
    {
      "namespace": "sys",
      "declaration": "void SetFieldTimeStepScale(f32 scale)"
    },
    {
      "namespace": "sys",
      "declaration": "int GetFrameCount()"
    },
    {
      "namespace": "sys",
      "declaration": "void SetSystemFlag(as_u32 flag, bool is_on)"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncTakePhotoCount()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncEnterW1C2BasementFirst()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncAccessMuseumSound()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncAccessMuseumEnemy()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncAccessMuseumCollectable()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncAccessMuseumKinopio()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncAccessMuseumArt()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncTalkShopW5G1()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncTalkShopW3G3()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncTalkShopW3C1()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncTalkShopW2G2()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncTalkShopW1G2()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncTalkShopW1G1()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void AddTotalBuyAccessoryCoin(int val)"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void AddTotalBuyItemCoin(int val)"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncUse1upKinokoCount()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncOpenOfflineHtml()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncGameOverCount()"
    },
    {
      "namespace": "pouch::record",
      "declaration": "void IncOliviaHintCount()"
    },
    {
      "namespace": "pouch",
      "declaration": "void ClearRoadParameter()"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetRoadParameter()"
    },
    {
      "namespace": "pouch",
      "declaration": "void ResetBag()"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetShopCumulativeCoin(int coin)"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetShopCumulativeCoin(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "void Pop()"
    },
    {
      "namespace": "pouch",
      "declaration": "void Push()"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetUseKinopioPoint(int point)"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetUseKinopioPoint(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "bool IsEquipmentAmulet(string item_id)"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetEquipBellNo()"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetupEquipmentIgnoreParty(string id)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetupEquipment(string id)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetPuzzleLevel(as_s32 lv)"
    },
    {
      "namespace": "pouch",
      "declaration": "bool UnsetBoundingShapePosition(string mapName, string BBName)"
    },
    {
      "namespace": "pouch",
      "declaration": "bool SetBoundingShapePosition(string mapName, string BBName, const math::Vec3& pos)"
    },
    {
      "namespace": "pouch",
      "declaration": "void ClearRetryPoint()"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetRetryPoint(const math::Vec3& pos, int param=0)"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetRetryReturnParam()"
    },
    {
      "namespace": "pouch",
      "declaration": "bool IsRetryReturn()"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetFootstepCount(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetFootstepCount(int step_count)"
    },
    {
      "namespace": "pouch",
      "declaration": "void IncFootstepCount(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "f32 GetPeachShipPoint(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetPeachShipPoint(f32 point_frame)"
    },
    {
      "namespace": "pouch",
      "declaration": "string GetSalvageItemSetId(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetSalvageItemSetId(string salvage_itemsetid)"
    },
    {
      "namespace": "pouch",
      "declaration": "string GetSalvageId(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetSalvageId(string salvage_id)"
    },
    {
      "namespace": "pouch",
      "declaration": "f32 GetShipDir(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetShipDir(f32 dir)"
    },
    {
      "namespace": "pouch",
      "declaration": "math::Vec3 GetShipTargetPos(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetShipTargetPos(const math::Vec3& pos)"
    },
    {
      "namespace": "pouch",
      "declaration": "math::Vec3 GetShipPos(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetShipPos(const math::Vec3& pos)"
    },
    {
      "namespace": "pouch",
      "declaration": "bool IsInVehicle()"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetVehiclePosMap(string mapname, const math::Vec3& pos)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetVehiclePosMap(string mapname, const math::Vec3& pos, float dir)"
    },
    {
      "namespace": "pouch",
      "declaration": "float GetVehicleDir(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "math::Vec3 GetVehiclePos(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "string GetVehicleMapName(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "bool IsEnableNavi()"
    },
    {
      "namespace": "pouch",
      "declaration": "void DisableNavi()"
    },
    {
      "namespace": "pouch",
      "declaration": "void EnableNavi()"
    },
    {
      "namespace": "pouch",
      "declaration": "void EquipHammer()"
    },
    {
      "namespace": "pouch",
      "declaration": "void ReleaseHammer()"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetTotalCoin(int coin)"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetTotalCoin(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetCoinAdjustRate(int coin)"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetCoinAdjustRate(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "void AddCoin(int coin)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetCoin(int coin)"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetCoin(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "bool IsFullKP()"
    },
    {
      "namespace": "pouch",
      "declaration": "bool IsEmptyKP()"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetKP(int kp)"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetKP()"
    },
    {
      "namespace": "pouch",
      "declaration": "void AddKP(int kp)"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetMaxKP(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetHP(int hp)"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetHP(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetMaxHP(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "int GetLevel(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "string GetBeroName(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "void SetBeroName(string name)"
    },
    {
      "namespace": "pouch",
      "declaration": "string GetMapName(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "string GetCourseName(void)"
    },
    {
      "namespace": "pouch",
      "declaration": "string GetWorldName(void)"
    },
    {
      "namespace": "hariko",
      "declaration": "void DisableDashAttackCameraShake(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "math::Vec3 GetFirstHammerHitSize(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "math::Vec3 GetFirstHitSize(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void EnableHitShapeHarikoOnHariko( Handle handle )"
    },
    {
      "namespace": "hariko",
      "declaration": "void DisableHitShapeHarikoOnHariko( Handle handle )"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetHammerHitOffsetPos(Handle handle, math::Vec3 v)"
    },
    {
      "namespace": "hariko",
      "declaration": "math::Vec3 GetHammerHitOffsetPos(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetHammerHitSize(Handle handle, math::Vec3 v)"
    },
    {
      "namespace": "hariko",
      "declaration": "math::Vec3 GetHammerHitSize(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SeparateHammerHit(Handle handle, bool enable=true)"
    },
    {
      "namespace": "hariko",
      "declaration": "void BeginAnimeConfetti(Handle handle, int preset, string anim1=\"\", string anim2=\"\", string anim3=\"\", string anim4=\"\", string anim5=\"\", string anim6=\"\")"
    },
    {
      "namespace": "hariko",
      "declaration": "void BeginConfetti(Handle handle, const math::Vec3& pos)"
    },
    {
      "namespace": "hariko",
      "declaration": "void StartWeakBreakSmoke(Handle handle, string label = \"\")"
    },
    {
      "namespace": "hariko",
      "declaration": "void StartWhiteFlag_NoSmoke(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void StartWhiteFlag(Handle handle, string label = \"\")"
    },
    {
      "namespace": "hariko",
      "declaration": "void WhiteFlag_SetCastSunShadowEnable(Handle handle, bool enable)"
    },
    {
      "namespace": "hariko",
      "declaration": "void Knockback(Handle handle, const math::Vec3& pos)"
    },
    {
      "namespace": "hariko",
      "declaration": "math::Vec3 GetAttackPos(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetAttackPos(Handle handle, const math::Vec3& pos)"
    },
    {
      "namespace": "hariko",
      "declaration": "void ChaseDeccel(Handle handle, f32 dec = 0.0f)"
    },
    {
      "namespace": "hariko",
      "declaration": "void ChaseAccel(Handle handle, math::Vec3 pos, f32 acc = 0.0f)"
    },
    {
      "namespace": "hariko",
      "declaration": "void Dash(Handle handle, math::Vec3 pos)"
    },
    {
      "namespace": "hariko",
      "declaration": "math::Vec3 GetProwlPos(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetProwlType(Handle handle, int prowl_type)"
    },
    {
      "namespace": "hariko",
      "declaration": "f32 GetProwlInterval(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "int GetNearProwlOrder(Handle handle, const math::Vec3& pos)"
    },
    {
      "namespace": "hariko",
      "declaration": "int GetProwlOrder(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetProwlOrder(Handle handle, int index)"
    },
    {
      "namespace": "hariko",
      "declaration": "int GetProwlPointCount(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void InitProwlPoint(Handle handle, array<math::Vec3>& point_array)"
    },
    {
      "namespace": "hariko",
      "declaration": "bool IsNoProwl(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "bool IsViewLine(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "bool IsOutsideTrace(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "bool IsFoundPlayer(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "bool IsLookPlayer(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "bool IsBrokenWeak(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "int GetMaxHP(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "int GetHP(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetHP(Handle handle, int hp)"
    },
    {
      "namespace": "hariko",
      "declaration": "int GetWeakNum(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetWeakDelay(Handle handle, f32 msec)"
    },
    {
      "namespace": "hariko",
      "declaration": "string GetHitWeak(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void DestroyWeak(Handle handle, string node_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void HideWeak(Handle handle, string node_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void ShowWeak(Handle handle, string node_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void ResetWeak(Handle handle, string node_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void ForceReturn(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void ForceFind(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void DisableFocusCamera(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void EnableFocusCamera(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void DisableFloating(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void EnableFloating(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void DisableDamage(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void EnableDamage(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void EnableVehicleHornFind(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void DisableVehicleHornFind(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void DisableFind(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void EnableFind(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "bool CheckPlayerHit(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void DisableAttack(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void EnableAttack(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void StartBlink(Handle handle, f32 msec)"
    },
    {
      "namespace": "hariko",
      "declaration": "void EndEvent(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void BeginEvent(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void ResetSwitch(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetFloorOffset(Handle handle, f32 floor_offset)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetCheckToHitMapSide(Handle handle, bool enable)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetCheckToHitMap(Handle handle, bool enable)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchLost(Handle handle, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchLost(Handle handle, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchContact(Handle handle, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchContact(Handle handle, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchAttack(Handle handle, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchAttack(Handle handle, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchFind(Handle handle, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchFind(Handle handle, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchWeakDamage(Handle handle, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchWeakDamage(Handle handle, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchDamage(Handle handle, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchDamage(Handle handle, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchReturn(Handle handle, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchReturn(Handle handle, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchMain(Handle handle, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchMain(Handle handle, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchMainOld(Handle handle, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchExit(Handle handle, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SwitchExit(Handle handle, const string& func_name)"
    },
    {
      "namespace": "hariko",
      "declaration": "void RunMain(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void ResetTraceParam(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void ResetProwlParam(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void ResetViewParam(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetTraceParam(Handle handle, math::Vec3 center, math::Vec3 size, f32 rot = 0.0f)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetProwlParam(Handle handle, math::Vec3 center, math::Vec3 size, f32 rot = 0.0f)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetViewParam(Handle handle, f32 angle, f32 dist)"
    },
    {
      "namespace": "hariko",
      "declaration": "void GetTraceParam(Handle handle, math::Vec3& center, math::Vec3& size, f32& rot)"
    },
    {
      "namespace": "hariko",
      "declaration": "void GetProwlParam(Handle handle, math::Vec3& center, math::Vec3& size, f32& rot)"
    },
    {
      "namespace": "hariko",
      "declaration": "void GetViewParam(Handle handle, f32& angle, f32& dist)"
    },
    {
      "namespace": "hariko",
      "declaration": "int GetDamageResult(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void SetDefeat(const string& map_id, const string& dispos_id)"
    },
    {
      "namespace": "hariko",
      "declaration": "bool IsDefeated(const string& dispos_id)"
    },
    {
      "namespace": "hariko",
      "declaration": "bool IsDefeated(const string& map_id, const string& dispos_id)"
    },
    {
      "namespace": "hariko",
      "declaration": "bool IsDefeated(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "int GetPrevState(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "int GetState(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void ChangeState(Handle handle, int state)"
    },
    {
      "namespace": "hariko",
      "declaration": "void LockState(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "void UnlockState(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "bool IsLockedState(Handle handle)"
    },
    {
      "namespace": "hariko",
      "declaration": "Handle Entry(string& dispos_id)"
    },
    {
      "namespace": "Switch",
      "declaration": "void ClearGroup(const string& group_name)"
    },
    {
      "namespace": "navigator",
      "declaration": "void DisableAction(bool disable, int disable_action_type = navigator::DisableActionType_Default )"
    },
    {
      "namespace": "navigator",
      "declaration": "void SetHomePos(math::Vec3 home_pos)"
    },
    {
      "namespace": "navigator",
      "declaration": "math::Vec3 GetHomePos()"
    },
    {
      "namespace": "navigator",
      "declaration": "void Wait()"
    },
    {
      "namespace": "navigator",
      "declaration": "bool IsBusy()"
    },
    {
      "namespace": "navigator",
      "declaration": "chr::Handle GetEventFollowTarget()"
    },
    {
      "namespace": "navigator",
      "declaration": "void EndFollow()"
    },
    {
      "namespace": "navigator",
      "declaration": "void BeginFollow (chr::Handle handle = chr::Handle())"
    },
    {
      "namespace": "navigator",
      "declaration": "void ResetTalkSetUp()"
    },
    {
      "namespace": "navigator",
      "declaration": "void SetAffect(int affect_type, int msec=-1, bool transform=false, s32 for_battle=0)"
    },
    {
      "namespace": "navigator",
      "declaration": "void Look(int look_dir)"
    },
    {
      "namespace": "navigator",
      "declaration": "void Jump(int jump_count)"
    },
    {
      "namespace": "navigator",
      "declaration": "math::Vec3 CalcHomePos(int pos_type, int entry_dir)"
    },
    {
      "namespace": "navigator",
      "declaration": "void ReturnHomeMsec(int msec)"
    },
    {
      "namespace": "navigator",
      "declaration": "void ReturnHome(s32 move_speed=navigator::MoveSpeed_Normal)"
    },
    {
      "namespace": "navigator",
      "declaration": "void MoveMsec(const math::Vec3& pos, int msec, int interpolate_type=math::MOVE_TYPE_DECEL)"
    },
    {
      "namespace": "navigator",
      "declaration": "void Move(const math::Vec3& pos, s32 move_speed=navigator::MoveSpeed_Normal)"
    },
    {
      "namespace": "navigator",
      "declaration": "void ExitDirect()"
    },
    {
      "namespace": "navigator",
      "declaration": "void Exit(math::Vec3 paint_pos)"
    },
    {
      "namespace": "navigator",
      "declaration": "void Exit()"
    },
    {
      "namespace": "navigator",
      "declaration": "void SetKeepRelative(bool keep_relative)"
    },
    {
      "namespace": "navigator",
      "declaration": "bool HasSpaceToEntry(math::Vec3 entry_pos)"
    },
    {
      "namespace": "navigator",
      "declaration": "bool IsEnableEntry()"
    },
    {
      "namespace": "navigator",
      "declaration": "void EntryAuto(f32 length = 0.0f, bool back = false)"
    },
    {
      "namespace": "navigator",
      "declaration": "msg::MessageHandle GetHintMessageHandle()"
    },
    {
      "namespace": "navigator",
      "declaration": "void SetCallHint(string func_name)"
    },
    {
      "namespace": "navigator",
      "declaration": "void CallHintValue(msg::MessageHandle handle)"
    },
    {
      "namespace": "navigator",
      "declaration": "void EntryHint()"
    },
    {
      "namespace": "navigator",
      "declaration": "void EntryDirect(math::Vec3 pos, f32 dir)"
    },
    {
      "namespace": "navigator",
      "declaration": "void Entry(int pos_type, int entry_dir, int look_dir, int entry_type=navigator::EntryType_Default)"
    },
    {
      "namespace": "navigator",
      "declaration": "void Entry(math::Vec3 paint_pos, math::Vec3 home_pos, f32 dir)"
    },
    {
      "namespace": "navigator",
      "declaration": "void Entry(f32 entry_dir, f32 look_dir, bool quick = false)"
    },
    {
      "namespace": "navigator",
      "declaration": "void DisableHint()"
    },
    {
      "namespace": "navigator",
      "declaration": "void EnableHint()"
    },
    {
      "namespace": "snd::effect",
      "declaration": "void Setup(const string& id)"
    },
    {
      "namespace": "snd::effect",
      "declaration": "void ChangeFxEQ(const string& id)"
    },
    {
      "namespace": "snd::effect",
      "declaration": "void Change(const string& id)"
    },
    {
      "namespace": "snd::effect",
      "declaration": "as_s32 GetFxSpeakerRMS(as_s32 band, as_s32 ch)"
    },
    {
      "namespace": "snd::effect",
      "declaration": "void SetReturnGain(float gain)"
    },
    {
      "namespace": "btl::amulet",
      "declaration": "void SetupLastPicture()"
    },
    {
      "namespace": "btl::amulet",
      "declaration": "void SetupLastTonTonSmo()"
    },
    {
      "namespace": "btl::amulet",
      "declaration": "void Used1upKinoko()"
    },
    {
      "namespace": "btl::amulet",
      "declaration": "bool Is1upKinoko()"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void FlyPosMsec(const MobjHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void FlyPos(const MobjHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void _FlyPos(const MobjHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void JumpOnlyPosMsec(const MobjHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void JumpPosMsec(const MobjHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void JumpPos(const MobjHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void _JumpPos(const MobjHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, bool jumpOnly)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void MovePosMsec(const MobjHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void MovePos(const MobjHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void _MovePos(const MobjHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, as_f32 tdist, bool sound, as_s32 type)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void Rotate(const MobjHandle& handle, as_f32 x, as_f32 y, as_f32 z, as_f32 msec)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void ResetFallAcc(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "as_f32 GetFallAcc(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetFallAcc(const MobjHandle& handle, as_f32 acc)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "bool IsOpenSystem()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void WaitSystem()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void CloseSystem()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void OpenSystem(const string& msg)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "bool IsOpenAttackName()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void CloseAttackName()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void OpenAttackName(const string& msg)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "bool IsOpenFormation()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void CloseFormation()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void OpenFormationBottom(const string& msg)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void OpenFormation(const string& msg)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "bool IsOpenGodHandHelp()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void CloseGodHandHelp()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void OpenGodHandHelp(const string& msg)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 GetFixBalloonNum()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "bool IsOpenFixBalloon(as_s32 no)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void CloseFixBalloon(as_s32 no)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void WaitFixBalloon(as_s32 no)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 OpenFixBalloon(const string& msg, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 OpenFixBalloon(const string& msg, float x, float y, float z)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "bool IsSameOpenHeihoBalloon(const string& msg)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 GetHeihoBalloonNum(bool term)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "bool IsOpenHeihoBalloon(as_s32 no)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void CloseHeihoBalloonAll()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void CloseHeihoBalloon(as_s32 no)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void WaitHeihoBalloon(as_s32 no)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 OpenHeihoBalloon(const string& msg, const math::Vec3& pos, bool term)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 OpenHeihoBalloon(const string& msg, const npc::Handle& handle, const string& loc_name, bool term)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void EnableAudienceBalloon()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void DisableAudienceBalloon()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "bool IsOpenAudienceBalloon(as_s32 no)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void CloseAudienceBalloonAll()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void CloseAudienceBalloon(as_s32 no)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 GetAudienceHintBalloonNum()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 GetAudienceBalloonNum()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 OpenAudienceBalloon(const string& msg, const UnitHandle& handle, const math::Vec3 offset = math::Vec3::Zero())"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 GetBalloonNum()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "bool IsOpenBalloon(as_s32 no)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void CloseBalloonAll()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void CloseBalloon(as_s32 no)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void WaitBalloon(as_s32 no)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 OpenBalloon(const string& msg, const PartsHandle& handle, bool no_anime=false, bool no_toge=true)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 OpenBalloonFace(const string& msg, const math::Vec3& pos, bool right, const string& state)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 OpenBalloonFace(const string& msg, const math::Vec3& pos, bool right=true)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 OpenBalloon(const string& msg, const UnitHandle& handle, bool check_area=true, bool no_anime=false, bool no_toge=true)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "as_s32 GetSelectNo()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "bool IsOpen()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void Wait()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void Close()"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void SetTogeFix(as_s32 index)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void SetTogeDir(as_s32 index)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void SetPos(as_s32 index)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void OpenNoTogeValue(const string& msg, const string& value, const UnitHandle& handle, bool no_anime=false, float blend=0.0f, bool loop_anime=false)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void OpenValue(const string& msg, const string& value, const UnitHandle& handle, bool no_anime=false, float blend=0.0f, bool loop_anime=false)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void OpenValue(const string& msg, const string& value, const string& sound)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void OpenValue(const string& msg, const string& value)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void OpenNoToge(const string& msg, const UnitHandle& handle, bool no_anime=false, float blend=0.0f, bool loop_anime=false)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void Open(const string& msg, const UnitHandle& handle, bool no_anime=false, float blend=0.0f, bool loop_anime=false)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void Open(const string& msg, const string& sound)"
    },
    {
      "namespace": "btl::ui::talk",
      "declaration": "void Open(const string& msg)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void ChangeLightAnime(MobjHandle& handle, const string& anime, int index=0)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetSpeedAnime(MobjHandle& handle, float spd, int ch=0)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void ChangeAnime(MobjHandle& handle, const string& anime, int ch=0)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void DisableSoundSignal(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void EnableSoundSignal(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void ReplaceTexture(const MobjHandle& handle, const string& name, const string& color)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void ReplaceMainAlbedoColor(const MobjHandle& handle, const string& color)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void UpdateBoneEnableLocator(const MobjHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "math::Vec3 GetLocatorPos(const MobjHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetLocatorPos(const MobjHandle& handle, const string& name, float x, float y, float z)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetLocatorPos(const MobjHandle& handle, const string& name, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "math::Vec3 GetLocatorRot(const MobjHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetLocatorRot(const MobjHandle& handle, const string& name, float x, float y, float z)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetLocatorRot(const MobjHandle& handle, const string& name, const math::Vec3& scale)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "math::Vec3 GetLocatorScale(const MobjHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetLocatorScale(const MobjHandle& handle, const string& name, float x, float y, float z)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetLocatorScale(const MobjHandle& handle, const string& name, const math::Vec3& scale)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "math::Vec3 GetLocatorLocalPos(const MobjHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "math::Vec3 GetLocatorWorldPos(const MobjHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "bool IsShowLocator(const MobjHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void HideLocator(const MobjHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void ShowLocator(const MobjHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void CreateLocator(const MobjHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetFollowPos(const MobjHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetFollowPos(const MobjHandle& handle, const math::Vec3& rot)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetFollowRot(const MobjHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetFollowRot(const MobjHandle& handle, const math::Vec3& rot)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void ClearFollow(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetFollow(const MobjHandle& handle, const MobjHandle& target, const string& name, bool pos_only=false)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "string GetMobjID(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetMaterialParam(const MobjHandle& handle, const string& name, as_f32 v)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetMaterialParam(const MobjHandle& handle, const string& name, const math::Vec3& v)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetShow(const MobjHandle& handle, bool show)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "bool IsShow(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void Hide(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void Show(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "as_f32 GetHomeDir(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetHomeDir(const MobjHandle& handle, as_f32 dir)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "as_f32 GetDir(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetDirectDir(const MobjHandle& handle, as_f32 dir)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetDir(const MobjHandle& handle, as_f32 dir)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "math::Vec3 GetPos(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void SetPos(const MobjHandle& handle, math::Vec3& pos)"
    },
    {
      "namespace": "btl::mobj",
      "declaration": "void Destroy(const MobjHandle& handle)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void FlyPosMsec(const ItemHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void FlyPos(const ItemHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void _FlyPos(const ItemHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void JumpOnlyPosMsec(const ItemHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void JumpPosMsec(const ItemHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void JumpPos(const ItemHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void _JumpPos(const ItemHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, bool jumpOnly)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void MovePosMsec(const ItemHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void MovePos(const ItemHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void _MovePos(const ItemHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, as_f32 tdist, bool sound, as_s32 type)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void Rotate(const ItemHandle& handle, as_f32 x, as_f32 y, as_f32 z, as_f32 msec)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void ResetFallAcc(const ItemHandle& handle)"
    },
    {
      "namespace": "btl::item",
      "declaration": "as_f32 GetFallAcc(const ItemHandle& handle)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void SetFallAcc(const ItemHandle& handle, as_f32 acc)"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "bool IsEndTimer()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "int GetTime()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void HideTimer()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void StopTimer()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void StartTimer()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void UnsetTimer()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void SetupTimer(float sec)"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void SetContinueState(bool set)"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "bool IsUnset()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "bool IsFinish()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "bool IsBusy()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "bool IsReady()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void Open()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void EnableTarget(const string& id)"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void SetupTarget(const string& id, const UnitHandle& handle)"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void WaitReady()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void ForceUnset()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void Unset()"
    },
    {
      "namespace": "btl::ui::hand",
      "declaration": "void Setup()"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SoundDisable(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SoundEnable(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void EffectDisableSignal(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void EffectEnableSignal(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SoundDisableSignal(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SoundEnableSignal(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SoundDamageToge(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SoundSetDamageFlag(const PartsHandle& handle, const string& flag=\"\")"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SoundDamage(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SoundAttack(const PartsHandle& handle, as_f32 vol=1.0f, const string& flag=\"\")"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SoundLanding(const PartsHandle& handle, as_f32 vol=1.0f, const string& flag=\"\")"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SoundJump(const PartsHandle& handle, as_f32 vol=1.0f, const string& flag=\"\")"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "snd::VoiceHandle SoundFollowSE(const PartsHandle& handle, const string& flag)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "snd::VoiceHandle SoundSE(const PartsHandle& handle, const string& flag)"
    },
    {
      "namespace": "hand::script",
      "declaration": "bool IsEnableOneHandBlendMode()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void DisableOneHandBlendMode()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void EnableOneHandBlendMode()"
    },
    {
      "namespace": "hand::script",
      "declaration": "bool IsEnableOnlyRightOneHandCtrl()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void DisableOnlyRightOneHandCtrl()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void EnableOnlyRightOneHandCtrl()"
    },
    {
      "namespace": "hand::script",
      "declaration": "bool IsEnableOneHandCtrl()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void EnableOneHandCtrl()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void DisableOneHandCtrl()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void EnableCalibration()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void DisableCalibration()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetHandOpenAnime(const string& anime)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void StartInterp(as_f32 frame)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetCompletionRate(as_f32 rate)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetOffsetArmRightOnly(bool only)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetOffsetArmType(as_s32 type)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetOffsetArmLength(as_f32 offset, as_f32 rate=0.0f, as_f32 frame=0.0f, as_f32 end_frame=0.0f, as_f32 slide=0.0f, bool near=false)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void DisableCtrlArm()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void EnableCtrlArm()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetVibrationPow(as_f32 pow)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetHandSearchTarget(btl::PartsHandle l_parts, const string& l_name, btl::PartsHandle r_parts, const string& r_name)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ChangeHandJunkenPaa()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ChangeHandJunkenChoki()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ChangeHandJunkenGuu()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ResetControllerQuarernion()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ClearRightHandTarget()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ClearLeftHandTarget()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetRightHandTarget(btl::PartsHandle parts, string name)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetLeftHandTarget(btl::PartsHandle parts, string name)"
    },
    {
      "namespace": "hand::script",
      "declaration": "float GetControllerDir()"
    },
    {
      "namespace": "hand::script",
      "declaration": "float GetHandDir()"
    },
    {
      "namespace": "hand::script",
      "declaration": "math::Vec3 GetHandPos()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetHandWidth(float dist)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetHandDist(float dist)"
    },
    {
      "namespace": "hand::script",
      "declaration": "math::Vec3 GetSplineOffset()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ResetSplineOffset()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetSplineOffset(const math::Vec3& offset)"
    },
    {
      "namespace": "hand::script",
      "declaration": "bool IsBalloon()"
    },
    {
      "namespace": "hand::script",
      "declaration": "bool IsBalloonHide()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetBalloonPos(const math::Vec3& pos)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void HideBalloon()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ShowBalloon(as_s32 text, as_s32 anime, bool hide=true)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ResetMaxVelocity()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ResetMaxAccel()"
    },
    {
      "namespace": "hand::script",
      "declaration": "float GetMaxVelocity()"
    },
    {
      "namespace": "hand::script",
      "declaration": "float GetMaxAccel()"
    },
    {
      "namespace": "hand::script",
      "declaration": "float GetStrikeOffsetDir()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetStrikeManualDir(bool v)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetStrikeOffsetDir(as_f32 dir)"
    },
    {
      "namespace": "hand::script",
      "declaration": "as_f32 GetStrikeDirMax()"
    },
    {
      "namespace": "hand::script",
      "declaration": "as_f32 GetStrikeDirMin()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetStrikeDir(as_f32 dir)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetStrikeDir(as_f32 min, as_f32 max, as_f32 dir)"
    },
    {
      "namespace": "hand::script",
      "declaration": "math::Vec2 GetCalc()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ResetAngularVelocityHistory()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void GetAngularVelocityHistory(array<math::Vec3>& list)"
    },
    {
      "namespace": "hand::script",
      "declaration": "math::Vec3 GetAngularVelocity()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ResetAccelerationHistory()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void GetAccelerationHistory(array<math::Vec3>& list)"
    },
    {
      "namespace": "hand::script",
      "declaration": "math::Vec3 GetAcceleration()"
    },
    {
      "namespace": "hand::script",
      "declaration": "bool IsBindCatch()"
    },
    {
      "namespace": "hand::script",
      "declaration": "bool IsHit()"
    },
    {
      "namespace": "hand::script",
      "declaration": "bool IsCatch()"
    },
    {
      "namespace": "hand::script",
      "declaration": "bool IsTouch()"
    },
    {
      "namespace": "hand::script",
      "declaration": "bool IsOpen()"
    },
    {
      "namespace": "hand::script",
      "declaration": "bool IsOpening()"
    },
    {
      "namespace": "hand::script",
      "declaration": "bool IsHoldButton()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetSensitivityRaw(float x, float y)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetSensitivity(float x, float y)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetForceHold()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetDirectWristDir(float dir)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetWristDir(float dir)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetDirectBind(bool v)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetRebindTarget()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void SetBindTarget(bool v)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ChangeModeJunken()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ChangeModePull()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ChangeModeLiftStrike()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ChangeModeStrike()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ChangeModeLift()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ChangeModeSearch()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ChangeModeFree(bool one_hand=false)"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ChangeModeOpen()"
    },
    {
      "namespace": "hand::script",
      "declaration": "void ChangeModeWaitOpen()"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffForceDamageStar(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnForceDamageStar(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetScopeFly(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetScopeFloat(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetScopeGround(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsNoChangeAnimeUnit(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffNoChangeAnimeUnit(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnNoChangeAnimeUnit(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffNoStayPoseGap(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnNoStayPoseGap(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffHideUpdate(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnHideUpdate(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffForceUpdate(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnForceUpdate(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsForceUpdate(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffForceHideNear(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnForceHideNear(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsForceHideNear(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffNoHideOutScreen(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnNoHideOutScreen(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsNoHideOutScreen(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffNoHideNear(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnNoHideNear(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsNoHideNear(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffNoCollision(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnNoCollision(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsNoCollision(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffFixCollision(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnFixCollision(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffNoTarget(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnNoTarget(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffDirect(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnDirect(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffStatus(const PartsHandle& handle, as_u64 flag)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnStatus(const PartsHandle& handle, as_u64 flag)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool CheckStatus(const PartsHandle& handle, as_u64 flag)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as::Variable& GetVariable(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsKouraIn(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsFly(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsFloat(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffGround(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnGround(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsGround(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OffDefenseAttr(const PartsHandle& handle, as_u64 flag)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnDefenseAttr(const PartsHandle& handle, as_u64 flag)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool CheckDefenseAttr(const PartsHandle& handle, as_u64 flag)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffPanelInvalid(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnPanelInvalid(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsPanelInvalid(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffPanelUsed(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnPanelUsed(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffPanelHold(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnPanelHold(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsPanelHold(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsPanelFix(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsPanelEnable(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsPanelUsed(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffPanelSet(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnPanelSet(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsPanelSet(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffForceUpdate(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnForceUpdate(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsForceUpdate(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsDispRealDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffDispRealDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnDispRealDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsRotateJumpAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffRotateJumpAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnRotateJumpAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsNoTogeCounterStan(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoTogeCounterStan(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoTogeCounterStan(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsNoTogeCounterPinch(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoTogeCounterPinch(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoTogeCounterPinch(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAttackConditionIce(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffAttackConditionIce(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnAttackConditionIce(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsDamage1To0(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffDamage1To0(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnDamage1To0(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsDamage2To1(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffDamage2To1(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnDamage2To1(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsMultiChr(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffMultiChr(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnMultiChr(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsNoHitGobj(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoHitGobj(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoHitGobj(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsNoMoveRing(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoMoveRing(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoMoveRing(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoCollision(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoCollision(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsNoCollision(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsTransparent(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffTransparent(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnTransparent(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool CheckNoTarget(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoTarget(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoTarget(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoReturnHome(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoReturnHome(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoStopFormationAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoStopFormationAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsNoStopFormationAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoWarawaraAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoWarawaraAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsNoWarawaraAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoFormationAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoFormationAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsNoFormationAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoGuard(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoGuard(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNextUnitAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNextUnitAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffStatus(const UnitHandle& handle, as_u64 flag)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnStatus(const UnitHandle& handle, as_u64 flag)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool CheckStatus(const UnitHandle& handle, as_u64 flag)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAttrRoot(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAttrToge(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAttrBossReal(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAttrBossOrigami(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAttrGround(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAttrFloat(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAttrFly(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAttrFaceSide(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAttrFaceFront(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffAttr(const UnitHandle& handle, as_u32 flag)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnAttr(const UnitHandle& handle, as_u32 flag)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool CheckAttr(const UnitHandle& handle, as_u32 flag)"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetEscapeRate()"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetEscapeTryCount()"
    },
    {
      "namespace": "btl::record",
      "declaration": "bool IsCanCheer()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void AddBonusNpcDamageCount()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void AddBonusNpcEnterCount()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void AddCheerAcMissPoint()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void AddCheerAcExcellentPoint()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void AddCheerEasePoint()"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetCheerEasePointCoin()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void AddAddTimeEasePoint()"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetAddTimeEasePointTime()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void AddBossChargePoint()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void AddUsed1upKinokoPoint()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void AddUsedKinokoPoint()"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetLabSugorokuAttackTime()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void SetLabSugorokuAttackTime(as_s32 val)"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetLabPuzzleResult(as_s32 no)"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetLabPuzzlePlayNum()"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetLabTimeAttackRestTime()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void SetLabTimeAttackRestTime(as_s32 val)"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetLabPuzzleAttackTime()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void SetLabPuzzleAttackTime(as_s32 val)"
    },
    {
      "namespace": "btl::record",
      "declaration": "void DisableDrawRoot()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void EnableDrawRoot()"
    },
    {
      "namespace": "btl::record",
      "declaration": "bool IsEscapeMiss()"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetWaveTurn()"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetTurn()"
    },
    {
      "namespace": "btl::record",
      "declaration": "void SetAP(as_s32 val)"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_f32 GetRateAP()"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetAP()"
    },
    {
      "namespace": "btl::record",
      "declaration": "as_s32 GetMP()"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionGasDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionTurnOver(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionMagicEarth(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionMagicEarth(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionCheerSleep(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionPierced(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionCrucifixion(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionHole(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionRubberBand(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionIceGuard(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionDoubleIce(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionIce(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionThunder(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionFire(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsConditionStan(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionTurnOver(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionCheerSleep(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionPierced(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionCrucifixion(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionHole(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionRubberBand(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionIceGuard(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionDoubleIce(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionIce(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionThunder(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionFire(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetConditionStan(const UnitHandle& handle, as_s32 turn)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffNoConditionEffect(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnNoConditionEffect(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::collision",
      "declaration": "void CheckMap(math::Vec3& pos)"
    },
    {
      "namespace": "btl::collision",
      "declaration": "float GetGroundHeight()"
    },
    {
      "namespace": "btl::collision",
      "declaration": "void SetGroundHeight(as_f32 height)"
    },
    {
      "namespace": "btl::collision",
      "declaration": "UnitHandle GetCheckUnit()"
    },
    {
      "namespace": "btl::collision",
      "declaration": "PartsHandle GetHitParts()"
    },
    {
      "namespace": "btl::collision",
      "declaration": "UnitHandle GetHitUnit()"
    },
    {
      "namespace": "btl::drop",
      "declaration": "UnitHandle GetDropPanelMagicUnit()"
    },
    {
      "namespace": "btl::drop",
      "declaration": "void DropPanelMagic(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::drop",
      "declaration": "void DropItem(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::event",
      "declaration": "bool IsEventLose1upKinoko()"
    },
    {
      "namespace": "btl::event",
      "declaration": "bool IsEventLose()"
    },
    {
      "namespace": "btl::event",
      "declaration": "void WaitEventStartSelectCmd()"
    },
    {
      "namespace": "btl::event",
      "declaration": "void WaitEventEndMoveRing()"
    },
    {
      "namespace": "btl::event",
      "declaration": "void WaitEventStartMoveRing()"
    },
    {
      "namespace": "btl::event",
      "declaration": "void WaitEventEnemyTurn()"
    },
    {
      "namespace": "btl::event",
      "declaration": "void WaitEventStartTurn()"
    },
    {
      "namespace": "btl::event",
      "declaration": "void SetEventScript(const UnitHandle& handle)"
    },
    {
      "namespace": "snd::battle",
      "declaration": "bool IsOverrideID()"
    },
    {
      "namespace": "snd::battle",
      "declaration": "void ResetOverrideID()"
    },
    {
      "namespace": "snd::battle",
      "declaration": "void SetOverrideID(const string& id)"
    },
    {
      "namespace": "snd::battle",
      "declaration": "bool IsPlayingFF()"
    },
    {
      "namespace": "snd::battle",
      "declaration": "void StopFF(as_f32 fade)"
    },
    {
      "namespace": "snd::battle",
      "declaration": "void PlayFF(const string& id)"
    },
    {
      "namespace": "snd::battle",
      "declaration": "void SetVolumeBGM(as_f32 vol, as_f32 fade)"
    },
    {
      "namespace": "snd::battle",
      "declaration": "void StopBGM(as_f32 fade)"
    },
    {
      "namespace": "snd::battle",
      "declaration": "void ResumePauseBGM(as_f32 fade)"
    },
    {
      "namespace": "snd::battle",
      "declaration": "void PauseBGM(as_f32 fade)"
    },
    {
      "namespace": "snd::battle",
      "declaration": "void PlayBGM(const string& id)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void FlyPosMsec(const EffectHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void FlyPos(const EffectHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void _FlyPos(const EffectHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void FallContinue(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void FallPosMsec(const EffectHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void FallPos(const EffectHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void _FallPos(const EffectHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void JumpOnlyPosMsec(const EffectHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void JumpPosMsec(const EffectHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void JumpPos(const EffectHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void _JumpPos(const EffectHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, bool jumpOnly)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void MovePosMsec(const EffectHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void MovePos(const EffectHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void _MovePos(const EffectHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, as_f32 tdist, bool sound, as_s32 type)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void Rotate(const EffectHandle& handle, as_f32 x, as_f32 y, as_f32 z, as_f32 msec)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void ResetFallAcc(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "as_f32 GetFallAcc(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFallAcc(const EffectHandle& handle, as_f32 acc)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EffectHoleHealStar(const UnitHandle& handle, as_s32 num)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EffectHealStar(const UnitHandle& handle, as_s32 num)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EffectDisableSignal(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EffectEnableSignal(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetDeadEffectName(const UnitHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "EffectHandle GetEffectStartPos(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetEffectIceRot(const UnitHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetEffectIceScale(const UnitHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetEffectIceEndAnimeNoClearFollow(const UnitHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetEffectIceEndAnime(const UnitHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetEffectIceFollowLocator(const UnitHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EffectDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EffectDamageWater(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EffectDamageIce(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EffectDamageFire(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EffectDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EffectLanding(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EffectJump(const UnitHandle& handle)"
    },
    {
      "namespace": "snd::fade",
      "declaration": "as_f32 GetFadeTime(const string& name)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "bool CheckCanSlideRing(as_s32 no)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 CheckCanRotateRing(as_s32 no)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void GetBonusHeartL()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void GetBonusHeartM()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void GetBonusHeartS()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void AddCoin100()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void AddCoin10()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void AddCoin1()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetJumpCount()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetHammerCount()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void GetAnswerMoveRing(as_s32 no, as_s32& type, as_s32& ring_no, as_s32& count)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetAnswerMoveRingNum()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void ResetDoneDispos()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetBingoBonus(bool success)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetThinkTime()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetThinkTime(as_s32 time)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void DischargeHeart()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void ScatterCoin(as_s32 level)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "bool ComarePictureBlockInfo(as_s32 ring_no)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "bool ComarePictureBlockInfo()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SavePictureBlockInfo()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "bool GetBlockInfoRouteEnd(as_s32 ring_no, as_s32 angle)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "bool GetBlockInfoRoute(as_s32 ring_no, as_s32 angle)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetBlockInfoRoute(as_s32 ring_no, as_s32 angle)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetPlayerRouteBlockInfo()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void GetBlockInfoIDList(as_s32 id, array<RangePos>& list)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetBlockInfoID(as_s32 ring_no, as_s32 angle)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetBlockInfoID(as_s32 ring_no, as_s32 angle, as_s32 id)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void ResetBlockInfo()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void ResetMagicPanel()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void UsedMagicPanel()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void HideAllPanel()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetExcellentCount()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "UnitHandle GetDisposPanel(as_s32 panel, as_s32 no)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "bool IsCantUsedMagic()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "UnitHandle PopPanelDispos(int panel, int ring_no=0, int angle=0)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void AddSpecialPanelDispos(as_s32 panel)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void AddPanelArea(int panel, int area1=0, int area2=0, int area3=0)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void AddPanelDispos(as_s32 panel)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetPanelDispos(int panel, int ring_no=0, int angle=0)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "RangePos GetReservedRangePos(as_s32 board, as_s32 priority)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void GetNoneReservedList(array<RangePos>& list)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void GetEmptyReservedList(array<RangePos>& list)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void GetEmptyReservedList(as_s32 type, array<RangePos>& list)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void setReservedNG(as_s32 ring, as_s32 angle)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void setReservedBan(as_s32 board, as_s32 priority)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetReservedChange(as_s32 panel)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetReservedMagicChange(as_s32 panel)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetReservedAttackChange(as_s32 panel)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetReservedArrowIn(as_s32 num)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetReservedArrowReverse(as_s32 num)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetReservedPanel(as_s32 panel, as_s32 priority = 0)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void MoveReservedPanel(as_s32 boardType, as_s32 priority, as_s32 ring, as_s32 angle)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void AddReservedPanel(as_s32 boardType, as_s32 ring, as_s32 angle)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "bool GetReservedPreset()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void GetBoardTypeRangePos(as_s32 type, array<RangePos>& list)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetAttackNumLeft()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetAttackNum()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetMoveRingNumLeft()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetMoveRingNum()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetMoveRingNumLeft(const as_s32 num)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetMoveRingNum(const as_s32 num)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetSugorokuMoveRingNum(const as_s32 num)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetPresetControl(bool slide, as_s32 no, as_s32 num)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetPresetSetIdAtPlayer(const string& id)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetPresetSetId(const UnitHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetPresetSetId(const string& id)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetBackupUse()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetRandomRotateSlideCountExEx(int count, int type1, int no1, int count1, int type2=0, int no2=0, int count2=0, int type3=0, int no3=0, int count3=0)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetRandomRotateSlideCountEx(int count, int type1, int no1, int type2=0, int no2=0, int type3=0, int no3=0)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetRandomRotateSlideCount(int count, int type1, int type2=0, int type3=0)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetRandomRotateSlideType(as_s32 index, as_s32 type, as_s32 no, as_s32 count)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetRandomRotateSlideCount(as_s32 count)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetRecoveryPanelDisposNum()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetRecoveryPanelDisposNum(as_s32 num)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetAttackPanelDisposNum()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetAttackPanelDisposNum(as_s32 num)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetDummyPanelDisposNum()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetDummyPanelDisposNum(as_s32 num)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "as_s32 GetMovePanelDisposNum()"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void SetMovePanelDisposNum(as_s32 num)"
    },
    {
      "namespace": "btl::MR",
      "declaration": "void ClearAllPanelDisposNum()"
    },
    {
      "namespace": "btl::set",
      "declaration": "string GetID()"
    },
    {
      "namespace": "btl::set",
      "declaration": "void SetupSpecialOrFixPanel(const string& id)"
    },
    {
      "namespace": "btl::set",
      "declaration": "void UnsetSpecialAndFixPanel()"
    },
    {
      "namespace": "btl::set",
      "declaration": "void SetBattleLabList(array<string>& list)"
    },
    {
      "namespace": "btl::set",
      "declaration": "void GetAreaEncountSymbolList(array<string>& list)"
    },
    {
      "namespace": "btl::set",
      "declaration": "void ResetSeqBattle()"
    },
    {
      "namespace": "btl::set",
      "declaration": "as_s32 GetRestAreaEncount()"
    },
    {
      "namespace": "btl::set",
      "declaration": "as_s32 GetAreaEncountNo()"
    },
    {
      "namespace": "btl::set",
      "declaration": "as_s32 GetAreaEncountNum()"
    },
    {
      "namespace": "btl::set",
      "declaration": "void SetBattleTypeQuizSong()"
    },
    {
      "namespace": "btl::set",
      "declaration": "void SetBattleTypeQuizCount()"
    },
    {
      "namespace": "btl::set",
      "declaration": "void SetBattleTypeQuizShuffle()"
    },
    {
      "namespace": "btl::set",
      "declaration": "void SetBattleTypeQuizRace()"
    },
    {
      "namespace": "btl::set",
      "declaration": "void SetBattleTypeQuizPicture()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeViewer()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeSugorokuLast()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeLab()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeJunkenLab()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeSugorokuLab()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypePuzzleTimeLab()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypePuzzleLab()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeFree()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeQuizSong()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeQuizCount()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeQuizShuffle()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeQuizRace()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeQuizPicture()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeQuizTop()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeQuiz()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypePictureLast()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypeSugoroku()"
    },
    {
      "namespace": "btl::set",
      "declaration": "bool IsBattleTypePuzzle()"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SoundFootStep(const UnitHandle& handle, as_f32 dist, bool sync)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SoundDisable(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SoundEnable(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SoundDisableSignal(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SoundEnableSignal(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SoundDamageToge(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SoundSetDamageFlag(const UnitHandle& handle, const string& flag)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SoundDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SoundAttack(const UnitHandle& handle, as_f32 vol=1.0f, const string& flag=\"\")"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SoundLanding(const UnitHandle& handle, as_f32 vol=1.0f, const string& flag=\"\")"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SoundJump(const UnitHandle& handle, as_f32 vol=1.0f, const string& flag=\"\")"
    },
    {
      "namespace": "btl::unit",
      "declaration": "snd::VoiceHandle SoundFollowSE(const UnitHandle& handle, const string& flag)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "snd::VoiceHandle SoundSE(const UnitHandle& handle, const string& flag)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetConfettiAlphaForForward( float alpha )"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetConfettiRenderPassDeferred()"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetConfettiRenderPassForward()"
    },
    {
      "namespace": "confetti",
      "declaration": "void FastForwardTime(float msec)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetWindAccel(float accel)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetEventMode_ForHarikoClear()"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetEventMode_ForHarikoBreak()"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetEventMode_ForKPMaxUpNew()"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetEventMode_ForKPMaxUp()"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetEventMode_ForTapeBreak()"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetEventMode_NoEvent()"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetEventMode2(bool enable)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetEventMode(bool enable)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetConfettiEmissionForEvent(float emission)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetConfettiBrightnessForEvent(int brightness)"
    },
    {
      "namespace": "confetti",
      "declaration": "void RenderConfettiPaper1f(const math::Mtx43& mtx, float r=1.0f, float g=1.0f, float b=1.0f, int pattern=0, float curvedeg=0.0f)"
    },
    {
      "namespace": "confetti",
      "declaration": "void RenderConfettiPaper1f(const math::Mtx43& mtx, float scale, float r, float g, float b, int pattern=0, float curvedeg=0.0f)"
    },
    {
      "namespace": "confetti",
      "declaration": "void RenderConfettiPaper1f(const math::Vec3& pos, const math::Vec3& rotdeg, float scale, float r, float g, float b, int pattern=0, float curvedeg=0.0f)"
    },
    {
      "namespace": "confetti",
      "declaration": "void RenderConfettiPaper1f(const math::Mtx43& mtx, float scale=1.0f, int color=0, int pattern=0, float curvedeg=0.0f)"
    },
    {
      "namespace": "confetti",
      "declaration": "void RenderConfettiPaper1f(const math::Vec3& pos, const math::Vec3& rotdeg, float scale=1.0f, int color=0, int pattern=0, float curvedeg=0.0f)"
    },
    {
      "namespace": "confetti",
      "declaration": "void ClearLocator()"
    },
    {
      "namespace": "confetti",
      "declaration": "void ClearLocator(chr::Handle handle)"
    },
    {
      "namespace": "confetti",
      "declaration": "void BeginConfettiLocator(chr::Handle handle, const array<string>& list, float v_front=3.0, float v_up=1.0, float v_rand_front=2.0, float v_rand_right=2.0, float v_rand_up=1.0)"
    },
    {
      "namespace": "confetti",
      "declaration": "void RemoveConfettiPaperFollow(chr::Handle handle, const string& lctName)"
    },
    {
      "namespace": "confetti",
      "declaration": "void AddConfettiPaperFollow(chr::Handle handle, const string& lctName, float scale, int color, int pattern)"
    },
    {
      "namespace": "confetti",
      "declaration": "int GetConfettiPaperColorNum()"
    },
    {
      "namespace": "confetti",
      "declaration": "bool ExistsAirFromPlayer()"
    },
    {
      "namespace": "confetti",
      "declaration": "void EraseGroundConfetti()"
    },
    {
      "namespace": "confetti",
      "declaration": "void EraseCollectableConfetti()"
    },
    {
      "namespace": "confetti",
      "declaration": "void EraseAllConfetti()"
    },
    {
      "namespace": "confetti",
      "declaration": "bool IsDisabledCollectPaper()"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetDisabledCollectPaper(bool disable)"
    },
    {
      "namespace": "confetti",
      "declaration": "bool IsEnableGoldenPaper()"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetEraseTime(int msec)"
    },
    {
      "namespace": "confetti",
      "declaration": "void ResetVaccumConfettiPos()"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetVaccumConfettiPos(math::Vec3 globaoPos)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetVaccumConfettiRange(float range)"
    },
    {
      "namespace": "confetti",
      "declaration": "void EnableVaccumConfetti(bool enable)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetEnableGoldenPaper(bool enable)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetVaccumConfettiTime(float frames)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetDisabledRepair(bool disable)"
    },
    {
      "namespace": "confetti",
      "declaration": "void DisableErase(bool erase)"
    },
    {
      "namespace": "confetti",
      "declaration": "int countCollectableConfetti()"
    },
    {
      "namespace": "confetti",
      "declaration": "void BeginConfettiColorMaxUp(const math::Vec3& pos, float r, int paperNum, const math::Vec3& color, float scale)"
    },
    {
      "namespace": "confetti",
      "declaration": "void BeginConfettiColor(const math::Vec3 &pos, const math::Vec3& dir, int paperNum, const math::Vec3& color, float v_front=3.0, float v_up=1.0, float v_rand_front=2.0, float v_rand_right=2.0, float v_rand_up=1.0)"
    },
    {
      "namespace": "confetti",
      "declaration": "void BeginConfettiColorNoSE(const math::Vec3 &pos, const math::Vec3& dir, int paperNum, const math::Vec3& color, float v_front=3.0, float v_up=1.0, float v_rand_front=2.0, float v_rand_right=2.0, float v_rand_up=1.0)"
    },
    {
      "namespace": "confetti",
      "declaration": "void BeginSquareConfetti(const math::Vec3 &pos, const math::Vec3& dir, int paperNum, float v_front=3.0, float v_up=1.0, float v_rand_front=2.0, float v_rand_right=2.0, float v_rand_up=1.0, float scale=1.0)"
    },
    {
      "namespace": "confetti",
      "declaration": "void BeginConfetti(const math::Vec3 &pos, const math::Vec3& dir, int paperNum, float v_front=3.0, float v_up=1.0, float v_rand_front=2.0, float v_rand_right=2.0, float v_rand_up=1.0)"
    },
    {
      "namespace": "confetti",
      "declaration": "void BeginConfettiNoSE(const math::Vec3 &pos, const math::Vec3& dir, int paperNum, float v_front=3.0, float v_up=1.0, float v_rand_front=2.0, float v_rand_right=2.0, float v_rand_up=1.0, float scale=0, int pattern=-1)"
    },
    {
      "namespace": "confetti",
      "declaration": "void DebugRepairAllMapHole()"
    },
    {
      "namespace": "confetti",
      "declaration": "bool IsDisposHole(const string & name)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetHoleFlagWithoutDispos( const string& mapName, const string& holeName, bool repair )"
    },
    {
      "namespace": "confetti",
      "declaration": "bool GetHoleFlag( const string& mapName, const string& holeName )"
    },
    {
      "namespace": "confetti",
      "declaration": "math::Vec3 GetHoleRot( const string& holeName )"
    },
    {
      "namespace": "confetti",
      "declaration": "math::Vec3 GetHolePos( const string& holeName )"
    },
    {
      "namespace": "confetti",
      "declaration": "int GetRepairedHoleNum()"
    },
    {
      "namespace": "confetti",
      "declaration": "int GetHoleNum()"
    },
    {
      "namespace": "confetti",
      "declaration": "string GetHoleName(const int idx)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetBlackVisibility(const string & name, bool visible)"
    },
    {
      "namespace": "confetti",
      "declaration": "bool IsYatara(const string & name)"
    },
    {
      "namespace": "confetti",
      "declaration": "void EnableSmallHole(const string & name)"
    },
    {
      "namespace": "confetti",
      "declaration": "bool IsDisabledHole(const string & name)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetDisabledHole(const string & name, bool disable)"
    },
    {
      "namespace": "confetti",
      "declaration": "bool IsInactiveHole(const string & name)"
    },
    {
      "namespace": "confetti",
      "declaration": "void SetInactiveHole(const string & name, bool inactive)"
    },
    {
      "namespace": "confetti",
      "declaration": "int GetHoleNeedPaperNum(const string & name)"
    },
    {
      "namespace": "confetti",
      "declaration": "int GetHolePaperNum(const string & name)"
    },
    {
      "namespace": "confetti",
      "declaration": "float GetHoleRepairRate(const string & name)"
    },
    {
      "namespace": "confetti",
      "declaration": "bool IsCompleteHole(const string & name)"
    },
    {
      "namespace": "confetti",
      "declaration": "bool IsSuccessHole(const string & name)"
    },
    {
      "namespace": "confetti",
      "declaration": "void UnrepairHole(const string & name)"
    },
    {
      "namespace": "confetti",
      "declaration": "void RepairHoleSoon(const string & name)"
    },
    {
      "namespace": "confetti",
      "declaration": "void RepairHole(const string & name)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetSSAOFlagOnlyChara(bool flag)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetSSAOAlpha(f32 alpha)"
    },
    {
      "namespace": "gfx",
      "declaration": "void PlanarReflectionEnable()"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetPaperReflectionToUnlimitPos()"
    },
    {
      "namespace": "gfx",
      "declaration": "void StartupMonitorScene()"
    },
    {
      "namespace": "gfx",
      "declaration": "void ChangeSunShadowPreset(const ::string& presetName)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetDistortionIntesity(f32 intensity)"
    },
    {
      "namespace": "gfx",
      "declaration": "void DisableDistortionFilter()"
    },
    {
      "namespace": "gfx",
      "declaration": "void EnableDistortionFilter()"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLitNeonZWidth(f32 width)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLitNeonZDist(f32 distance)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetOceanFogHeightAlpha(f32 alpha)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetOceanFogAlpha(f32 alpha)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetOceanFogMode(int mode)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetOceanFogVisible(bool flag)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetSilhouetteResolverVisibility(bool flag)"
    },
    {
      "namespace": "gfx",
      "declaration": "void ChangePlayerSilhouetteThreshold(float threshold)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetEventSilhouette2Visibility(bool flag)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetEventSilhouetteVisibility(bool flag)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetPlayerSilhouetteVisibility(bool flag)"
    },
    {
      "namespace": "gfx",
      "declaration": "void ReleaseStopBlurFilter()"
    },
    {
      "namespace": "gfx",
      "declaration": "void RequestStopBlurFilter( int blurLevel, int frame, bool enableFade, float alphaTo )"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetWaterAlbedoFilterLut(const string& name)"
    },
    {
      "namespace": "gfx",
      "declaration": "void ResumeGobjAnime()"
    },
    {
      "namespace": "gfx",
      "declaration": "void PauseGobjAnime()"
    },
    {
      "namespace": "gfx",
      "declaration": "void UpdateStaticObjShadow()"
    },
    {
      "namespace": "gfx",
      "declaration": "void CreateRealWaterRippleWave(mobj::Handle handle, const math::Vec3& pos, f32 scale, f32 limit, bool forceCreate = false)"
    },
    {
      "namespace": "gfx",
      "declaration": "void CreateRealWaterRippleWave(mobj::Handle handle, const math::Vec3& pos, f32 scale, bool forceCreate = false)"
    },
    {
      "namespace": "gfx",
      "declaration": "void DofBlurSize( f32 size )"
    },
    {
      "namespace": "gfx",
      "declaration": "void DofFarBeginEnd( f32 begin, f32 end )"
    },
    {
      "namespace": "gfx",
      "declaration": "void DofNearBeginEnd( f32 begin, f32 end )"
    },
    {
      "namespace": "gfx",
      "declaration": "void DisableDof()"
    },
    {
      "namespace": "gfx",
      "declaration": "void EnableDof()"
    },
    {
      "namespace": "gfx",
      "declaration": "void DistFogBlendType( int type )"
    },
    {
      "namespace": "gfx",
      "declaration": "void DistFogBeginEnd(f32 begin, f32 end)"
    },
    {
      "namespace": "gfx",
      "declaration": "void DistFogIntensity(f32 intensity)"
    },
    {
      "namespace": "gfx",
      "declaration": "void DistFogColor(f32 r, f32 g, f32 b)"
    },
    {
      "namespace": "gfx",
      "declaration": "void DisableDistFog()"
    },
    {
      "namespace": "gfx",
      "declaration": "void EnableDistFog()"
    },
    {
      "namespace": "gfx",
      "declaration": "void PhotoGenerate( )"
    },
    {
      "namespace": "gfx",
      "declaration": "void FilterDynamicPeraMaskFlag(bool flag)"
    },
    {
      "namespace": "gfx",
      "declaration": "void FilterFillBg(const ::string& id, f32 a)"
    },
    {
      "namespace": "gfx",
      "declaration": "void FilterFillBg(const ::string& id)"
    },
    {
      "namespace": "gfx",
      "declaration": "void FilterFillAlpha(f32 a)"
    },
    {
      "namespace": "gfx",
      "declaration": "void FilterFillColor(f32 r, f32 g, f32 b)"
    },
    {
      "namespace": "gfx",
      "declaration": "void FilterBrightness(f32 brightness)"
    },
    {
      "namespace": "gfx",
      "declaration": "void EndFilter()"
    },
    {
      "namespace": "gfx",
      "declaration": "void BeginFilterKeepEffectScene()"
    },
    {
      "namespace": "gfx",
      "declaration": "void BeginFilter()"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetStencilShadowDarkness(f32 darkness)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetFixedModeForLightCastShadow(bool isFixedMode)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightIntensitySubMul(const string& name, float intensity)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightCastShadowToDefault(const string& name)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightCastShadow(const string& name, bool flag)"
    },
    {
      "namespace": "gfx",
      "declaration": "void setLightConeAngle(gfx::SpotLight handle, float innerConeAngle, float outerConeAngle )"
    },
    {
      "namespace": "gfx",
      "declaration": "void setLightLength(gfx::SpotLight handle, float near, float far )"
    },
    {
      "namespace": "gfx",
      "declaration": "void setLightLength(gfx::SpotLight handle, float length )"
    },
    {
      "namespace": "gfx",
      "declaration": "void setLightDirection(gfx::SpotLight handle, float azimuth, float altitude )"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightPosition(gfx::SpotLight handle, const math::Vec3& pos)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightColor(gfx::SpotLight handle, const math::Vec3& color)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightName(gfx::SpotLight handle, const string& name)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightVisible(gfx::SpotLight handle, bool visible)"
    },
    {
      "namespace": "gfx",
      "declaration": "void DestroyLight(gfx::SpotLight handle)"
    },
    {
      "namespace": "gfx",
      "declaration": "gfx::SpotLight CreateSpotLight(const math::Vec3& pos, float length)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightInOutRadius(gfx::PointLight handle, float innerRadius, float outerRadius)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightRadius(gfx::PointLight handle, float radius)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightPosition(gfx::PointLight handle, const math::Vec3& pos)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightColor(gfx::PointLight handle, const math::Vec3& color)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightName(gfx::PointLight handle, const string& name)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetLightVisible(gfx::PointLight handle, bool visible)"
    },
    {
      "namespace": "gfx",
      "declaration": "void DestroyLight(gfx::PointLight handle)"
    },
    {
      "namespace": "gfx",
      "declaration": "gfx::PointLight CreatePointLight(const math::Vec3& pos, float radius)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetGlobalLightDirection(float azimuth, float altitude)"
    },
    {
      "namespace": "gfx",
      "declaration": "void SetGlobalLightColor(const math::Vec3& color)"
    },
    {
      "namespace": "gfx",
      "declaration": "void ChangeSubRenderParams(const ::string& id, float msec)"
    },
    {
      "namespace": "gfx",
      "declaration": "void EndOtherRenderParams()"
    },
    {
      "namespace": "gfx",
      "declaration": "void BeginOtherRenderParams( const ::string& id )"
    },
    {
      "namespace": "",
      "declaration": "bool is_system_flag_itemget()"
    },
    {
      "namespace": "",
      "declaration": "bool is_system_flag_menu()"
    },
    {
      "namespace": "",
      "declaration": "void set_skip_counter(as_u32 mask, as_u32 counter)"
    },
    {
      "namespace": "",
      "declaration": "void disable_thread_build()"
    },
    {
      "namespace": "",
      "declaration": "void enable_thread_build()"
    },
    {
      "namespace": "",
      "declaration": "bool wait_timer()"
    },
    {
      "namespace": "",
      "declaration": "void start_timer(as_f32 msec)"
    },
    {
      "namespace": "",
      "declaration": "int run_ctrl(int flg)"
    },
    {
      "namespace": "",
      "declaration": "void exit_end(void)"
    },
    {
      "namespace": "",
      "declaration": "void exit_start(void)"
    },
    {
      "namespace": "",
      "declaration": "void shared_brother_end(void)"
    },
    {
      "namespace": "",
      "declaration": "void shared_brother_start(void)"
    },
    {
      "namespace": "",
      "declaration": "void shared_brother_start(as::Variable& handle)"
    },
    {
      "namespace": "",
      "declaration": "void shared_brother_start(as::ContextHandle& handle)"
    },
    {
      "namespace": "",
      "declaration": "void brother_end(void)"
    },
    {
      "namespace": "",
      "declaration": "void brother_start(void)"
    },
    {
      "namespace": "",
      "declaration": "void brother_start(as::Variable& handle)"
    },
    {
      "namespace": "",
      "declaration": "void brother_start(as::ContextHandle& handle)"
    },
    {
      "namespace": "",
      "declaration": "void shared_inline_end(void)"
    },
    {
      "namespace": "",
      "declaration": "void shared_inline_start(void)"
    },
    {
      "namespace": "",
      "declaration": "void shared_inline_start(as::Variable& handle)"
    },
    {
      "namespace": "",
      "declaration": "void shared_inline_start(as::ContextHandle& handle)"
    },
    {
      "namespace": "",
      "declaration": "void inline_end(void)"
    },
    {
      "namespace": "",
      "declaration": "void inline_start(void)"
    },
    {
      "namespace": "",
      "declaration": "void inline_start(as::Variable& handle)"
    },
    {
      "namespace": "",
      "declaration": "void inline_start(as::ContextHandle& handle)"
    },
    {
      "namespace": "",
      "declaration": "void exit_off(void)"
    },
    {
      "namespace": "",
      "declaration": "void exit_on(void)"
    },
    {
      "namespace": "",
      "declaration": "void exit(const string& func, any@ arg)"
    },
    {
      "namespace": "",
      "declaration": "void exit(const string& func)"
    },
    {
      "namespace": "",
      "declaration": "as::ContextHandle post_run_brother(const string& func, any@ arg)"
    },
    {
      "namespace": "",
      "declaration": "as::ContextHandle post_run_brother(const string& func)"
    },
    {
      "namespace": "",
      "declaration": "as::ContextHandle run_brother(const string& func, any@ arg)"
    },
    {
      "namespace": "",
      "declaration": "as::ContextHandle run_brother(const string& func)"
    },
    {
      "namespace": "",
      "declaration": "as::ContextHandle run_brother(const any& class_obj, const string& func)"
    },
    {
      "namespace": "",
      "declaration": "as::ContextHandle post_run(const string& func, any@ arg)"
    },
    {
      "namespace": "",
      "declaration": "as::ContextHandle post_run(const string& func)"
    },
    {
      "namespace": "",
      "declaration": "as::ContextHandle post_run(const any& class_obj, const string& func)"
    },
    {
      "namespace": "",
      "declaration": "as::ContextHandle run(const string& func, any@ arg)"
    },
    {
      "namespace": "",
      "declaration": "as::ContextHandle run(const string& func)"
    },
    {
      "namespace": "",
      "declaration": "as::ContextHandle run(const any& class_obj, const string& func)"
    },
    {
      "namespace": "",
      "declaration": "bool search_function(const string& func)"
    },
    {
      "namespace": "",
      "declaration": "void clear_parent(as::ContextHandle handle)"
    },
    {
      "namespace": "",
      "declaration": "void clear_my_parent()"
    },
    {
      "namespace": "",
      "declaration": "bool busy(as::ContextHandle handle)"
    },
    {
      "namespace": "",
      "declaration": "void wait(as::ContextHandle handle)"
    },
    {
      "namespace": "",
      "declaration": "void stop_my_all_child()"
    },
    {
      "namespace": "",
      "declaration": "void stop_with_all_child(as::ContextHandle handle)"
    },
    {
      "namespace": "",
      "declaration": "void stop(as::ContextHandle handle)"
    },
    {
      "namespace": "",
      "declaration": "bool& slw_bool(int no)"
    },
    {
      "namespace": "",
      "declaration": "void slw_string_set(int no, const string& str)"
    },
    {
      "namespace": "",
      "declaration": "string& slw_string(int no)"
    },
    {
      "namespace": "",
      "declaration": "as_f32& slw_float(int no)"
    },
    {
      "namespace": "",
      "declaration": "as_u32& slw_hex(int no)"
    },
    {
      "namespace": "",
      "declaration": "int& slw_int(int no)"
    },
    {
      "namespace": "",
      "declaration": "as::Variable& slw(int no)"
    },
    {
      "namespace": "",
      "declaration": "any@ lw_any(int no)"
    },
    {
      "namespace": "",
      "declaration": "bool& lw_bool(int no)"
    },
    {
      "namespace": "",
      "declaration": "void lw_string_set(int no, const string& str)"
    },
    {
      "namespace": "",
      "declaration": "string& lw_string(int no)"
    },
    {
      "namespace": "",
      "declaration": "as_f32& lw_float(int no)"
    },
    {
      "namespace": "",
      "declaration": "as_u32& lw_hex(int no)"
    },
    {
      "namespace": "",
      "declaration": "int& lw_int(int no)"
    },
    {
      "namespace": "",
      "declaration": "as::Variable& lw(int no)"
    },
    {
      "namespace": "",
      "declaration": "void assertmsg(bool exp, const string& fmt, string p0=\"0\",string p1=\"0\",string p2=\"0\",string p3=\"0\",string p4=\"0\",string p5=\"0\",string p6=\"0\",string p7=\"0\",string p8=\"0\",string p9=\"0\")"
    },
    {
      "namespace": "",
      "declaration": "void assert(bool exp)"
    },
    {
      "namespace": "",
      "declaration": "void warning(bool exp, const string& fmt, string p0=\"0\",string p1=\"0\",string p2=\"0\",string p3=\"0\",string p4=\"0\",string p5=\"0\",string p6=\"0\",string p7=\"0\",string p8=\"0\",string p9=\"0\")"
    },
    {
      "namespace": "",
      "declaration": "int sprint(string& str, const string& fmt, string p0=\"0\",string p1=\"0\",string p2=\"0\",string p3=\"0\",string p4=\"0\",string p5=\"0\",string p6=\"0\",string p7=\"0\",string p8=\"0\",string p9=\"0\")"
    },
    {
      "namespace": "",
      "declaration": "void print(const string& fmt, string p0=\"0\",string p1=\"0\",string p2=\"0\",string p3=\"0\",string p4=\"0\",string p5=\"0\",string p6=\"0\",string p7=\"0\",string p8=\"0\",string p9=\"0\")"
    },
    {
      "namespace": "",
      "declaration": "void put_val(const string& val)"
    },
    {
      "namespace": "",
      "declaration": "void put_val(bool val)"
    },
    {
      "namespace": "",
      "declaration": "void put_val(as_f32 val)"
    },
    {
      "namespace": "",
      "declaration": "void put_val(as_u64 val)"
    },
    {
      "namespace": "",
      "declaration": "void put_val(as_u32 val)"
    },
    {
      "namespace": "",
      "declaration": "void put_val(int val)"
    },
    {
      "namespace": "",
      "declaration": "void put_msg(const string& str)"
    },
    {
      "namespace": "",
      "declaration": "as_f32 get_field_timer_frame(const string& str=\"\")"
    },
    {
      "namespace": "",
      "declaration": "as_u64 get_field_timer_usec(const string& str=\"\")"
    },
    {
      "namespace": "",
      "declaration": "as_u64 get_field_timer_msec(const string& str=\"\")"
    },
    {
      "namespace": "",
      "declaration": "as_u64 get_field_timer(const string& str=\"\")"
    },
    {
      "namespace": "",
      "declaration": "void start_field_timer(const string& str=\"\")"
    },
    {
      "namespace": "",
      "declaration": "void __add_field_timer_total_tick()"
    },
    {
      "namespace": "",
      "declaration": "f32 get_msec_count(void)"
    },
    {
      "namespace": "",
      "declaration": "f32 get_frame_count(void)"
    },
    {
      "namespace": "",
      "declaration": "f32 get_battle_msec_count(void)"
    },
    {
      "namespace": "",
      "declaration": "f32 get_battle_frame_count(void)"
    },
    {
      "namespace": "",
      "declaration": "f32 get_field_msec_count(void)"
    },
    {
      "namespace": "",
      "declaration": "f32 get_field_frame_count(void)"
    },
    {
      "namespace": "",
      "declaration": "f32 get_base_msec_count(void)"
    },
    {
      "namespace": "",
      "declaration": "f32 get_base_frame_count(void)"
    },
    {
      "namespace": "",
      "declaration": "as_u32 get_tick_count()"
    },
    {
      "namespace": "",
      "declaration": "void wait_msec(as_f32 msec)"
    },
    {
      "namespace": "",
      "declaration": "void wait_frame(as_f32 frame)"
    },
    {
      "namespace": "",
      "declaration": "void next_frame()"
    },
    {
      "namespace": "",
      "declaration": "void end(void)"
    },
    {
      "namespace": "util::Color4f",
      "declaration": "const Color4f& Cyan()"
    },
    {
      "namespace": "util::Color4f",
      "declaration": "const Color4f& Magenta()"
    },
    {
      "namespace": "util::Color4f",
      "declaration": "const Color4f& Yellow()"
    },
    {
      "namespace": "util::Color4f",
      "declaration": "const Color4f& Blue()"
    },
    {
      "namespace": "util::Color4f",
      "declaration": "const Color4f& Green()"
    },
    {
      "namespace": "util::Color4f",
      "declaration": "const Color4f& Red()"
    },
    {
      "namespace": "util::Color4f",
      "declaration": "const Color4f& White()"
    },
    {
      "namespace": "util::Color4f",
      "declaration": "const Color4f& Gray()"
    },
    {
      "namespace": "util::Color4f",
      "declaration": "const Color4f& Black()"
    },
    {
      "namespace": "util::Color4f",
      "declaration": "Color4f Lerp(const Color4f& a, const Color4f& b, f32 t)"
    },
    {
      "namespace": "util::Color4u8",
      "declaration": "const Color4u8& Cyan()"
    },
    {
      "namespace": "util::Color4u8",
      "declaration": "const Color4u8& Magenta()"
    },
    {
      "namespace": "util::Color4u8",
      "declaration": "const Color4u8& Yellow()"
    },
    {
      "namespace": "util::Color4u8",
      "declaration": "const Color4u8& Blue()"
    },
    {
      "namespace": "util::Color4u8",
      "declaration": "const Color4u8& Green()"
    },
    {
      "namespace": "util::Color4u8",
      "declaration": "const Color4u8& Red()"
    },
    {
      "namespace": "util::Color4u8",
      "declaration": "const Color4u8& White()"
    },
    {
      "namespace": "util::Color4u8",
      "declaration": "const Color4u8& Gray()"
    },
    {
      "namespace": "util::Color4u8",
      "declaration": "const Color4u8& Black()"
    },
    {
      "namespace": "util::Color4u8",
      "declaration": "Color4u8 Lerp(const Color4u8& a, const Color4u8& b, f32 t)"
    },
    {
      "namespace": "snd::vib",
      "declaration": "void SetLowBPF(as_s32 freq, as_f32 Q)"
    },
    {
      "namespace": "snd::vib",
      "declaration": "void SetHighBPF(as_s32 freq, as_f32 Q)"
    },
    {
      "namespace": "snd::slot",
      "declaration": "void SetSlotCtrlParam(as_f32 lpf, as_f32 min_dist, as_f32 max_dist)"
    },
    {
      "namespace": "snd::slot",
      "declaration": "void SetSendAuxA(const string& name, float send, float fade=0.0f)"
    },
    {
      "namespace": "snd::slot",
      "declaration": "void SetLPF(const string& name, float lpf, float fade=0.0f)"
    },
    {
      "namespace": "snd::slot",
      "declaration": "void ResumePause(const string& name, float fade=0.0f)"
    },
    {
      "namespace": "snd::slot",
      "declaration": "void Pause(const string& name, float fade=0.0f)"
    },
    {
      "namespace": "snd::slot",
      "declaration": "void ResumeMute(const string& name, float fade=0.0f)"
    },
    {
      "namespace": "snd::slot",
      "declaration": "void Mute(const string& name, float fade=0.0f)"
    },
    {
      "namespace": "snd::slot",
      "declaration": "void Silent(const string& name, float rate, float fade=0.0f)"
    },
    {
      "namespace": "snd::slot",
      "declaration": "float GetVolume(const string& name)"
    },
    {
      "namespace": "snd::slot",
      "declaration": "void SetVolume(const string& name, float vol, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "float GetPlayTime(VoiceHandle& handle)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void GetPos(VoiceHandle& handle, math::Vec3& pos)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void SetPos(VoiceHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void SetLpf(VoiceHandle& handle, float pow, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void SetBiquad(VoiceHandle& handle, float pow, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void ResumePause(VoiceHandle& handle, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void Pause(VoiceHandle& handle, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void ResumeMute(VoiceHandle& handle, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void Mute(VoiceHandle& handle, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "bool IsActive(VoiceHandle& handle)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void SetSpan(VoiceHandle& handle, float pan, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void SetPan(VoiceHandle& handle, float pan, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void SetPitch(VoiceHandle& handle, float pitch, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "as_f32 GetVolume(VoiceHandle& handle)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void SetVolume(VoiceHandle& handle, float vol, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void Silent(VoiceHandle& handle, float rate, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void Kill()"
    },
    {
      "namespace": "snd::se",
      "declaration": "void StopAll(as_f32 fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void Kill(VoiceHandle& handle)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void StopNoRelease(VoiceHandle& handle, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void Stop(VoiceHandle& handle, float fade=0.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void WaitPrepared(VoiceHandle& handle)"
    },
    {
      "namespace": "snd::se",
      "declaration": "bool IsPrepared(VoiceHandle& handle)"
    },
    {
      "namespace": "snd::se",
      "declaration": "void Start(VoiceHandle& handle)"
    },
    {
      "namespace": "snd::se",
      "declaration": "VoiceHandle PlayPos(const string& name, const string& flag_name, math::Vec3& pos, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "VoiceHandle PlayPos(const string& name, const string& flag_name, float x, float y, float z, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "VoiceHandle Play(const string& name, const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "VoiceHandle PreparePos(const string& name, const string& flag_name, math::Vec3& pos, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "VoiceHandle PreparePos(const string& name, const string& flag_name, float x, float y, float z, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::se",
      "declaration": "VoiceHandle Prepare(const string& name, const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::ff",
      "declaration": "void SetLPF(float lpf, float fade=0.0f)"
    },
    {
      "namespace": "snd::ff",
      "declaration": "void SetSurroundPan(float pan, float fade=0.0f)"
    },
    {
      "namespace": "snd::ff",
      "declaration": "void SetPan(float pan, float fade=0.0f)"
    },
    {
      "namespace": "snd::ff",
      "declaration": "void SetVolume(float vol, float fade=0.0f)"
    },
    {
      "namespace": "snd::ff",
      "declaration": "void Stop(float fade=0.0f)"
    },
    {
      "namespace": "snd::ff",
      "declaration": "bool IsActive()"
    },
    {
      "namespace": "snd::ff",
      "declaration": "void PlayNoCtrlBGM(const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::ff",
      "declaration": "void PlaySilentBGM(const string& flag_name, float rate, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::ff",
      "declaration": "void PlayMuteBGM(const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::ff",
      "declaration": "void Play(const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void SetLPFElement(const string& name, float lpf, float fade=0.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void SetVolumeElement(const string& name, float vol, float fade=0.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void PlayElement(const string& name, float fade=0.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void StopElement(const string& name, float fade=0.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void ResumeMute(float fade=0.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void Mute(float fade=0.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void ResumePause(float fade=0.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void Pause(float fade=0.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void Silent(float rate, float fade=0.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void SetVolume(int ch, float vol, float fade=0.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void SetVolume(float vol, float fade=0.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void Resume()"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void Stop(float fade=0.0f)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void Change(const string& flag_name)"
    },
    {
      "namespace": "snd::envbgm",
      "declaration": "void Play(const string& flag_name)"
    },
    {
      "namespace": "snd::env",
      "declaration": "void PlayElement(const string& name, float fade=0.0f)"
    },
    {
      "namespace": "snd::env",
      "declaration": "void StopElement(const string& name, float fade=0.0f)"
    },
    {
      "namespace": "snd::env",
      "declaration": "void Resume()"
    },
    {
      "namespace": "snd::env",
      "declaration": "void Stop(float fade=0.0f)"
    },
    {
      "namespace": "snd::env",
      "declaration": "void PlaySub(const string& flag_name)"
    },
    {
      "namespace": "snd::env",
      "declaration": "void Play(const string& flag_name)"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void SetupSurround()"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void SetupSurround(const string& name)"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void SetupEffect()"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void SetupEffect(const string& name)"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void PlaySpaceArea()"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void PlaySpaceArea(const string& name)"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void PlayWind()"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void PlayWind(const string& name)"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void PlayEnv()"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void PlayEnv(const string& name)"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void PlayEnvBGM()"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void PlayEnvBGM(const string& name)"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void PlayBGM()"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void PlayBGM(const string& name)"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void SetupGroup()"
    },
    {
      "namespace": "snd::dispos",
      "declaration": "void SetupGroup(const string& name)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void PlayBeat(const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_s32 GetMeasureBoomBox()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_s32 GetBeatBoomBox()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_s32 GetHalfBeatBoomBox()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "bool IsActiveBoomBox()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void StopBoomBox(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void PlayBoomBox(chr::Handle handle, const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_s32 GetMeasureCtrlBGM()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_s32 GetBeatCtrlBGM()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_s32 GetHalfBeatCtrlBGM()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SilentHariko(float rate, float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_f32 GetVolumeHariko()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetVolumeHariko(float vol, float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "bool IsActiveHariko()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void ResumePauseHariko(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void PauseHariko(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void ResumeMuteHariko(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void MuteHariko(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void StopHariko(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void PlayHariko(const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void StartHariko()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void WaitPreparedHariko()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "bool IsPreparedHariko()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void PrepareHariko(const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_f32 GetVolumeTimer()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetVolumeTimer(float vol, float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "bool IsActiveTimer()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void StopTimer(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void PlayTimer(const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "string GetCurrentBGM()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_f32 GetPlayTime(as_s32 ch)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_f32 GetPlayTime()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void Silent(as_s32 ch, as_f32 rate, as_f32 fade)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void Silent(float rate, float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetLPF(as_s32 ch, as_f32 lpf, as_f32 fade)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetLPF(float lpf, float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_f32 GetPitch(as_s32 ch)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetPitch(as_s32 ch, as_f32 pitch, as_f32 fade)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_f32 GetPitch()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetPitch(float pitch, float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetSurroundPan(as_s32 ch, as_f32 pan, as_f32 fade)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetSurroundPan(float pan, float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetPan(as_s32 ch, as_f32 pan, as_f32 fade)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetPan(float pan, float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetVolumeEx(as_s32 ch, as_f32 vol, as_f32 fade)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetVolumeEx(float vol, float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_f32 GetVolume(as_s32 ch)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetVolume(as_s32 ch, as_f32 vol, as_f32 fade)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "as_f32 GetVolume()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void SetVolume(float vol, float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "bool IsActive(as_s32 ch)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "bool IsActive()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void _ResumeMute(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void _Mute(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void ResumePause2(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void Pause2(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void ResumePause(as_s32 ch, as_f32 fade)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void ResumePause(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void Pause(as_s32 ch, as_f32 fade)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void Pause(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void Stop(as_s32 ch, as_f32 fade)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void Stop(float fade=0.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void PlaySync(const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void PlayAdd(int ch, const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f, int skip_time=0)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void Play(array<string>& list, float fade=0.0f, float dly=0.0f, float vol=1.0f, int skip_time=0)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void PlayOrResume(const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f, int skip_time=0)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void Play(const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f, int skip_time=0)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void Start()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void WaitPrepared()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "bool IsPrepared()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void Prepare(array<string>& list, float fade=0.0f, float dly=0.0f, float vol=1.0f, int skip_time=0)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void Prepare(const string& flag_name, float fade=0.0f, float dly=0.0f, float vol=1.0f, int skip_time=0)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void WaitDoneChangeCtrlBGM()"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void ChangeCtrlBGM(int no, bool noBridge=false)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void PlayCtrlBGM(const string& bgm_id, int no=0, int skip_time=0)"
    },
    {
      "namespace": "snd::bgm",
      "declaration": "void CleanStack()"
    },
    {
      "namespace": "snd",
      "declaration": "void DisableSilhouette()"
    },
    {
      "namespace": "snd",
      "declaration": "void EnableSilhouette()"
    },
    {
      "namespace": "snd",
      "declaration": "void DisableHiding()"
    },
    {
      "namespace": "snd",
      "declaration": "void EnableHiding()"
    },
    {
      "namespace": "snd",
      "declaration": "void ResumeMenuOut(float fade)"
    },
    {
      "namespace": "snd",
      "declaration": "void PauseMenuIn(float fade, float bgm_vol)"
    },
    {
      "namespace": "snd",
      "declaration": "void DoneSkip()"
    },
    {
      "namespace": "snd",
      "declaration": "void ResumeSkipPoint()"
    },
    {
      "namespace": "snd",
      "declaration": "void PauseSkipPoint()"
    },
    {
      "namespace": "snd",
      "declaration": "void StartSkipPoint()"
    },
    {
      "namespace": "snd",
      "declaration": "void DisablePitchCtrlFF()"
    },
    {
      "namespace": "snd",
      "declaration": "void EnablePitchCtrlFF()"
    },
    {
      "namespace": "snd",
      "declaration": "void DisablePitchCtrlSE()"
    },
    {
      "namespace": "snd",
      "declaration": "void EnablePitchCtrlSE()"
    },
    {
      "namespace": "snd",
      "declaration": "void DisablePitchCtrlBGM()"
    },
    {
      "namespace": "snd",
      "declaration": "void EnablePitchCtrlBGM()"
    },
    {
      "namespace": "snd",
      "declaration": "void EnableCutSceneChangeVolCtrl()"
    },
    {
      "namespace": "snd",
      "declaration": "void DisableCutSceneChangeVolCtrl()"
    },
    {
      "namespace": "snd",
      "declaration": "void EnableSceneChangeVolCtrl()"
    },
    {
      "namespace": "snd",
      "declaration": "void DisableSceneChangeVolCtrl()"
    },
    {
      "namespace": "snd",
      "declaration": "void LoadData(const string& name)"
    },
    {
      "namespace": "snd",
      "declaration": "void SetScene(const string& scene)"
    },
    {
      "namespace": "snd",
      "declaration": "void SilentTalkOutBattle(float fade=0.0f)"
    },
    {
      "namespace": "snd",
      "declaration": "void SilentTalkInBattle(float fade=0.0f)"
    },
    {
      "namespace": "snd",
      "declaration": "void SilentTalkOutField(float fade=0.0f)"
    },
    {
      "namespace": "snd",
      "declaration": "void SilentTalkInField(float fade=0.0f)"
    },
    {
      "namespace": "snd",
      "declaration": "bool IsReadyCache()"
    },
    {
      "namespace": "snd",
      "declaration": "void CacheUnloadBattleFull()"
    },
    {
      "namespace": "snd",
      "declaration": "void CacheLoadBattle(const string& label)"
    },
    {
      "namespace": "snd",
      "declaration": "void CacheUnloadFieldFull()"
    },
    {
      "namespace": "snd",
      "declaration": "void CacheLoadField(const string& label)"
    },
    {
      "namespace": "snd",
      "declaration": "void CacheUnloadCommonFull()"
    },
    {
      "namespace": "snd",
      "declaration": "void CacheLoadCommon(const string& label)"
    },
    {
      "namespace": "snd",
      "declaration": "void GetListenerPos(VoiceHandle& handle, math::Vec3& pos)"
    },
    {
      "namespace": "snd",
      "declaration": "void EnableCheckStopBGM()"
    },
    {
      "namespace": "snd",
      "declaration": "void DisableCheckStopBGM()"
    },
    {
      "namespace": "snd",
      "declaration": "void ExitField(float fade=0.0f)"
    },
    {
      "namespace": "snd",
      "declaration": "SlotHandle GetSlotHandle(const string& name)"
    },
    {
      "namespace": "snd",
      "declaration": "VoiceHandle GetVoiceHandle(const string& name)"
    },
    {
      "namespace": "snd",
      "declaration": "bool IsExistLabel(const string& name)"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "bool IsForceValid()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "void DisableForceValid()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "void EnableForceValid()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "bool IsInfinite()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "void DisableInfinite()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "void EnableInfinite()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "bool IsBatteryEmpty()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "bool IsBatteryLow()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "bool IsBatteryFull()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "void SetLimitMsec(as_f32 msec)"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "as_f32 GetLimitMsec()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "void ClearActiveMsec()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "void SetActiveMsec(as_f32 msec)"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "as_f32 GetActiveMsec()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "bool IsMasterEfficacyPause()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "bool IsMasterPause()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "bool IsPause()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "bool IsEnable()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "void ResumePause()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "void Pause()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "void Disable()"
    },
    {
      "namespace": "player::secret_block_radar",
      "declaration": "void Enable()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "bool IsEnableEvtCanTUseHideCloak()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void DisableEvtCanTUseHideCloak()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void EnableEvtCanTUseHideCloak()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void StopEffect(float msec)"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void StartEffect(float msec)"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "bool IsForceValid()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void DisableForceValid()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void EnableForceValid()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "bool IsInfinite()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void DisableInfinite()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void EnableInfinite()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "bool IsBatteryEmpty()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "bool IsBatteryLow()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "bool IsBatteryFull()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void SetLimitMsec(as_f32 msec)"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "as_f32 GetLimitMsec()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void ClearActiveMsec()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void SetActiveMsec(as_f32 msec)"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "as_f32 GetActiveMsec()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "bool IsMasterEfficacyPause()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "bool IsMasterPause()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "bool IsPause()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "bool IsEnable()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void ResumePause()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void Pause()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void Disable()"
    },
    {
      "namespace": "player::hide_cloak",
      "declaration": "void Enable()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "bool IsForceValid()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "void DisableForceValid()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "void EnableForceValid()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "bool IsInfinite()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "void DisableInfinite()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "void EnableInfinite()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "bool IsBatteryEmpty()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "bool IsBatteryLow()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "bool IsBatteryFull()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "void SetLimitMsec(as_f32 msec)"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "as_f32 GetLimitMsec()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "void ClearActiveMsec()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "void SetActiveMsec(as_f32 msec)"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "as_f32 GetActiveMsec()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "bool IsMasterEfficacyPause()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "bool IsMasterPause()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "bool IsPause()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "bool IsEnable()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "void ResumePause()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "void Pause()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "void Disable()"
    },
    {
      "namespace": "player::knp_radar",
      "declaration": "void Enable()"
    },
    {
      "namespace": "player",
      "declaration": "bool IsTimerStop()"
    },
    {
      "namespace": "player",
      "declaration": "void ForceStopTimer()"
    },
    {
      "namespace": "player",
      "declaration": "bool IsCancelCallNavi(const ::string& stop_name=\"\", bool return_status_flg = true)"
    },
    {
      "namespace": "player",
      "declaration": "bool IsEnableCallNavi(void)"
    },
    {
      "namespace": "player",
      "declaration": "void SetCheckToHitMapSide(bool enable)"
    },
    {
      "namespace": "player",
      "declaration": "void UnsetHariboteMode()"
    },
    {
      "namespace": "player",
      "declaration": "void SetHariboteMode(chr::Handle haribote, string hariboteStayAnim, string hariboteWalkAnim, string hariboteJumpAnim, chr::Handle party, string partyStayAnim, string partyWalkAnim, string partyJumpAnim)"
    },
    {
      "namespace": "player",
      "declaration": "void SetHariboteMode(chr::Handle haribote, string hariboteStayAnim, string hariboteWalkAnim, string hariboteJumpAnim)"
    },
    {
      "namespace": "player",
      "declaration": "void DisableFallCollisionCheck()"
    },
    {
      "namespace": "player",
      "declaration": "void EnableFallCollisionCheck()"
    },
    {
      "namespace": "player",
      "declaration": "void ResetBoatState()"
    },
    {
      "namespace": "player",
      "declaration": "void setBoatDefaultAnime(string anime, bool change_soon = false)"
    },
    {
      "namespace": "player",
      "declaration": "bool checkBoatEnableHammer()"
    },
    {
      "namespace": "player",
      "declaration": "bool checkBoatLanding()"
    },
    {
      "namespace": "player",
      "declaration": "void SetBoatMode(chr::Handle boat)"
    },
    {
      "namespace": "player",
      "declaration": "void ResetShipRotAcc()"
    },
    {
      "namespace": "player",
      "declaration": "void ResetShipAcc()"
    },
    {
      "namespace": "player",
      "declaration": "void SetShipRotY(f32 rotY)"
    },
    {
      "namespace": "player",
      "declaration": "f32 GetShipSpeedMax()"
    },
    {
      "namespace": "player",
      "declaration": "f32 GetShipSpeed()"
    },
    {
      "namespace": "player",
      "declaration": "math::Mtx43 GetShipMatrix()"
    },
    {
      "namespace": "player",
      "declaration": "bool IsShipPowerup()"
    },
    {
      "namespace": "player",
      "declaration": "void SetShipPowerup(bool powerup)"
    },
    {
      "namespace": "player",
      "declaration": "void EnableShipCalc()"
    },
    {
      "namespace": "player",
      "declaration": "void DisableShipCalc()"
    },
    {
      "namespace": "player",
      "declaration": "void DisableShipResetAcc()"
    },
    {
      "namespace": "player",
      "declaration": "bool IsShipMode()"
    },
    {
      "namespace": "player",
      "declaration": "void SetShipMode()"
    },
    {
      "namespace": "player",
      "declaration": "void SetPampassGrassMode(bool enable)"
    },
    {
      "namespace": "player",
      "declaration": "f32 GetFallPower()"
    },
    {
      "namespace": "player",
      "declaration": "bool CheckRun()"
    },
    {
      "namespace": "player",
      "declaration": "bool CheckWalked()"
    },
    {
      "namespace": "player",
      "declaration": "void SetEscapeMapKeyDelay(int delay)"
    },
    {
      "namespace": "player",
      "declaration": "void SetStickLimit(f32 dir)"
    },
    {
      "namespace": "player",
      "declaration": "s32 CheckStickState()"
    },
    {
      "namespace": "player",
      "declaration": "void VehicleUnfixDir(bool resetDir = false)"
    },
    {
      "namespace": "player",
      "declaration": "void VehicleFixDir()"
    },
    {
      "namespace": "player",
      "declaration": "void VehicleChrSetOffsetY(chr::Handle chr, float height)"
    },
    {
      "namespace": "player",
      "declaration": "float VehicleChrGetOffsetY(chr::Handle chr)"
    },
    {
      "namespace": "player",
      "declaration": "void VehicleRemoveChr(chr::Handle chr)"
    },
    {
      "namespace": "player",
      "declaration": "void VehicleAddChr(chr::Handle chr)"
    },
    {
      "namespace": "player",
      "declaration": "math::Vec3 GetVehicleLctRot_IgnoreYAxis(const ::string& lct_name)"
    },
    {
      "namespace": "player",
      "declaration": "math::Vec3 GetVehicleLctRot(const ::string& my_lct, bool ignore_Yaxis = false)"
    },
    {
      "namespace": "player",
      "declaration": "math::Vec3 GetVehicleLctPos(const ::string& lct_name)"
    },
    {
      "namespace": "player",
      "declaration": "void SetVehicleRallyMode(bool enableRallymode, bool enableBoost)"
    },
    {
      "namespace": "player",
      "declaration": "void VehicleBreakSE()"
    },
    {
      "namespace": "player",
      "declaration": "void VehicleBreakAction()"
    },
    {
      "namespace": "player",
      "declaration": "void VehicleGetOut_KeepFlag()"
    },
    {
      "namespace": "player",
      "declaration": "void VehicleGetOut()"
    },
    {
      "namespace": "player",
      "declaration": "void VehicleRide()"
    },
    {
      "namespace": "player",
      "declaration": "bool IsDashAttack(void)"
    },
    {
      "namespace": "player",
      "declaration": "bool IsVehicleAccel(void)"
    },
    {
      "namespace": "player",
      "declaration": "bool IsInVehicle(void)"
    },
    {
      "namespace": "player",
      "declaration": "math::Vec3 GetCollisionFootHitPos(void)"
    },
    {
      "namespace": "player",
      "declaration": "bool IsCollisionFootHit(void)"
    },
    {
      "namespace": "player",
      "declaration": "f32 GetRunSpeed(void)"
    },
    {
      "namespace": "player",
      "declaration": "f32 GetWalkSpeed(void)"
    },
    {
      "namespace": "player",
      "declaration": "void EventOff(u32 flg)"
    },
    {
      "namespace": "player",
      "declaration": "void EventOn(u32 flg)"
    },
    {
      "namespace": "player",
      "declaration": "bool EventFlgCheck(u32 flg)"
    },
    {
      "namespace": "player",
      "declaration": "math::Vec3 GetAveragePos()"
    },
    {
      "namespace": "player",
      "declaration": "void ExitDamageEvent()"
    },
    {
      "namespace": "player",
      "declaration": "void WaitDamageEvent(void)"
    },
    {
      "namespace": "player",
      "declaration": "bool IsDamageEvent(void)"
    },
    {
      "namespace": "player",
      "declaration": "void DamageOnlyHP (int damage, bool hpLimit1=false)"
    },
    {
      "namespace": "player",
      "declaration": "void DamageAndRecover2D(int damage, int type, math::Vec3 recover_pos, f32 recover_height, f32 influence=1.0f, bool direct=false, bool hpLimit1=false)"
    },
    {
      "namespace": "player",
      "declaration": "void DamageAndRecover(int damage, int type, math::Vec3 recover_pos, f32 recover_height=-1.0f, f32 influence=1.0f, bool direct=false, bool hpLimit1=false)"
    },
    {
      "namespace": "player",
      "declaration": "math::Vec3 GetGroundPos(const math::Vec3& start, const math::Vec3& end)"
    },
    {
      "namespace": "player",
      "declaration": "math::Vec3 GetRecoverPos()"
    },
    {
      "namespace": "player",
      "declaration": "void DamageKnockBack(int damage, int type, int frame, f32 knock_back_dir, f32 influence=1.0f, bool direct=false, bool hpLimit1=false)"
    },
    {
      "namespace": "player",
      "declaration": "void Damage(int damage, int type, int frame, f32 influence=1.0f, chr::Handle obj = chr::Handle(), string& func=\"player_damage_event\", bool direct=false, bool hpLimit1=false)"
    },
    {
      "namespace": "player",
      "declaration": "chr::Handle GetDamageChr()"
    },
    {
      "namespace": "player",
      "declaration": "int GetDamageType()"
    },
    {
      "namespace": "player",
      "declaration": "void SetLastBattle(bool enable)"
    },
    {
      "namespace": "player",
      "declaration": "bool IsLastBattle()"
    },
    {
      "namespace": "player",
      "declaration": "bool ActionFlgCheck(int flag)"
    },
    {
      "namespace": "player",
      "declaration": "void EndBlink()"
    },
    {
      "namespace": "player",
      "declaration": "void StartBlink(int count)"
    },
    {
      "namespace": "player",
      "declaration": "bool IsStar()"
    },
    {
      "namespace": "player",
      "declaration": "void StarCancel()"
    },
    {
      "namespace": "player",
      "declaration": "void StarRequest()"
    },
    {
      "namespace": "player",
      "declaration": "void EnableFollowItem()"
    },
    {
      "namespace": "player",
      "declaration": "void DisableFollowItem()"
    },
    {
      "namespace": "player",
      "declaration": "void DisableForceCallNavi()"
    },
    {
      "namespace": "player",
      "declaration": "void EnableForceCallNavi()"
    },
    {
      "namespace": "player",
      "declaration": "void DisableSysAnime(bool disable)"
    },
    {
      "namespace": "player",
      "declaration": "void DisableCallParty(bool disable)"
    },
    {
      "namespace": "player",
      "declaration": "void EnableShortcutStopSE(bool enabled)"
    },
    {
      "namespace": "player",
      "declaration": "void EnableMenuStopSE(bool enabled)"
    },
    {
      "namespace": "player",
      "declaration": "void ForceEnableHelp(bool enabled)"
    },
    {
      "namespace": "player",
      "declaration": "void DisableMenu(bool disable, bool with_shortcut = true, bool release_timer_equip = true)"
    },
    {
      "namespace": "player",
      "declaration": "void DisableVehicleGetOut(bool disable)"
    },
    {
      "namespace": "player",
      "declaration": "void DisableConfetti(bool disable)"
    },
    {
      "namespace": "player",
      "declaration": "void DisableHammer(bool disable)"
    },
    {
      "namespace": "player",
      "declaration": "void DisableWalk(bool disable)"
    },
    {
      "namespace": "player",
      "declaration": "void DisableAccess(bool disable)"
    },
    {
      "namespace": "player",
      "declaration": "void DisableJump(bool disable)"
    },
    {
      "namespace": "player",
      "declaration": "void UnlockConfettiDir(void)"
    },
    {
      "namespace": "player",
      "declaration": "void LockConfettiDir(f32 dir)"
    },
    {
      "namespace": "player",
      "declaration": "void UnlockHammerDir(void)"
    },
    {
      "namespace": "player",
      "declaration": "void LockHammerDir(f32 dir)"
    },
    {
      "namespace": "player",
      "declaration": "void DisableMoveStickY(bool disable)"
    },
    {
      "namespace": "player",
      "declaration": "void DisableMoveStickX(bool disable)"
    },
    {
      "namespace": "player",
      "declaration": "void HammerKeep(bool is_keep)"
    },
    {
      "namespace": "player",
      "declaration": "void Hammer(void)"
    },
    {
      "namespace": "player",
      "declaration": "void Jump(void)"
    },
    {
      "namespace": "player",
      "declaration": "void SetStopStete(void)"
    },
    {
      "namespace": "player",
      "declaration": "void ChangeJumpParamOnce(const string& jump_name)"
    },
    {
      "namespace": "player",
      "declaration": "void Fall(const string& fall_anime, const string& land_anime, f32 ground_y=-1000.0f, bool move_xz=false)"
    },
    {
      "namespace": "player",
      "declaration": "void ResetHammerEffectScale()"
    },
    {
      "namespace": "player",
      "declaration": "void SetHammerEffectScale(float scale)"
    },
    {
      "namespace": "player",
      "declaration": "void DisableHammerEffect()"
    },
    {
      "namespace": "player",
      "declaration": "void EnableHammerEffect()"
    },
    {
      "namespace": "player",
      "declaration": "void DisableHammerSE()"
    },
    {
      "namespace": "player",
      "declaration": "void EnableHammerSE()"
    },
    {
      "namespace": "player",
      "declaration": "bool IsGround()"
    },
    {
      "namespace": "player",
      "declaration": "void SetStealth(bool stealth)"
    },
    {
      "namespace": "player",
      "declaration": "void EnableKeepStar()"
    },
    {
      "namespace": "player",
      "declaration": "void EnableSilhouette()"
    },
    {
      "namespace": "player",
      "declaration": "void GameOver()"
    },
    {
      "namespace": "player",
      "declaration": "void SetGameOverFunc(const as::string& func_name)"
    },
    {
      "namespace": "player",
      "declaration": "void EnableGameOver()"
    },
    {
      "namespace": "player",
      "declaration": "void DisableGameOver()"
    },
    {
      "namespace": "player",
      "declaration": "f32 GetSleepMsec()"
    },
    {
      "namespace": "player",
      "declaration": "bool CheckFreeSpace()"
    },
    {
      "namespace": "player",
      "declaration": "bool IsPinch()"
    },
    {
      "namespace": "player",
      "declaration": "bool IsEnableReaction()"
    },
    {
      "namespace": "player",
      "declaration": "void AutoRestart (const ::string& stop_name=\"\", as::ContextHandle handle=as::ContextHandle())"
    },
    {
      "namespace": "player",
      "declaration": "void Restart(const ::string& stop_name=\"\", bool return_status_flg = true)"
    },
    {
      "namespace": "player",
      "declaration": "bool IsRestart(const ::string& stop_name)"
    },
    {
      "namespace": "player",
      "declaration": "bool IsStopRequest()"
    },
    {
      "namespace": "player",
      "declaration": "bool IsStop()"
    },
    {
      "namespace": "player",
      "declaration": "void ReserveStop(const string& stop_name, int pri, bool no_ctrl, bool no_touch)"
    },
    {
      "namespace": "player",
      "declaration": "bool WeakStopWaitKeepUI(const ::string& stop_name=\"\", bool wait_ground=true, bool no_move=true, int pri=player::StopPriority_Damage, bool wait_state=true, bool no_hit=true, bool auto_fall=true)"
    },
    {
      "namespace": "player",
      "declaration": "void StopWaitKeepUI(const ::string& stop_name=\"\", bool wait_ground=true, bool no_move=true, int pri=player::StopPriority_Event, bool wait_state=true, bool no_hit=true, bool auto_fall=true)"
    },
    {
      "namespace": "player",
      "declaration": "void StopKeepUI(const ::string& stop_name=\"\", bool wait_ground=true, bool no_move=true, int pri=player::StopPriority_Event, bool wait_state=true, bool no_hit=true, bool auto_fall=true)"
    },
    {
      "namespace": "player",
      "declaration": "bool WeakStopWait(const ::string& stop_name=\"\", bool wait_ground=true, bool no_move=true, int pri=player::StopPriority_Damage, bool wait_state=true, bool no_hit=true, bool auto_fall=true)"
    },
    {
      "namespace": "player",
      "declaration": "void StopWait(const ::string& stop_name=\"\", bool wait_ground=true, bool no_move=true, int pri=player::StopPriority_Event, bool wait_state=true, bool no_hit=true, bool auto_fall=true)"
    },
    {
      "namespace": "player",
      "declaration": "void Stop(const ::string& stop_name=\"\", bool wait_ground=true, bool no_move=true, int pri=player::StopPriority_Event, bool wait_state=true, bool no_hit=true, bool auto_fall=true)"
    },
    {
      "namespace": "btl",
      "declaration": "bool IsAttackNPC()"
    },
    {
      "namespace": "btl",
      "declaration": "string GetBattleLastItemName()"
    },
    {
      "namespace": "btl",
      "declaration": "string GetBattleLastItemID()"
    },
    {
      "namespace": "btl",
      "declaration": "void Drop(npc::Handle leader_handle, npc::Handle drop_handle=npc::Handle(), int rate=100)"
    },
    {
      "namespace": "btl",
      "declaration": "int GetBattleResultLab()"
    },
    {
      "namespace": "btl",
      "declaration": "void SetBattleResult(int result)"
    },
    {
      "namespace": "btl",
      "declaration": "int GetBattleResult()"
    },
    {
      "namespace": "btl",
      "declaration": "void WaitEndBattle()"
    },
    {
      "namespace": "btl",
      "declaration": "void CallBattle(npc::Handle handle, int startType = 0, int startOption = 0)"
    },
    {
      "namespace": "btl",
      "declaration": "void DisableBattleEndFadeIn(void)"
    },
    {
      "namespace": "btl",
      "declaration": "void DisableBattleEndFadeOut(void)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetPeraLUT(Handle handle, const string& set_lut)"
    },
    {
      "namespace": "npc",
      "declaration": "string GetEncountPattern(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetFearHarikoList(Handle handle, const array<string>& hariko_list)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetFearNpcList(Handle handle, const array<string>& npc_list)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsWaveEncount()"
    },
    {
      "namespace": "npc",
      "declaration": "void DropPaper(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetBattleSetID(Handle handle, const string& battle_set_id)"
    },
    {
      "namespace": "npc",
      "declaration": "string GetBattleSetID(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsEnterBattleLeader(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetTalkableIconOffset(Handle handle, math::Vec3 offset)"
    },
    {
      "namespace": "npc",
      "declaration": "void ReturnTraceWalk(Handle handle, bool in_prowl_end = true)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetTraceProwlEnd(Handle handle, bool in_prowl_end)"
    },
    {
      "namespace": "npc",
      "declaration": "void EndTraceRecord(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void StartTraceRecord(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsOutsideTrace(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsOutsideProwl(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetProwlOrder(Handle handle, int index)"
    },
    {
      "namespace": "npc",
      "declaration": "math::Vec3 GetProwlPos(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void AutoProwl(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "math::Vec3 GetProwlPoint(Handle handle, int idx)"
    },
    {
      "namespace": "npc",
      "declaration": "int GetProwlPointCount(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "int GetProwlOrder(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "f32 GetProwlIntervalWithRandom(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "f32 GetProwlInterval(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetProwlInterval(Handle handle, f32 interval)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsNoProwl(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void EntryDefeatedEffect(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetDamageAnim(Handle handle, string damage_anim)"
    },
    {
      "namespace": "npc",
      "declaration": "string GetDamageAnim(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void PlayEncountAnim(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void DisableEncountAnim(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void EnableEncountAnim(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetDefeat(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsDefeated(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void PeriodActionPrevAnim(Handle handle, const string& except)"
    },
    {
      "namespace": "npc",
      "declaration": "void PeriodActionPrevAnim(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void PopActionPrev(Handle handle, bool state = true, bool anime = true, bool dir = true, bool prev_clear = true)"
    },
    {
      "namespace": "npc",
      "declaration": "void PushActionFirst(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void PushActionPrev(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ClearActionPrev(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void setCheckMapLowerPosHigh(Handle handle, bool enable)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetCheckToHitMapSide(Handle handle, bool enable)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetCheckToHitMapUpper(Handle handle, bool enable)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetCheckToHitMapLower(Handle handle, bool enable)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetCheckToHitMap(Handle handle, bool enable)"
    },
    {
      "namespace": "npc",
      "declaration": "void ChangeStateEventWait(Handle handle, bool manual_mode = false)"
    },
    {
      "namespace": "npc",
      "declaration": "void ChangeStateLost(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ChangeStateExit(Handle handle, int reason=ExitReason_Battle)"
    },
    {
      "namespace": "npc",
      "declaration": "int GetExitReason(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsPausedMain(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsRunningMain(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsPausedAction(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsRunningAction(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void EndEvent(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void BeginEvent (Handle handle, int event_state_type=EventStateType_Pause)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsCanceledFind(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsStatusFind(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void AutoFind(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ForceFind(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ResetRotNecessary(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "Handle GetParent(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ExitChild(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void Delete(Handle handle, bool direct=false)"
    },
    {
      "namespace": "npc",
      "declaration": "void WaitIsReady(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsAdditionalEntry(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "Handle EntryChild(const string& id, const string& name, Handle parent)"
    },
    {
      "namespace": "npc",
      "declaration": "Handle EntryGenerate(DisposData& dispos, const math::Vec3& force_pos, f32 force_dir)"
    },
    {
      "namespace": "npc",
      "declaration": "Handle EntryGenerate(DisposData& dispos, const math::Vec3& force_pos)"
    },
    {
      "namespace": "npc",
      "declaration": "Handle EntryGenerate(DisposData& dispos)"
    },
    {
      "namespace": "npc",
      "declaration": "Handle Entry(string& dispos_id, bool force_invisible, const math::Vec3& force_pos, f32 force_dir)"
    },
    {
      "namespace": "npc",
      "declaration": "Handle Entry(string& dispos_id, bool force_invisible, const math::Vec3& force_pos)"
    },
    {
      "namespace": "npc",
      "declaration": "Handle Entry(string& dispos_id, bool force_invisible)"
    },
    {
      "namespace": "npc",
      "declaration": "string GetFieldExitItemSet(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void EnableFreeFall(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void DisableFreeFall(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetRangeActionFunc(Handle handle, string enter_func, string leave_func)"
    },
    {
      "namespace": "npc",
      "declaration": "void DisableRangeAction(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void EnableRangeAction(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void EnableTalk(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void DisableTalk(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ResetTraceParam(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ResetProwlParam(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ResetViewParam(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetTraceParam(Handle handle, math::Vec3 center, math::Vec3 size, f32 rot = 0.0f)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetProwlParam(Handle handle, math::Vec3 center, math::Vec3 size, f32 rot = 0.0f)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetViewParam(Handle handle, f32 angle, f32 dist)"
    },
    {
      "namespace": "npc",
      "declaration": "string GetTraceActionType(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "string GetProwlActionType(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void GetTraceParam(Handle handle, math::Vec3& center, math::Vec3& size, f32& rot)"
    },
    {
      "namespace": "npc",
      "declaration": "void GetProwlParam(Handle handle, math::Vec3& center, math::Vec3& size, f32& rot)"
    },
    {
      "namespace": "npc",
      "declaration": "void GetViewParam(Handle handle, f32& angle, f32& dist)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsViewLine(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool CheckOutsideTrace(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetOriginalDir(Handle handle, f32 dir)"
    },
    {
      "namespace": "npc",
      "declaration": "f32 GetOriginalDir(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetOriginalPos(Handle handle, const math::Vec3& pos)"
    },
    {
      "namespace": "npc",
      "declaration": "void GetOriginalPosXZ(Handle handle, f32& x, f32& z)"
    },
    {
      "namespace": "npc",
      "declaration": "void GetOriginalPos(Handle handle, f32& x, f32& y, f32& z)"
    },
    {
      "namespace": "npc",
      "declaration": "void GetOriginalPos(Handle handle, math::Vec3& pos)"
    },
    {
      "namespace": "npc",
      "declaration": "const math::Vec3& GetOriginalPos(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "f32 GetPreEntryDir(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "const math::Vec3& GetPreEntryPos(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetPreEntry(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ClearPreEntry(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ForceRunPreEntry(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsPreEntry(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void RotToDispos(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ResetChaseSpeed(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetChaseSpeed(Handle handle, f32 speed)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetMoveSpeedToChase(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetMoveSpeedToWalk(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetChaseMoveSpeed(Handle handle, f32 speed)"
    },
    {
      "namespace": "npc",
      "declaration": "f32 GetChaseMoveSpeed(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetWalkMoveSpeed(Handle handle, f32 speed)"
    },
    {
      "namespace": "npc",
      "declaration": "f32 GetWalkMoveSpeed(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsFoundReturn(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ForceReturn(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void DisableReturn(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void EnableReturn(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetNoAttentionTalking(Handle handle, bool no_attention)"
    },
    {
      "namespace": "npc",
      "declaration": "void UnfixDirOnTalk(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetAnimeOnTalk(Handle handle, const string& anime)"
    },
    {
      "namespace": "npc",
      "declaration": "void FixDirOnTalk(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "f32 GetFloorOffset(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetFloorOffset(Handle handle, f32 floor_offset)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsFloating(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void InitFloating(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void DisableFloating(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void EnableFloating(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void EnableProwl(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void DisableProwl(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetProwlType(Handle handle, int type)"
    },
    {
      "namespace": "npc",
      "declaration": "void EnableBlock(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void DisableBlcok(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void EnableAreaEncount(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void DisableAreaEncount(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void EnableVehicleHornFind(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void DisableVehicleHornFind(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void EnableFind(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void DisableFind(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetEnableCollision_BoundWeapon(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetEnableCollision_FlyWeapon(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetEnableCollision_Fly(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetSwingHammerHit(Handle handle, bool enable=true)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetHammerHitOffsetPos(Handle handle, math::Vec3 v)"
    },
    {
      "namespace": "npc",
      "declaration": "math::Vec3 GetHammerHitOffsetPos(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetHammerHitSize(Handle handle, math::Vec3 v)"
    },
    {
      "namespace": "npc",
      "declaration": "math::Vec3 GetHammerHitSize(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SeparateHammerHit(Handle handle, bool enable=true)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetStumpSE(Handle handle, string stump_se)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsAlive(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetDeleteOnDefeat(Handle handle, bool is_delete)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetDeleteOnEscaped(Handle handle, bool is_delete)"
    },
    {
      "namespace": "npc",
      "declaration": "void UndeadOff(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void Undead(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsFirstAttack(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool IsEnemy(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "int GetAttackPower(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "bool CheckActionFlag(Handle handle, int flg)"
    },
    {
      "namespace": "npc",
      "declaration": "void SetActionFlag(Handle handle, bool set, int flg)"
    },
    {
      "namespace": "npc",
      "declaration": "void UnlockState(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void LockState(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void ResetSwitch(Handle handle, int action_type)"
    },
    {
      "namespace": "npc",
      "declaration": "void ResetSwitch(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchTalk(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchExitByGimmick(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchExitByDashAttack(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchExitByFirstAttack(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchExitByStar(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchExit(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchEncount(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchEscaped(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchReturn(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchLost(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchFind(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchMain(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void SwitchAction(Handle handle, const string& func_name)"
    },
    {
      "namespace": "npc",
      "declaration": "void RunMain(Handle handle)"
    },
    {
      "namespace": "npc",
      "declaration": "as::Variable& GetPrivWork_SearchKnp(Handle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "string GetText(const string& label)"
    },
    {
      "namespace": "msg",
      "declaration": "s32 EntryPouchList()"
    },
    {
      "namespace": "msg",
      "declaration": "bool PouchSellCheck()"
    },
    {
      "namespace": "msg",
      "declaration": "bool SellShop(as_s32 pouchIndex)"
    },
    {
      "namespace": "msg",
      "declaration": "as_s32 EntryShop(const string& shopDataName)"
    },
    {
      "namespace": "msg",
      "declaration": "void SimpleSelect4Close(as_u64& work)"
    },
    {
      "namespace": "msg",
      "declaration": "void SimpleSelect4Retry(as_u64& work)"
    },
    {
      "namespace": "msg",
      "declaration": "as_s32 SimpleSelect4Check(as_u64& work)"
    },
    {
      "namespace": "msg",
      "declaration": "void SimpleSelect4Open(as_u64& work, const string& select4)"
    },
    {
      "namespace": "msg",
      "declaration": "as_s32 SimpleSelect4(const string& select4)"
    },
    {
      "namespace": "msg",
      "declaration": "void LoadMapSlot(const string& fileName)"
    },
    {
      "namespace": "msg",
      "declaration": "void PowerUpTest()"
    },
    {
      "namespace": "msg",
      "declaration": "void NotificationNews(const string& item, as_f32 lifeTimeMsec=0)"
    },
    {
      "namespace": "msg",
      "declaration": "void UseEvtSimple(const string& msg)"
    },
    {
      "namespace": "msg",
      "declaration": "void UseEvtSimple(item::Handle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void UseEvt(const string& baseMsg, const string& itemMsg, const string& se=\"SE_SYS_Decide_Normal\", float offsetPosY=0)"
    },
    {
      "namespace": "msg",
      "declaration": "void UseEvt(const string& msg)"
    },
    {
      "namespace": "msg",
      "declaration": "void UseEvt(item::Handle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void GetEvt2(const string& msg)"
    },
    {
      "namespace": "msg",
      "declaration": "void GetEvt2(item::Handle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void GetEvtFade(const string& msg, const math::Vec3 &pos)"
    },
    {
      "namespace": "msg",
      "declaration": "void GetEvt(const string& msg, const math::Vec3 &pos)"
    },
    {
      "namespace": "msg",
      "declaration": "void GetEvt(const string& msg, chr::Handle chr = chr::Handle())"
    },
    {
      "namespace": "msg",
      "declaration": "void GetEvt(const string& baseMsg, item::Handle handle, chr::Handle chr = chr::Handle())"
    },
    {
      "namespace": "msg",
      "declaration": "void GetEvt(const string& baseMsg, const string& itemID, chr::Handle chr = chr::Handle())"
    },
    {
      "namespace": "msg",
      "declaration": "void GetEvt(item::Handle handle, chr::Handle chr = chr::Handle())"
    },
    {
      "namespace": "msg",
      "declaration": "void Shake(MessageHandle handle, int count, float ampX, float ampY)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetNoSkip(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void ClearReadFlag(const string& msgLabel)"
    },
    {
      "namespace": "msg",
      "declaration": "bool GetReadFlag(const string& msgLabel)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetReadFlag(const string& msgLabel)"
    },
    {
      "namespace": "msg",
      "declaration": "string GetSelectItem(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void DisableKeyWait(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "as_s32 WaitScript(MessageHandle handle, const string& talkScript, const string& stayScript)"
    },
    {
      "namespace": "msg",
      "declaration": "as_s32 WaitMsec(MessageHandle handle, f32 wait_msec, const string& talkAnime=\"話し\", const string& stayAnime=\"静止\")"
    },
    {
      "namespace": "msg",
      "declaration": "as_s32 Wait(MessageHandle handle, const string& talkAnime=\"話し\", const string& stayAnime=\"静止\")"
    },
    {
      "namespace": "msg",
      "declaration": "as_s32 WaitNoAnime(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "bool IsFinish(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "bool IsTextEnd(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void Restart(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "bool IsOnceStop(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "bool IsValid(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void Close(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void CloseAll()"
    },
    {
      "namespace": "msg",
      "declaration": "void WaitLife(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "as_s32 GetLifeTime(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void Open(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetAutoHide(MessageHandle handle, bool flag)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetTextOnly(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void EnableHintMode(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetPage(MessageHandle handle, int page)"
    },
    {
      "namespace": "msg",
      "declaration": "int GetPageNum(const string& label)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetScrollSE(MessageHandle handle, const string& scrollSE)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetCloseSE(MessageHandle handle, const string& closeSE)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetOpenSE(MessageHandle handle, const string& openSE)"
    },
    {
      "namespace": "msg",
      "declaration": "void EnableSmallTalkAnime(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void DisableVoice(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void EnableSmallVoice(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetVoice(MessageHandle handle, const string& label=\"\")"
    },
    {
      "namespace": "msg",
      "declaration": "void SetFaceState(MessageHandle handle, const string& state)"
    },
    {
      "namespace": "msg",
      "declaration": "void EnableFaceRight(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void EnableFaceLeft(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetFollowNoClamp(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetFollowOffset(MessageHandle handle, const math::Vec3& offsetPos=math::Vec3(0, 100, 0))"
    },
    {
      "namespace": "msg",
      "declaration": "void SetFollow(MessageHandle handle, bool flag)"
    },
    {
      "namespace": "msg",
      "declaration": "void AutoToge(MessageHandle handle, bool enable)"
    },
    {
      "namespace": "msg",
      "declaration": "void HideToge(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void ShowToge(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetTogeFixRotate(MessageHandle handle, as_s32 dir, float deg)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetTogeFix(MessageHandle handle, as_s32 dir)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetTogeDir(MessageHandle handle, as_s32 dir)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetSelectFilter(MessageHandle handle, bool b0, bool b1=true, bool b2=true, bool b3=true, bool b4=true, bool b5=true, bool b6=true, bool b7=true, bool b8=true, bool b9=true, bool b10=true, bool b11=true)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetSelectFilter(MessageHandle handle, as_u32 flag)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetSelectDefaultCursor(MessageHandle handle, as_s32 cursorPos)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetSelectWaitFrame(MessageHandle handle, as_s32 frame)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetValue(MessageHandle handle, as_s32 no, const string& label)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetValue(MessageHandle handle, as_s32 no, as_s32 value)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetPosZ(MessageHandle handle, as_f32 z)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetPos(MessageHandle handle, math::Vec2& pos)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetPos(MessageHandle handle, as_f32 x, as_f32 y)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetPos(MessageHandle handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetPosAuto(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetPosIndex(MessageHandle handle, as_s32 index)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetPriority(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetTargetOffset(MessageHandle handle, const math::Vec3& offsetPos)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetTarget(MessageHandle handle, const math::Vec3& pos)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetTarget(MessageHandle handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "msg",
      "declaration": "void SetCenteringY(MessageHandle handle, bool flag)"
    },
    {
      "namespace": "msg",
      "declaration": "math::Vec3 GetPos(MessageHandle handle)"
    },
    {
      "namespace": "msg",
      "declaration": "math::Vec2 CalcWindowSize(const string& label)"
    },
    {
      "namespace": "msg",
      "declaration": "math::Vec2 CalcWindowPos(math::Vec3 pos, const string& label)"
    },
    {
      "namespace": "msg",
      "declaration": "void Add(MessageHandle handle, const string& label)"
    },
    {
      "namespace": "msg",
      "declaration": "MessageHandle Create(const string& label)"
    },
    {
      "namespace": "msg",
      "declaration": "MessageHandle Create(chr::Handle chr, const string& label)"
    },
    {
      "namespace": "msg",
      "declaration": "as_s32 PrintHideToge(chr::Handle handle, const string& label)"
    },
    {
      "namespace": "msg",
      "declaration": "as_s32 Print(chr::Handle handle, const string& label)"
    },
    {
      "namespace": "msg",
      "declaration": "as_s32 Print(const string& label)"
    },
    {
      "namespace": "mobj",
      "declaration": "bool IsNearHide(mobj::Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void Delete(Handle handle, bool direct=false)"
    },
    {
      "namespace": "mobj",
      "declaration": "void resetSwitchAction(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void SwitchAction(Handle handle, string)"
    },
    {
      "namespace": "mobj",
      "declaration": "bool CheckHole(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void SetIgnoreHoleLock(Handle handle, u32 flag, bool set)"
    },
    {
      "namespace": "mobj",
      "declaration": "void DirectReaction(Handle handle, int hit_place)"
    },
    {
      "namespace": "mobj",
      "declaration": "void PermitReaction(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void WaitReaction(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "bool CheckReaction(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void SetWorkVariable(Handle handle, int index, as::Variable& value)"
    },
    {
      "namespace": "mobj",
      "declaration": "as::Variable& GetWorkVariable(Handle handle, int index)"
    },
    {
      "namespace": "mobj",
      "declaration": "void DropConfetti(Handle handle, int num = 0)"
    },
    {
      "namespace": "mobj",
      "declaration": "void SetConfettiParam(Handle handle, int min, int max)"
    },
    {
      "namespace": "mobj",
      "declaration": "f32 GetItemSpd(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "f32 GetItemDirMax(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "f32 GetItemDirMin(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void SetItemSpd(Handle handle, f32 spd)"
    },
    {
      "namespace": "mobj",
      "declaration": "void SetItemDir(Handle handle, f32 dir, f32 range)"
    },
    {
      "namespace": "mobj",
      "declaration": "void ResetItemSetEntryCount(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void IncItemSetEntryCount(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "as::string GetItemSetID( Handle handle, int tableNo = 0 )"
    },
    {
      "namespace": "mobj",
      "declaration": "as::string GetItemLctName(Handle handle, int index = 0)"
    },
    {
      "namespace": "mobj",
      "declaration": "math::Vec3 GetItemLct(Handle handle, int index = 0)"
    },
    {
      "namespace": "mobj",
      "declaration": "int GetItemLctCount(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "bool IsDisposItemSet(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "bool IsNextSetTreasure(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "bool IsNextSetOnceItem(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "string MakeFlagName(string map_id, string mobj_name)"
    },
    {
      "namespace": "mobj",
      "declaration": "void ResetSwitch(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void SetSwitch(Handle handle, int val)"
    },
    {
      "namespace": "mobj",
      "declaration": "int CheckSwitch(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void ResetFlag(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void SetFlag(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "bool CheckFlag(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void WaitIsReady(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void WaitInitializeDispos()"
    },
    {
      "namespace": "mobj",
      "declaration": "void EntryDispos(const string& dispos)"
    },
    {
      "namespace": "mobj",
      "declaration": "bool CheckInFront(mobj::Handle mobj_handle, chr::Handle target_handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "bool CheckInRight(mobj::Handle mobj_handle, chr::Handle target_handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void LockHole(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void SetReactionPlayable(Handle handle, bool is_reaction_playable)"
    },
    {
      "namespace": "mobj",
      "declaration": "void SetOriginalPos(Handle handle, math::Vec3 vec)"
    },
    {
      "namespace": "mobj",
      "declaration": "math::Vec3 GetOriginalPos(Handle handle)"
    },
    {
      "namespace": "mobj",
      "declaration": "void SetUniqueColor(Handle handle, string color_id)"
    },
    {
      "namespace": "mobj",
      "declaration": "void SetColor(Handle handle, as_s32 color)"
    },
    {
      "namespace": "mobj",
      "declaration": "Handle Entry(const string &name, const string &id, const math::Vec3& pos=math::Vec3(0.0f, 0.0f, 0.0f), const math::Vec3& dir=math::Vec3(0.0f, 0.0f, 0.0f))"
    },
    {
      "namespace": "math",
      "declaration": "as_f32 CompareAngle(as_f32 d1, as_f32 d2)"
    },
    {
      "namespace": "math",
      "declaration": "as_f32 CalcDirDir(as_f32 d, as_f32 cam_d)"
    },
    {
      "namespace": "math",
      "declaration": "as_f32 CorrectDeg(as_f32 d)"
    },
    {
      "namespace": "math",
      "declaration": "void RotateDir(math::Vec3& pos, as_f32 dir)"
    },
    {
      "namespace": "math",
      "declaration": "void RotateDir(as_f32 &x, as_f32 &z, as_f32 dir)"
    },
    {
      "namespace": "math",
      "declaration": "void MoveDir(math::Vec3& pos, as_f32 spd, as_f32 dir)"
    },
    {
      "namespace": "math",
      "declaration": "void MoveDir(as_f32 &x, as_f32 &z, as_f32 spd, as_f32 dir)"
    },
    {
      "namespace": "math",
      "declaration": "as_f32 AngleABf(const Vec3& va, const Vec3& vb)"
    },
    {
      "namespace": "math",
      "declaration": "as_f32 AngleABf(as_f32 ax, as_f32 az, as_f32 bx, as_f32 bz)"
    },
    {
      "namespace": "math",
      "declaration": "as_f32 CalcDir(as_f32 x, as_f32 z)"
    },
    {
      "namespace": "math",
      "declaration": "void Seed()"
    },
    {
      "namespace": "math",
      "declaration": "void Seed(as_u32 seed)"
    },
    {
      "namespace": "math",
      "declaration": "as_s32 Randi(as_s32 min, as_s32 max)"
    },
    {
      "namespace": "math",
      "declaration": "as_f32 Randf(as_f32 min, as_f32 max)"
    },
    {
      "namespace": "math",
      "declaration": "as_s32 Randi(as_s32 max)"
    },
    {
      "namespace": "math",
      "declaration": "as_f32 Randf(as_f32 max)"
    },
    {
      "namespace": "math::Quat",
      "declaration": "const Quat& Zero()"
    },
    {
      "namespace": "math::Quat",
      "declaration": "Quat MakeVectorRotation(const Vec3& from, const Vec3& to)"
    },
    {
      "namespace": "math::Quat",
      "declaration": "Quat FromAxisAngle(const Vec3& axis, f32 radian)"
    },
    {
      "namespace": "math::Quat",
      "declaration": "Quat FromRotationMatrix(const Mtx43& value)"
    },
    {
      "namespace": "math::Quat",
      "declaration": "Quat FromEulerianAngle(const Vec3& rot)"
    },
    {
      "namespace": "math::Quat",
      "declaration": "Quat FromEulerianAngle(const f32 yaw, const f32 pitch, const f32 roll)"
    },
    {
      "namespace": "math::Quat",
      "declaration": "Quat FromYawPitchRoll(f32 yaw, f32 pitch, f32 roll)"
    },
    {
      "namespace": "math::Quat",
      "declaration": "Quat Squad(const Quat& a, const Quat& b, const Quat& c, const Quat& d, f32 t)"
    },
    {
      "namespace": "math::Quat",
      "declaration": "Quat Slerp(const Quat& a, const Quat& b, f32 t)"
    },
    {
      "namespace": "math::Quat",
      "declaration": "Quat Lerp(const Quat& a, const Quat& b, f32 t)"
    },
    {
      "namespace": "math::Quat",
      "declaration": "Quat Inverse(const Quat& value)"
    },
    {
      "namespace": "math::Quat",
      "declaration": "Quat Normalize(const Quat& value)"
    },
    {
      "namespace": "math::Quat",
      "declaration": "f32 Dot(const Quat& a, const Quat& b)"
    },
    {
      "namespace": "math::Mtx44",
      "declaration": "const Mtx44& Identity()"
    },
    {
      "namespace": "math::Mtx44",
      "declaration": "const Mtx44& Zero()"
    },
    {
      "namespace": "math::Mtx44",
      "declaration": "Mtx43 ToMatrix4x3f(const Mtx44& value)"
    },
    {
      "namespace": "math::Mtx44",
      "declaration": "Mtx44 OrthographicOffCenterRightHanded(f32 left, f32 right, f32 bottom, f32 top, f32 nearClip, f32 farClip)"
    },
    {
      "namespace": "math::Mtx44",
      "declaration": "Mtx44 OrthographicRightHanded(f32 width, f32 height, f32 nearClip, f32 farClip)"
    },
    {
      "namespace": "math::Mtx44",
      "declaration": "Mtx44 PerspectiveOffCenterRightHanded(f32 left, f32 right, f32 bottom, f32 top, f32 nearClip, f32 farClip)"
    },
    {
      "namespace": "math::Mtx44",
      "declaration": "Mtx44 PerspectiveFieldOfViewRightHanded(f32 fieldOfView, f32 aspectRatio, f32 nearClip, f32 farClip)"
    },
    {
      "namespace": "math::Mtx44",
      "declaration": "Mtx44 PerspectiveRightHanded(f32 width, f32 height, f32 nearClip, f32 farClip)"
    },
    {
      "namespace": "math::Mtx44",
      "declaration": "Mtx44 MakeTranspose(const Mtx44& value)"
    },
    {
      "namespace": "math::Mtx43",
      "declaration": "const Mtx43& Identity()"
    },
    {
      "namespace": "math::Mtx43",
      "declaration": "const Mtx43& Zero()"
    },
    {
      "namespace": "math::Mtx43",
      "declaration": "Mtx44 ToMatrix4x4f(const Mtx43& value)"
    },
    {
      "namespace": "math::Mtx43",
      "declaration": "Mtx43 LookToRightHanded(const Vec3& position, const Vec3& direction, const Vec3& upward)"
    },
    {
      "namespace": "math::Mtx43",
      "declaration": "Mtx43 LookAtRightHanded(const Vec3& position, const Vec3& target, const Vec3& upward)"
    },
    {
      "namespace": "math::Mtx43",
      "declaration": "Mtx43 MakeTranspose(const Mtx43& value)"
    },
    {
      "namespace": "math::Mtx43",
      "declaration": "Mtx43 MakeRotation(const Quat& value)"
    },
    {
      "namespace": "math::Mtx43",
      "declaration": "Mtx43 MakeRotation(const Vec3& radian)"
    },
    {
      "namespace": "math::Mtx43",
      "declaration": "Mtx43 MakeScale(const Vec3& value)"
    },
    {
      "namespace": "math::Mtx43",
      "declaration": "Mtx43 MakeTranslation(const Vec3& value)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInOutBounce(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseOutBounce(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInBounce(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3Bounce(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInOutBack(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0), as_f32 back_ratio = 2.0f)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseOutBack(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0), as_f32 back_ratio = 2.0f)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInBack(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0), as_f32 back_ratio = 2.0f)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3Back(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0), as_f32 back_ratio = 2.0f)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInOutCircular(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseOutCircular(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInCircular(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3Circular(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInOutExponential(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseOutExponential(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInExponential(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3Exponential(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInOutSine(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseOutSine(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInSine(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3Sine(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInOutQuintic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseOutQuintic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInQuintic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3Quintic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInOutQuartic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseOutQuartic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInQuartic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3Quartic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInOutCubic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseOutCubic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInCubic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3Cubic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInOutQuadratic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseOutQuadratic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3EaseInQuadratic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3Quadratic(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3Linear(as_f32 time, as_f32 time_s, array<math::Vec3>& arg = array<math::Vec3>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3CurveLength(array<math::bezier::Vec3EasingParam>& p_list)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3CurveLength(math::bezier::Vec3EasingParam& p)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3Curve(as_f32 time, as_f32 time_s, array<math::bezier::Vec3EasingParam>& p_list)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec3 Vec3Curve(as_f32 time, as_f32 time_s, math::bezier::Vec3EasingParam& p)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInOutBounce(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseOutBounce(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInBounce(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2Bounce(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInOutBack(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0), as_f32 back_ratio = 2.0f)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseOutBack(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0), as_f32 back_ratio = 2.0f)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInBack(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0), as_f32 back_ratio = 2.0f)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2Back(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0), as_f32 back_ratio = 2.0f)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInOutCircular(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseOutCircular(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInCircular(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2Circular(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInOutExponential(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseOutExponential(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInExponential(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2Exponential(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInOutSine(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseOutSine(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInSine(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2Sine(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInOutQuintic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseOutQuintic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInQuintic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2Quintic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInOutQuartic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseOutQuartic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInQuartic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2Quartic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInOutCubic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseOutCubic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInCubic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2Cubic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInOutQuadratic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseOutQuadratic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2EaseInQuadratic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2Quadratic(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2Linear(as_f32 time, as_f32 time_s, array<math::Vec2>& arg = array<math::Vec2>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2CurveLength(array<math::bezier::Vec2EasingParam>& p_list)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2CurveLength(math::bezier::Vec2EasingParam& p)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2Curve(as_f32 time, as_f32 time_s, array<math::bezier::Vec2EasingParam>& p_list)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "math::Vec2 Vec2Curve(as_f32 time, as_f32 time_s, math::bezier::Vec2EasingParam& p)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInOutBounce(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseOutBounce(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInBounce(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Bounce(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInOutElastic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseOutElastic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInElastic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Elastic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInOutBack(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0), as_f32 back_ratio = 2.0f)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseOutBack(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0), as_f32 back_ratio = 2.0f)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInBack(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0), as_f32 back_ratio = 2.0f)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Back(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0), as_f32 back_ratio = 2.0f)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInOutCircular(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseOutCircular(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInCircular(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Circular(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInOutExponential(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseOutExponential(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInExponential(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Exponential(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInOutSine(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseOutSine(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInSine(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Sine(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInOutQuintic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseOutQuintic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInQuintic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Quintic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInOutQuartic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseOutQuartic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInQuartic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Quartic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInOutCubic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseOutCubic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInCubic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Cubic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInOutQuadratic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseOutQuadratic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 EaseInQuadratic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Quadratic(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Linear(as_f32 time, as_f32 time_s, array<as_f32>& arg = array<as_f32>(0))"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 CurveLength(array<math::bezier::EasingParam>& p_list)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 CurveLength(math::bezier::EasingParam& p)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Curve(as_f32 time, as_f32 time_s, array<math::bezier::EasingParam>& p_list)"
    },
    {
      "namespace": "math::bezier",
      "declaration": "as_f32 Curve(as_f32 time, as_f32 time_s, math::bezier::EasingParam& p)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 EaseInOut(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 SinDecel(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 SinAccel(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 TripleSin(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 DoubleSin(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 Sin(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 Bound(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 BururunDece(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 Bururun(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 Gemini(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 TripleDecel(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 DoubleDecel(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 Decel(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 TripleAccel(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 DoubleAccel(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 Accel(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math::interp",
      "declaration": "as_f32 Linear(as_f32 time, as_f32 time_s, as_f32 pow=1.0f)"
    },
    {
      "namespace": "math",
      "declaration": "as_f32 intplGetValue(as_s32 type, as_f32 value1, as_f32 value2, as_f32 time, as_f32 time_s, as_f32 pow)"
    },
    {
      "namespace": "math",
      "declaration": "as_f32 intplGetValue(as_s32 type, as_f32 value1, as_f32 value2, as_f32 time, as_f32 time_s)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Clamp(f32 v, f32 min, f32 max)"
    },
    {
      "namespace": "math",
      "declaration": "bool AreEqual(f32 x, f32 y, f32 error)"
    },
    {
      "namespace": "math",
      "declaration": "bool AreEqualRelative(f32 x, f32 y, f32 relativeError)"
    },
    {
      "namespace": "math",
      "declaration": "bool AreEqualAbs(f32 x, f32 y, f32 absError)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Rsqrt(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Rcp(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "bool IsUnordered(f32 x, f32 y)"
    },
    {
      "namespace": "math",
      "declaration": "bool IsLessgreater(f32 x, f32 y)"
    },
    {
      "namespace": "math",
      "declaration": "bool IsLessequal(f32 x, f32 y)"
    },
    {
      "namespace": "math",
      "declaration": "bool IsLess(f32 x, f32 y)"
    },
    {
      "namespace": "math",
      "declaration": "bool IsGreaterequal(f32 x, f32 y)"
    },
    {
      "namespace": "math",
      "declaration": "bool IsGreater(f32 x, f32 y)"
    },
    {
      "namespace": "math",
      "declaration": "bool Signbit(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "bool IsNormal(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "bool IsNan(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "bool IsInf(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "bool IsFinite(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "s32 Fpclassify(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Yn(s32 i, f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Y1(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Y0(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Jn(s32 i, f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 J1(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 J0(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Fma(f32 x, f32 y, f32 z)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Dim(f32 v1, f32 v2)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Max(f32 v1, f32 v2)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Min(f32 v1, f32 v2)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Nextafter(f32 x, f32 y)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Nan(string x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Copysign(f32 x, f32 y)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Remquo(f32 x, f32 y, s32 &i)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Remainder(f32 x, f32 y)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Fmod(f32 x, f32 y)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Rint(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Nearbyint(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Round(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Trunc(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Floor(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Ceil(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Lgamma(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Tgamma(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Erfc(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Erf(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 FAbs(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Hypot(f32 x, f32 y)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Cbrt(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Sqrt(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Pow(f32 x, f32 y)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Scalbn(f32 x, s32 y)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Modf(f32 x, f32 &y)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Logb(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "s32 Ilogb(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Frexp(f32 x, s32 &y)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Ldexp(f32 x, s32 y)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Log2(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Log1p(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Log10(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Log(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Expm1(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Exp2(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Exp(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Atanh(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Acosh(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Asinh(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Tanh(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Cosh(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Sinh(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 AcosRad(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 AsinRad(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Atan2Rad(f32 y, f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 AtanRad(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 TanRad(f32& pOutSin, f32& pOutCos, f32 radian)"
    },
    {
      "namespace": "math",
      "declaration": "f32 TanRad(f32 radian)"
    },
    {
      "namespace": "math",
      "declaration": "f32 CosRad(f32 radian)"
    },
    {
      "namespace": "math",
      "declaration": "f32 SinRad(f32 radian)"
    },
    {
      "namespace": "math",
      "declaration": "f32 AcosDeg(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 AsinDeg(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 Atan2Deg(f32 y, f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 AtanDeg(f32 x)"
    },
    {
      "namespace": "math",
      "declaration": "f32 TanDeg(f32& pOutSin, f32& pOutCos, f32 degree)"
    },
    {
      "namespace": "math",
      "declaration": "f32 TanDeg(f32 degree)"
    },
    {
      "namespace": "math",
      "declaration": "f32 CosDeg(f32 degree)"
    },
    {
      "namespace": "math",
      "declaration": "f32 SinDeg(f32 degree)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsExistDropItem()"
    },
    {
      "namespace": "item",
      "declaration": "string GetId(s32 itemIndex)"
    },
    {
      "namespace": "item",
      "declaration": "string GetLabelName(s32 itemIndex)"
    },
    {
      "namespace": "item",
      "declaration": "string GetLabelName(const string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "int GetPrice(s32 itemIndex)"
    },
    {
      "namespace": "item",
      "declaration": "int GetPrice(const string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "void SetItemMax(s32 drop_item_num, s32 dispos_item_num)"
    },
    {
      "namespace": "item",
      "declaration": "void DisableCommonEvent(bool disable)"
    },
    {
      "namespace": "item",
      "declaration": "void EnableDropItem()"
    },
    {
      "namespace": "item",
      "declaration": "void DisableDropItem()"
    },
    {
      "namespace": "item",
      "declaration": "void DeleteAllDropItem()"
    },
    {
      "namespace": "item",
      "declaration": "void SetVanishCountFlag(bool flag)"
    },
    {
      "namespace": "item",
      "declaration": "void SetGettableEffect(Handle handle, const string& label)"
    },
    {
      "namespace": "item",
      "declaration": "void SetStayEffect(Handle handle, const string& label)"
    },
    {
      "namespace": "item",
      "declaration": "void SetBoundSE(Handle handle, const string& label)"
    },
    {
      "namespace": "item",
      "declaration": "void SetItemGetFunc(Handle handle, const string& func_name)"
    },
    {
      "namespace": "item",
      "declaration": "void SetItemGetEvent(Handle handle, const string& func_name)"
    },
    {
      "namespace": "item",
      "declaration": "string GetItemGetEvent(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "::string GetLabel(const ::string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "::string GetContentsLabel(const ::string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "void ResetFlagAll(const string& )"
    },
    {
      "namespace": "item",
      "declaration": "void SetItemGetFlag(Handle handle, bool set)"
    },
    {
      "namespace": "item",
      "declaration": "void SetItemFlgs(Handle handle, u32 flgs, bool set)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsWait(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "void WaitEvent(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "bool GetFieldItem(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "void SetNoGetCounter(Handle handle, int count=-1)"
    },
    {
      "namespace": "item",
      "declaration": "void GotoEscapeState(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "void GotoFallState(Handle handle, bool rand = false)"
    },
    {
      "namespace": "item",
      "declaration": "void GotoWaitState(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "void GotoEntryState(Handle handle, f32 dir, f32 speed)"
    },
    {
      "namespace": "item",
      "declaration": "void SetUseEvent(const ::string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "void SetUseEvent(const ::string& item_id, const ::string& func_name)"
    },
    {
      "namespace": "item",
      "declaration": "void Collected(const string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsCollected(const string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "void UsePouchItem(Handle handle, const ::string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsStatCollectable(const string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsStatCollectable(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsStatBattle(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsStatField(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsStatUseMenu(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsStatMenu(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsStatKeyItem(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "bool EquipmentAmulet(const string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsEquipmentAmulet(const string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "bool RemoveAmulet(const string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "void DeleteKeyItem(const string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "bool RemovePouch(const string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "bool TryAddPouch(const string& id, bool get_quick = false)"
    },
    {
      "namespace": "item",
      "declaration": "bool TryAddPouch(Handle handle, bool get_quick = false)"
    },
    {
      "namespace": "item",
      "declaration": "bool CheckPouch(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "bool CheckPouch(const string& item_id)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsItemSetTreasure(const ::string& set)"
    },
    {
      "namespace": "item",
      "declaration": "bool IsItemSetOnceItem(const ::string& set)"
    },
    {
      "namespace": "item",
      "declaration": "bool GetItemTable(const ::string& set, int no, ::string& id, float& count)"
    },
    {
      "namespace": "item",
      "declaration": "int GetItemLotCount(const ::string& set)"
    },
    {
      "namespace": "item",
      "declaration": "void Stop(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "void PlayGetEffect(Handle handle, bool use_effect = true, bool use_se = false)"
    },
    {
      "namespace": "item",
      "declaration": "void DisableVanish(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "void EnableVanish(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "void SetVanishMsec(Handle handle, f32 msec)"
    },
    {
      "namespace": "item",
      "declaration": "void Delete(Handle handle, int type)"
    },
    {
      "namespace": "item",
      "declaration": "Handle GetHandleDispos(int index, const ::string& name)"
    },
    {
      "namespace": "item",
      "declaration": "string GetNameDispos(int index, const ::string& name)"
    },
    {
      "namespace": "item",
      "declaration": "int GetNumDispos(const ::string& name)"
    },
    {
      "namespace": "item",
      "declaration": "void Undisplay(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "void Display(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "void WaitIsReady(Handle handle)"
    },
    {
      "namespace": "item",
      "declaration": "Handle EntryDrop(const ::string& name, const ::string& id, const math::Vec3& pos)"
    },
    {
      "namespace": "item",
      "declaration": "Handle EntryForEvent(const ::string& name, const ::string& id, const math::Vec3& pos)"
    },
    {
      "namespace": "item",
      "declaration": "Handle EntryGallery(const ::string& name, const ::string& id, const math::Vec3& pos)"
    },
    {
      "namespace": "item",
      "declaration": "Handle Entry(const ::string& name, const ::string& id, const math::Vec3& pos)"
    },
    {
      "namespace": "gmap",
      "declaration": "string GetDigLocation(const string& dig_id)"
    },
    {
      "namespace": "gmap",
      "declaration": "string GetDigItemSet(const string& dig_id, int item_age)"
    },
    {
      "namespace": "gmap",
      "declaration": "bool getDigID(math::Vec3& check_pos, string& dig_id, string& dig_locate, string& dig_func)"
    },
    {
      "namespace": "gmap",
      "declaration": "string GetDigName(int index)"
    },
    {
      "namespace": "gmap",
      "declaration": "int GetDigDataNum()"
    },
    {
      "namespace": "gmap",
      "declaration": "void KillAnimeEffect(int idx=0)"
    },
    {
      "namespace": "gmap",
      "declaration": "void KillAnimeSound(int idx=0)"
    },
    {
      "namespace": "gmap",
      "declaration": "void EAobj_DestroyAnime(int idx)"
    },
    {
      "namespace": "gmap",
      "declaration": "void EAobj_WaitAnimeLoopTiming(int idx=0)"
    },
    {
      "namespace": "gmap",
      "declaration": "void EAobj_WaitAnimeEnd(int idx=0)"
    },
    {
      "namespace": "gmap",
      "declaration": "void EAobj_ChangeAnimeRefresh(const string& anime, int idx=0)"
    },
    {
      "namespace": "gmap",
      "declaration": "void EAobj_ChangeAnime(const string& anime, int idx=0)"
    },
    {
      "namespace": "gmap",
      "declaration": "::string GetEntryBeroName(void)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ShowNode(const ::string& name)"
    },
    {
      "namespace": "gmap",
      "declaration": "void HideNode(const ::string& name)"
    },
    {
      "namespace": "gmap",
      "declaration": "void RoadPlayModelOn(::string curveName)"
    },
    {
      "namespace": "gmap",
      "declaration": "void RoadPlayModelOff(::string curveName)"
    },
    {
      "namespace": "gmap",
      "declaration": "void RoadCurveSetOffsetRotY_Deg(::string curveName, f32 deg)"
    },
    {
      "namespace": "gmap",
      "declaration": "void RoadCurveNotStartWithOnly(::string curveNameStartWith)"
    },
    {
      "namespace": "gmap",
      "declaration": "void RoadCurveStartWithOnly(::string curveNameStartWith)"
    },
    {
      "namespace": "gmap",
      "declaration": "void RoadCurveOn(::string curveName)"
    },
    {
      "namespace": "gmap",
      "declaration": "void RoadCurveOff(::string curveName)"
    },
    {
      "namespace": "gmap",
      "declaration": "bool SetBoundingShapePos(const string& box_name, const math::Vec3& pos)"
    },
    {
      "namespace": "gmap",
      "declaration": "bool IsContainBoundingBox(const string& box_name, const math::Vec3& pos, float expand)"
    },
    {
      "namespace": "gmap",
      "declaration": "bool IsContainBoundingBox(const string& box_name, const math::Vec3& pos)"
    },
    {
      "namespace": "gmap",
      "declaration": "math::Vec3 GetBoundingShapeSize(const string& shape_name)"
    },
    {
      "namespace": "gmap",
      "declaration": "math::Vec3 GetBoundingShapePos(const string& shape_name)"
    },
    {
      "namespace": "gmap",
      "declaration": "bool IsExistBoundingShape(const string& shape_name)"
    },
    {
      "namespace": "gmap",
      "declaration": "void DisableMeshCollisionAll()"
    },
    {
      "namespace": "gmap",
      "declaration": "void DisableMeshCollision( ::string mesh, bool copyToChildren = true )"
    },
    {
      "namespace": "gmap",
      "declaration": "void EnableMeshCollision( ::string mesh, bool copyToChildren = true )"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetDisableMeshCollision( ::string mesh, bool ignore, bool copyToChildren = true )"
    },
    {
      "namespace": "gmap",
      "declaration": "void LinkSetExitFadeOut(const string& link_id, const string& fade_name)"
    },
    {
      "namespace": "gmap",
      "declaration": "string LinkGetExitFadeOut(const string& link_id)"
    },
    {
      "namespace": "gmap",
      "declaration": "void LinkSetEnterFadeIn(const string& link_id, const string& fade_name)"
    },
    {
      "namespace": "gmap",
      "declaration": "string LinkGetEnterFadeIn(const string& link_id)"
    },
    {
      "namespace": "gmap",
      "declaration": "string GetArriveID()"
    },
    {
      "namespace": "gmap",
      "declaration": "bool CheckCourseCaption()"
    },
    {
      "namespace": "gmap",
      "declaration": "void EnableCourseCaption()"
    },
    {
      "namespace": "gmap",
      "declaration": "void DisableCourseCaption()"
    },
    {
      "namespace": "gmap",
      "declaration": "string GetLastExitNode()"
    },
    {
      "namespace": "gmap",
      "declaration": "string GetLastEnterNode()"
    },
    {
      "namespace": "gmap",
      "declaration": "bool LinkCheckSameCourse()"
    },
    {
      "namespace": "gmap",
      "declaration": "bool LinkCheckSameMap()"
    },
    {
      "namespace": "gmap",
      "declaration": "void LinkExitUncancel()"
    },
    {
      "namespace": "gmap",
      "declaration": "void LinkExitCancel()"
    },
    {
      "namespace": "gmap",
      "declaration": "void LinkUncancel(const ::string& id)"
    },
    {
      "namespace": "gmap",
      "declaration": "void LinkCancel(const ::string& id)"
    },
    {
      "namespace": "gmap",
      "declaration": "string LinkGetNextName(void)"
    },
    {
      "namespace": "gmap",
      "declaration": "string LinkGetExitName(void)"
    },
    {
      "namespace": "gmap",
      "declaration": "void LinkGetDokanConfig(const string& id, string& lobj, string& anim, string& camera, int& anim_index, bool& is_reverse)"
    },
    {
      "namespace": "gmap",
      "declaration": "string LinkGetMarioDir(const string& id)"
    },
    {
      "namespace": "gmap",
      "declaration": "bool LinkCheckDoorToDoor(const ::string& id)"
    },
    {
      "namespace": "gmap",
      "declaration": "s32 LinkGetDoorType(const ::string& id)"
    },
    {
      "namespace": "gmap",
      "declaration": "::string LinkGetType(const ::string& id)"
    },
    {
      "namespace": "gmap",
      "declaration": "bool LinkCheckWalk(const ::string& id)"
    },
    {
      "namespace": "gmap",
      "declaration": "::string LinkGetLocate(const ::string& id)"
    },
    {
      "namespace": "gmap",
      "declaration": "void LinkGetDirection(const ::string& id, f32& dir)"
    },
    {
      "namespace": "gmap",
      "declaration": "bool LinkGetGoalPos(string& id, f32& x, f32& y, f32& z, bool check_ground = true)"
    },
    {
      "namespace": "gmap",
      "declaration": "void LinkGetPos(string& id, f32& x, f32& y, f32& z, bool check_ground = true)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ExitFromBonus(const ::string& id, const ::string& nextmap)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ExitToBonus(const ::string& next_map)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ExitEvent(const ::string& id)"
    },
    {
      "namespace": "gmap",
      "declaration": "void Exit(const ::string& id)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetLctVisible(const ::string& lct_name, bool visible)"
    },
    {
      "namespace": "gmap",
      "declaration": "bool IsLctVisible(const ::string& lct_name, bool recursive)"
    },
    {
      "namespace": "gmap",
      "declaration": "math::Vec3 GetLctPos(const ::string& lct_name)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetAnimeStopSystemFlag(bool stop, s32 index=0, s32 sys_flag=-1)"
    },
    {
      "namespace": "gmap",
      "declaration": "void WaitAnimeFrame( f32 frame, int index = 0 )"
    },
    {
      "namespace": "gmap",
      "declaration": "string GetAnimeName( int index = 0 )"
    },
    {
      "namespace": "gmap",
      "declaration": "f32 GetTotalAnimeFrame( int index = 0 )"
    },
    {
      "namespace": "gmap",
      "declaration": "f32 GetAnimeSpeed( int index = 0 )"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetAnimeSpeed( f32 frame, int index = 0 )"
    },
    {
      "namespace": "gmap",
      "declaration": "f32 GetAnimeFrame( int index = 0 )"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetAnimeFrame( f32 frame, int index = 0 )"
    },
    {
      "namespace": "gmap",
      "declaration": "void WaitAnimeNextLoop( int idx = 0 )"
    },
    {
      "namespace": "gmap",
      "declaration": "bool IsAnimeContinue( int idx = 0 )"
    },
    {
      "namespace": "gmap",
      "declaration": "void DestroyAnime( int idx = 0 )"
    },
    {
      "namespace": "gmap",
      "declaration": "void WaitAnimeEnd( int idx = 0 )"
    },
    {
      "namespace": "gmap",
      "declaration": "void ChangeAnimeForce( const ::string& anime_name, int idx = 0)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ChangeAnime( const ::string& anime_name, int idx = 0)"
    },
    {
      "namespace": "gmap",
      "declaration": "void LoadEnv( const ::string& map_id )"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetBlurScale(f32 frame  = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetEnvColor(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetHFogColor(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetHFogScale(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetHFog(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetFogColor(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetFogScale(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetFog(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetShadowColor(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetAmbientColor(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetLightColor(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetLightDir(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetEnvAll(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetShadowBias(f32 bias = 30.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetBlurScale(f32 scale, f32 frame  = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetEnvColor(f32 r, f32 g, f32 b, f32 frame  = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetHFogColor(f32 r, f32 g, f32 b, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetFogColor(f32 r, f32 g, f32 b, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetHFogScale(f32 scale, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetHFogDir(f32 azimuth, f32 altitude, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetHFog(f32 start, f32 end, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetFogScale(f32 scale, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetFog(f32 start, f32 end, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetFogType(int fog_type = 0)"
    },
    {
      "namespace": "gmap",
      "declaration": "int GetFogType(void)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetShadowColor(f32 r, f32 g, f32 b, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetAmbientColor(f32 r, f32 g, f32 b, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetLightColor(f32 r, f32 g, f32 b, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetLightDir(f32 azimuth, f32 altitude, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetDistortionParam(f32 frame)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetDistortionParam(f32 power, f32 top_power, f32 scale, f32 speed, f32 x, f32 y, f32 frame)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetDistortionParam(f32 power, f32 top_power)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetDistortionVisible(bool visible)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetContrastParam(f32 frame)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetContrastParam(f32 bright, f32 gray, f32 contrast)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetContrastVisible(bool visible)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetGradationParam(f32 frame)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetGradationCheck(bool checkFrag)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetGradationColor(f32 r1, f32 g1, f32 b1, f32 r2, f32 g2, f32 b2)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetGradationParam(f32 r, f32 g, f32 b, f32 angle, f32 alpha, f32 frame)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetGradationVisible(bool visible)"
    },
    {
      "namespace": "gmap",
      "declaration": "void FadeInVignette(int time)"
    },
    {
      "namespace": "gmap",
      "declaration": "void FadeOutVignette(float scale, float power, int time)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetVinEllipse(bool useEllipse)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetVinVisible(bool frag)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetVinOffset(f32 offset_x, f32 offset_y)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetVinParam(f32 scale, f32 power)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetVinType(int type)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetTonemapParam(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetTonemapParam(f32 luminance, f32 exposure, f32 white, f32 key, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetTonemapVisible(bool visible)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetDofParam(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetDofParam2(f32 near_start, f32 near_end, f32 far_start, f32 far_end, f32 blur_size, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetDofParam(f32 near, f32 far, f32 focus, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void DisableDofFocusDistance()"
    },
    {
      "namespace": "gmap",
      "declaration": "void EnableDofFocusDistance(f32 distance)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetDofVisible(bool visible)"
    },
    {
      "namespace": "gmap",
      "declaration": "void ResetBloomParam(f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetBloomParam(f32 threshold, f32 power, f32 scale, f32 frame = 10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetLightFilterOnOff (bool on, f32 frame=10.0f)"
    },
    {
      "namespace": "gmap",
      "declaration": "void SetBloomVisible(bool visible)"
    },
    {
      "namespace": "gmap",
      "declaration": "void RefreshOverlapImage(int phase)"
    },
    {
      "namespace": "gmap",
      "declaration": "void LoadSettings(string& id)"
    },
    {
      "namespace": "gmap",
      "declaration": "void WaitInitializeEvent(void)"
    },
    {
      "namespace": "gmap",
      "declaration": "void WaitInitializeDispos(void)"
    },
    {
      "namespace": "gmap",
      "declaration": "::string GetMapId(void)"
    },
    {
      "namespace": "gmap",
      "declaration": "Handle Entry()"
    },
    {
      "namespace": "fade",
      "declaration": "bool isBright(int ch)"
    },
    {
      "namespace": "fade",
      "declaration": "bool isBright()"
    },
    {
      "namespace": "fade",
      "declaration": "void SetCenter(int ch, math::Vec3 center)"
    },
    {
      "namespace": "fade",
      "declaration": "bool isLoop(int ch)"
    },
    {
      "namespace": "fade",
      "declaration": "void cancel(int ch)"
    },
    {
      "namespace": "fade",
      "declaration": "as_f32 GetFadeLength(int ch)"
    },
    {
      "namespace": "fade",
      "declaration": "void NextRun(int ch, string& name, int msec = 400)"
    },
    {
      "namespace": "fade",
      "declaration": "void Run(int ch, string& name, int msec = 400, math::Vec3 center = math::Vec3(0.0f, 0.0f, 0.0f))"
    },
    {
      "namespace": "fade",
      "declaration": "void Fadein(int ch, int msec, math::Vec3& center = math::Vec3())"
    },
    {
      "namespace": "fade",
      "declaration": "void Fadeout(int ch, int msec, math::Vec3 center = math::Vec3())"
    },
    {
      "namespace": "fade",
      "declaration": "void Clear(int ch)"
    },
    {
      "namespace": "fade",
      "declaration": "void WaitFade(int ch)"
    },
    {
      "namespace": "fade",
      "declaration": "bool IsRun(int ch)"
    },
    {
      "namespace": "dbg::text",
      "declaration": "void SetFrame(as_u32 frame)"
    },
    {
      "namespace": "dbg::text",
      "declaration": "void SetBGColor(util::Color4f col)"
    },
    {
      "namespace": "dbg::text",
      "declaration": "void SetTextScale(as_f32 x, as_f32 y)"
    },
    {
      "namespace": "dbg::text",
      "declaration": "void SetTextColor(util::Color4f col)"
    },
    {
      "namespace": "dbg::text",
      "declaration": "void SetAlign(int flags)"
    },
    {
      "namespace": "dbg::text",
      "declaration": "void SetPos(const math::Vec3& pos)"
    },
    {
      "namespace": "dbg::text",
      "declaration": "void SetPos(as_f32 x, as_f32 y)"
    },
    {
      "namespace": "dbg::text",
      "declaration": "void AddText(const ::string& fmt, ::string p0=\"0\",::string p1=\"0\",::string p2=\"0\",::string p3=\"0\",::string p4=\"0\",::string p5=\"0\",::string p6=\"0\",::string p7=\"0\",::string p8=\"0\",::string p9=\"0\")"
    },
    {
      "namespace": "dbg::text",
      "declaration": "void End()"
    },
    {
      "namespace": "dbg::text",
      "declaration": "void Begin()"
    },
    {
      "namespace": "dbg::text",
      "declaration": "void Show(math::Vec3& pos, int frame, const ::string& fmt, ::string p0=\"0\",::string p1=\"0\",::string p2=\"0\",::string p3=\"0\",::string p4=\"0\",::string p5=\"0\",::string p6=\"0\",::string p7=\"0\",::string p8=\"0\",::string p9=\"0\")"
    },
    {
      "namespace": "dbg::text",
      "declaration": "void Show(float x, float y, int frame, const ::string& fmt, ::string p0=\"0\",::string p1=\"0\",::string p2=\"0\",::string p3=\"0\",::string p4=\"0\",::string p5=\"0\",::string p6=\"0\",::string p7=\"0\",::string p8=\"0\",::string p9=\"0\")"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseRsRight()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigRsRight()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatRsRight()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonRsRight()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseRsLeft()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigRsLeft()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatRsLeft()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonRsLeft()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseRsDown()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigRsDown()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatRsDown()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonRsDown()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseRsUp()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigRsUp()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatRsUp()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonRsUp()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseLsRight()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigLsRight()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatLsRight()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonLsRight()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseLsLeft()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigLsLeft()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatLsLeft()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonLsLeft()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseLsDown()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigLsDown()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatLsDown()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonLsDown()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseLsUp()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigLsUp()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatLsUp()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonLsUp()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseRight()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigRight()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatRight()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonRight()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseLeft()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigLeft()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatLeft()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonLeft()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseDown()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigDown()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatDown()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonDown()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseUp()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigUp()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatUp()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonUp()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseR()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigR()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatR()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonR()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseL()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigL()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatL()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonL()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseZR()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigZR()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatZR()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonZR()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseZL()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigZL()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatZL()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonZL()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseY()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigY()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatY()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonY()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseX()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigX()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatX()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonX()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseB()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigB()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatB()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonB()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsReleaseA()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsTrigA()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsRepeatA()"
    },
    {
      "namespace": "dbg::hid",
      "declaration": "bool IsButtonA()"
    },
    {
      "namespace": "dbg::Spot",
      "declaration": "void ClearAllPos()"
    },
    {
      "namespace": "dbg::Spot",
      "declaration": "bool SetPos(array<math::Vec3>& pos_array)"
    },
    {
      "namespace": "dbg::Spot",
      "declaration": "bool SetPos(math::Vec3 pos)"
    },
    {
      "namespace": "dbg::Skip",
      "declaration": "bool IsSkip()"
    },
    {
      "namespace": "dbg::Skip",
      "declaration": "void SetChapter()"
    },
    {
      "namespace": "dbg",
      "declaration": "void HideSystemRootMenu()"
    },
    {
      "namespace": "dbg",
      "declaration": "void ShowSystemRootMenu()"
    },
    {
      "namespace": "dbg",
      "declaration": "bool IsShowSystemRootMenu()"
    },
    {
      "namespace": "dbg",
      "declaration": "void EntrySimpleButton(const string& button_name, SimpleCallback ref simple_func)"
    },
    {
      "namespace": "dbg",
      "declaration": "void EntryButton(const string& button_name, DebugWindowCallback ref func, any ref func_arg = null)"
    },
    {
      "namespace": "dbg",
      "declaration": "void EntryWindow(DebugWindowCallback ref func, any ref func_arg = null)"
    },
    {
      "namespace": "dbg",
      "declaration": "void CalcShapeAABBForIcon(chr::Handle handle, math::Vec3& bbMin, math::Vec3& bbMax)"
    },
    {
      "namespace": "dbg",
      "declaration": "bool CheckPlayerInvincible()"
    },
    {
      "namespace": "dbg",
      "declaration": "as::string GetOriginBeroId(as::string beroId)"
    },
    {
      "namespace": "dbg",
      "declaration": "math::Vec3 GetJoinPos()"
    },
    {
      "namespace": "dbg",
      "declaration": "string GetJoinId(string beroId)"
    },
    {
      "namespace": "dbg",
      "declaration": "int JudgeJoinMode()"
    },
    {
      "namespace": "dbg",
      "declaration": "bool ArrowHead(math::Vec3 start, math::Vec3 end, math::Vec4 color, f32 scale=1.0f, f32 dir_deg=0.0f)"
    },
    {
      "namespace": "dbg",
      "declaration": "void Line2D(math::Vec3 start, math::Vec3 end, math::Vec4 color)"
    },
    {
      "namespace": "dbg",
      "declaration": "void Line(math::Vec3 start, math::Vec3 end, math::Vec4 color)"
    },
    {
      "namespace": "dbg",
      "declaration": "void WatchGF(string flag_name, string comment)"
    },
    {
      "namespace": "dbg",
      "declaration": "bool IsNoPresence()"
    },
    {
      "namespace": "dbg",
      "declaration": "bool IsActOnly()"
    },
    {
      "namespace": "dbg",
      "declaration": "bool IsInvincible()"
    },
    {
      "namespace": "dbg",
      "declaration": "void Screenshot4K(string fname)"
    },
    {
      "namespace": "dbg",
      "declaration": "void ScreenshotIcon(int width, int height, string fname)"
    },
    {
      "namespace": "dbg",
      "declaration": "void Screenshot()"
    },
    {
      "namespace": "dbg",
      "declaration": "void StopScreenshotMovie()"
    },
    {
      "namespace": "dbg",
      "declaration": "void StartScreenshotMovie()"
    },
    {
      "namespace": "chr",
      "declaration": "void CancelTalkAnim(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetupTalkAlphaWait(Handle handle, float change_frame, s32 alpha_index)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetupTalkAlpha(Handle handle, float change_frame, s32 alpha_index)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetupTalkWait(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetupTalkNone(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableHidingSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableHidingSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void PlayLanding(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void PlayJump(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void StopSoundSignal(Handle handle, float fade)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetSoundSignalCtrlNameNoPlay(Handle handle, ::string name, bool v)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetSoundSignalAddName(Handle handle, ::string name)"
    },
    {
      "namespace": "chr",
      "declaration": "void StopSE(Handle handle, ::string name)"
    },
    {
      "namespace": "chr",
      "declaration": "void StopSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "snd::VoiceHandle PlaySE(Handle handle, ::string name, ::string flagname, f32 vol=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "snd::VoiceHandle PlaySE(Handle handle, ::string flagname, f32 vol=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsInScreen( Handle handle) "
    },
    {
      "namespace": "chr",
      "declaration": "bool IsInScreen( Handle handle, float expand_w, float expand_h) "
    },
    {
      "namespace": "chr",
      "declaration": "void UpdateFishGroupCircle(array<Handle>& chr_list, math::Vec3 base_pos, f32 radius, f32 rot, f32 separate_ratio = 10.0f, f32 separate_power = 1.0f, f32 max_speed = 0.4f)"
    },
    {
      "namespace": "chr",
      "declaration": "void UpdateFishGroup(array<Handle>& chr_list, math::Vec3 base_pos, math::Vec3 base_dir, f32 separate_ratio = 10.0f, f32 separate_power = 1.0f, f32 max_speed = 0.4f)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetOceanTransform(Handle handle, f32 z)"
    },
    {
      "namespace": "chr",
      "declaration": "int GetPlayerJumpCount(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "int GetPlayerHammerCount(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "int GetPlayerDirCount(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableGetPlayerAction(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableGetPlayerAction(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void VehicleRemoveChr(Handle vehicleHandle, Handle removechrHandle)"
    },
    {
      "namespace": "chr",
      "declaration": "void VehicleAddChr(Handle vehicleHandle, Handle addchrHandle)"
    },
    {
      "namespace": "chr",
      "declaration": "void VehicleBreakAction( Handle handle )"
    },
    {
      "namespace": "chr",
      "declaration": "void VehicleAddHammerPower( Handle handle, const math::Vec3& power )"
    },
    {
      "namespace": "chr",
      "declaration": "void VehicleActionOff( Handle handle )"
    },
    {
      "namespace": "chr",
      "declaration": "void VehicleActionOn( Handle handle )"
    },
    {
      "namespace": "chr",
      "declaration": "void ReactionFlgOff( Handle handle,uint32_t flg)"
    },
    {
      "namespace": "chr",
      "declaration": "void ReactionFlgOn( Handle handle,uint32_t flg)"
    },
    {
      "namespace": "chr",
      "declaration": "bool ReactionFlgCheck( Handle handle,uint32_t flg)"
    },
    {
      "namespace": "chr",
      "declaration": "void AttributeFlgOff( Handle handle,uint32_t flg)"
    },
    {
      "namespace": "chr",
      "declaration": "void AttributeFlgOn( Handle handle,uint32_t flg)"
    },
    {
      "namespace": "chr",
      "declaration": "bool AttributeFlgCheck( Handle handle,uint32_t flg)"
    },
    {
      "namespace": "chr",
      "declaration": "void StatusFlgOff( Handle handle,uint32_t flg)"
    },
    {
      "namespace": "chr",
      "declaration": "void StatusFlgOn( Handle handle,uint32_t flg)"
    },
    {
      "namespace": "chr",
      "declaration": "bool StatusFlgCheck( Handle handle,uint32_t flg)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetMaterialParam(Handle handle, string name, float v)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetMaterialParam(Handle handle, string name, const math::Vec3& v)"
    },
    {
      "namespace": "chr",
      "declaration": "float GetCameraFadeNear(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetCameraFadeNear(Handle handle, float dist)"
    },
    {
      "namespace": "chr",
      "declaration": "as::Variable& GetWork(Handle handle, int no)"
    },
    {
      "namespace": "chr",
      "declaration": "as::Variable& GetPrivWork(Handle handle, int no)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetMatrix(Handle handle, const math::Mtx43& matrix)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetScaleZ(Handle handle, f32 z)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetScaleY(Handle handle, f32 y)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetScaleX(Handle handle, f32 x)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetScale(Handle handle, const math::Vec3& scale)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetScaleZ(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetScaleY(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetScaleX(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetScale(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetPosZ_Fast(Handle handle, f32 z)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetPosY_Fast(Handle handle, f32 y)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetPosX_Fast(Handle handle, f32 x)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetPos_Fast(Handle handle, const math::Vec3& pos)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetPosZ(Handle handle, f32 z)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetPosY(Handle handle, f32 y)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetPosX(Handle handle, f32 x)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetPos(Handle handle, const math::Vec3& pos)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetPosZ(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetPosY(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetPosX(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetMoveVec(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetPrevPos(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3& GetPos(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetFirstDir(Handle handle, f32 dir)"
    },
    {
      "namespace": "chr",
      "declaration": "f32 GetFirstDir(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetFirstPos(Handle handle, math::Vec3 & pos)"
    },
    {
      "namespace": "chr",
      "declaration": "const math::Vec3& _GetFirstPos(const Handle& handle)"
    },
    {
      "namespace": "chr",
      "declaration": "const math::Vec3& GetFirstPos(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsValidHandle(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "string GetID(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "string GetName(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetSilhouetteVisibilitySource(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void ResetSilhouetteVisibilitySource(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAlphaToTargetShapes(Handle handle, f32 alpha)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetStainEffectDirtAlpha(Handle handle, f32 alpha)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetStainEffectWhiteAlpha(Handle handle, f32 alpha)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetStainEffectWrinkleAlpha(Handle handle, f32 alpha)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLOD2(Handle handle, f32 dist)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLOD1(Handle handle, f32 dist)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetParam0f(Handle handle, const string& name, f32 param_0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetOpacity(Handle handle, const string& name, f32 opacity)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetEmission(Handle handle, const string& name, f32 emission)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctForProbe(Handle handle, const string& lct_name)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRealIceDistortionOnMask(Handle handle, float distortion)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRealIceModelMaskEnable(Handle handle, bool enable)"
    },
    {
      "namespace": "chr",
      "declaration": "void UnlockModelFadeOut(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void LockModelFade(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void StartModelFadeOut(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void StartModelFadeIn(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetPlaneClipGreaterThan(Handle handle, f32 worldY)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetPlaneClipLessThan(Handle handle, f32 worldY)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetUpdateOptimizedMode(Handle handle, int mode)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeDisplayTypeToDefault(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeDisplayTypeToOceanClipAsFillColor(Handle handle, math::Vec3 color)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeDisplayTypeToOceanClip(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeDisplayTypeToPhoto(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void UnmaskFromGfxFilter(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void MaskFromGfxFilter(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableLightRadiusScale(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLightIntensitySubMul(Handle handle, const ::string& light_name, float intensity)"
    },
    {
      "namespace": "chr",
      "declaration": "void FadeOutLight(Handle handle, const ::string& light_name, int frame)"
    },
    {
      "namespace": "chr",
      "declaration": "void FadeInLight(Handle handle, const ::string& light_name, int frame)"
    },
    {
      "namespace": "chr",
      "declaration": "void NoUsePlayerSilhouette(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void UsePlayerSilhouette(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void RenderPassAfter2D(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void ResetChangeLayer(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeLayer(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetForceCalcBounding(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetReceiveStencilShadowEnable(Handle handle, bool enable)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetCastStencilShadowEnable(Handle handle, bool enable)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetCastOmniShadowEnable(Handle handle, bool enable)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetCastSunShadowEnable(Handle handle, bool enable)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetStencilShadowRadius(Handle handle, f32 radius)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetStencilShadowBlur(Handle handle, f32 blur)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetStencilShadowDarkness(Handle handle, f32 darkness)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetStencilShadowLength(Handle handle, f32 length)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetCastShadowEnable(Handle handle, bool enable)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctMatrix(Handle handle, const ::string& bone_name, const math::Mtx43& mtx)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctRotZ(Handle handle, const ::string& bone_name, float z)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctRotY(Handle handle, const ::string& bone_name, float y)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctRotX(Handle handle, const ::string& bone_name, float x)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctRot(Handle handle, const ::string& bone_name, math::Vec3 deg)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctScaleZ(Handle handle, const ::string& bone_name, float z)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctScaleY(Handle handle, const ::string& bone_name, float y)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctScaleX(Handle handle, const ::string& bone_name, float x)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctScale(Handle handle, const ::string& bone_name, math::Vec3 scale)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctPositionZ(Handle handle, const ::string& bone_name, float z)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctPositionY(Handle handle, const ::string& bone_name, float y)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctPositionX(Handle handle, const ::string& bone_name, float x)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctPosition(Handle handle, const ::string& bone_name, math::Vec3 pos)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLctVisible(Handle handle, const ::string& bone_name, bool visible)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsLctVisible(Handle handle, const ::string& bone_name, bool recursive)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsValidLct(Handle handle, const ::string& lct_name)"
    },
    {
      "namespace": "chr",
      "declaration": "string GetLctName(Handle handle, int index = 0)"
    },
    {
      "namespace": "chr",
      "declaration": "void EditLctLocal(Handle handle, const ::string& lct_name, const math::Mtx43& local)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Mtx43 GetLctMtx(Handle handle, const ::string& lct_name)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetLctRot(Handle handle, const ::string& lct_name)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetLctPos(Handle handle, const ::string& lct_name)"
    },
    {
      "namespace": "chr",
      "declaration": "void ReplaceTexture(Handle handle, string base_name, string sub_name)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetMainAlbedoTexture(Handle handle, const ::string& color)"
    },
    {
      "namespace": "chr",
      "declaration": "void ForceUpdateMatrix(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetCheckMapAdhere(Handle handle, bool enable)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetCheckMapWaterSurface(Handle handle, bool enable)"
    },
    {
      "namespace": "chr",
      "declaration": "void OverrideMaterialSet(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsInBranch(Handle handle, string& branch_node, string& check_node)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableHit(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableHit(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableStopHammer( Handle handle )"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableStopHammer( Handle handle )"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableHitShapeForPlayer( Handle handle )"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableHitShapeForPlayer( Handle handle )"
    },
    {
      "namespace": "chr",
      "declaration": "void SetHitMoveReaction(Handle handle, int flag)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetHitOffsetPos(Handle handle, math::Vec3 v)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetHitOffsetPosZ(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetHitOffsetPosY(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetHitOffsetPosX(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetHitOffsetPos(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "u64 GetHitFootFlag(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "u64 GetHitMapFlag(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_u32 GetHitMapSideMaterial(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "const math::Vec3& GetHitMapSidePos(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "const math::Vec3& GetHitMapSideNormal(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "bool CheckHits(Handle handle, int flag)"
    },
    {
      "namespace": "chr",
      "declaration": "bool HitCheck(Handle handle1, Handle handle2 )"
    },
    {
      "namespace": "chr",
      "declaration": "bool HitcheckFlgCheck(Handle handle, u32 flg)"
    },
    {
      "namespace": "chr",
      "declaration": "void HitcheckFlgOff(Handle handle, u32 flg)"
    },
    {
      "namespace": "chr",
      "declaration": "void HitcheckFlgOn(Handle handle, u32 flg)"
    },
    {
      "namespace": "chr",
      "declaration": "f32 GetFloorHeight(f32 x, f32 y, f32 z, f32 dist)"
    },
    {
      "namespace": "chr",
      "declaration": "int GetHitCorrect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetHitCorrect(Handle handle, int correct)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetHitShape(Handle handle, int shape)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetHitSize(Handle handle, math::Vec3 v)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetHitSize(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetHitDepth(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetHitHeight(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetHitWidth(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "bool CheckHitPlaceFlgsAtoB(Handle handleA, Handle handleB, int hit_place)"
    },
    {
      "namespace": "chr",
      "declaration": "bool CheckHitPlaceFlgs(Handle handle, int hit_place)"
    },
    {
      "namespace": "chr",
      "declaration": "void ClearFollow(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void ClearRelativeFollowTranslate(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void ClearRelativeFollowMtx(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void ForceEnableFollowFade(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetIgnoreHitOfFollow(Handle handle, bool ignore)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetIgnoreVisibleOfFollow(Handle handle, bool ignore)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetFollow(Handle handle, const ::string& my_lct, const ::string& target_lct, bool keep_relative=false, bool only_translate=false)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetFollow(Handle handle, const ::string& my_lct, Handle target, bool only_translate=false)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetFollow(Handle handle, const ::string& my_lct, Handle target, const ::string& target_lct, bool only_translate=false)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetFollow(Handle handle, Handle target, bool keep_relative=false)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetFollow(Handle handle, Handle target, const ::string& lct_name, bool keep_relative=false, bool only_translate=false)"
    },
    {
      "namespace": "chr",
      "declaration": "string GetHammerSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetEffectLctName(Handle handle, string name)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLoopStopEffect(Handle handle, string label)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLoopEffect(Handle handle, string label)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetOutEffect(Handle handle, string label)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetInEffect(Handle handle, string label)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLandingEffect(Handle handle, string label)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLoopSE(Handle handle, string label)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetOutSE(Handle handle, string label)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetInSE(Handle handle, string label)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLandingSE(Handle handle, string label)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableLoopEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableLoopEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableLoopSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableLoopSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableOutEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableOutEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableOutSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableOutSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableInEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableInEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableInSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableInSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableJumpEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableJumpEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableJumpSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableJumpSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableLandingEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableLandingEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableLandingSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableLandingSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableFootstepEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableFootstepEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableFootstepSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableFootstepSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableSE(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void FishOn(Handle handle, bool is_gyro = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void Hatena(Handle handle, math::Vec3 adjust=math::Vec3(0.0f, 0.0f, 0.0f), float angle = 0)"
    },
    {
      "namespace": "chr",
      "declaration": "void BikkuriWave(Handle handle, math::Vec3 adjust=math::Vec3(0.0f, 0.0f, 0.0f), float angle = 0)"
    },
    {
      "namespace": "chr",
      "declaration": "void Bikkuri(Handle handle, math::Vec3 adjust=math::Vec3(0.0f, 0.0f, 0.0f), float angle = 0)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetBalloonOffset(Handle handle, math::Vec3 offset)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetDispOffsetPos(Handle handle, math::Vec3& offset)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetDistanceHideLength(Handle handle, f32 len)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsDistanceHide(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableDistanceHide(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableDistanceHide(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableForceShowEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableForceShowEffect(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void GetAdvancedShowParam(Handle handle, bool &is_normal_show, bool &is_system_show)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsShow(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SystemShow(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SystemHide(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void Show(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void Hide(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetLightAnimeSpeed(Handle handle, f32 light_speed, int light_index = 0)"
    },
    {
      "namespace": "chr",
      "declaration": "void WaitLightAnimeEnd(Handle handle, int light_index = 0)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeLightAnime(Handle handle, const string& anime, int light_index = 0)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsFixAnime(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void FixAnime(Handle handle, bool is_fix)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAnimeStopSystemFlag(Handle handle, as_u32 sys_flag=0xfffffffe)"
    },
    {
      "namespace": "chr",
      "declaration": "void ResizeCh(Handle handle, int num)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetBlendCh(Handle handle, int index)"
    },
    {
      "namespace": "chr",
      "declaration": "int GetBlendCh(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "::string GetAnimeState(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAnimeState(Handle handle, const string& state)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAnimeAlpha(Handle handle, float alpha, as_s32 index=0)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAnimeFrame(Handle handle, float frame, as_s32 index=0)"
    },
    {
      "namespace": "chr",
      "declaration": "float GetAnimeFrame(Handle handle,as_s32 index=0)"
    },
    {
      "namespace": "chr",
      "declaration": "float GetTotalFrame(Handle handle,as_s32 index=0)"
    },
    {
      "namespace": "chr",
      "declaration": "void ResetAnimeSpeed(Handle handle, as_s32 index=0)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAnimeSpeed(Handle handle, float step, as_s32 index=0)"
    },
    {
      "namespace": "chr",
      "declaration": "float GetAnimeSpeed(Handle handle, as_s32 index=0)"
    },
    {
      "namespace": "chr",
      "declaration": "::string GetAnimeMayaName(Handle handle, int ch = 0)"
    },
    {
      "namespace": "chr",
      "declaration": "::string GetAnimeName(Handle handle, int ch = 0)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsPlayingAnimeAny(Handle handle, int anime_index=0)"
    },
    {
      "namespace": "chr",
      "declaration": "bool HasAnime(Handle handle, const string& anime, bool other=true)"
    },
    {
      "namespace": "chr",
      "declaration": "void DestroyAnime(Handle handle, as_s32 anime_index=0)"
    },
    {
      "namespace": "chr",
      "declaration": "void WaitAnimeEnd(Handle handle, as_s32 index = 0)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetBlendAnime(Handle handle, as_s32 anime_index, f32 alpha)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeAnimeForce(Handle handle, const string& anime, as_s32 anime_index, bool no_sound_signal, bool no_effect_signal)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeAnimeForce(Handle handle, const string& anime, as_s32 anime_index=0, bool no_signal = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeAnimeNoSignal(Handle handle, const string& anime, as_s32 anime_index=0)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeAnimeXFade(Handle handle, const string& anime, as_s32 anime_index, bool no_sound_signal, bool no_effect_signal, f32 fadeFrame = 30.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeAnimeXFade(Handle handle, const string& anime, as_s32 anime_index=0, bool no_signal = false, f32 fadeFrame = 30.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeAnime(Handle handle, const string& anime, as_s32 anime_index, bool no_sound_signal, bool no_effect_signal)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChangeAnime(Handle handle, const string& anime, as_s32 anime_index=0, bool no_signal = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void RunAway(Handle handle, Handle t_handle, int interval_min, int interval_max)"
    },
    {
      "namespace": "chr",
      "declaration": "bool ChaseLoop(Handle handle, Handle t_handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChaseLoopInit(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChaseHeight(Handle handle, Handle t_handle, f32 y_offset = 0.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void ChaseForward(Handle handle, Handle t_handle, f32 dist, f32 range)"
    },
    {
      "namespace": "chr",
      "declaration": "void Chase(Handle handle, Handle t_handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetCorrectAngleMax(Handle handle, float angle_max)"
    },
    {
      "namespace": "chr",
      "declaration": "void SpinLandFrame(Handle handle, float spin_num, float spin_frame, const math::Vec3& dest_pos, const math::Vec3& dest_up_pos=math::Vec3::Zero(), int interp_type=math::MOVE_TYPE_DECEL, f32 interp_pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void SpinLandMSec(Handle handle, float spin_num, float spin_msec, const math::Vec3& dest_pos, const math::Vec3& dest_up_pos=math::Vec3::Zero(), int interp_type=math::MOVE_TYPE_DECEL, f32 interp_pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void SpinYFrame(Handle handle, float spin, float frame, int type=math::MOVE_TYPE_LINEAR)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetUseFootNormal(Handle handle, bool use)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetImageFlip(Handle handle, bool flip)"
    },
    {
      "namespace": "chr",
      "declaration": "bool ChrConvertPeraRotY(Handle handle, int check_pera_type, float &rot_y)"
    },
    {
      "namespace": "chr",
      "declaration": "bool ChrConvertPeraDir(Handle handle, int check_pera_type, float &dir)"
    },
    {
      "namespace": "chr",
      "declaration": "bool DirConvertPeraRotY(float input_dir, int check_pera_type, float &rot_y)"
    },
    {
      "namespace": "chr",
      "declaration": "bool RotYConvertPeraDir(float input_dir, int check_pera_type, float &dir)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsConvertPeraRotY(int check_pera_type)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsConvertPeraDir(int check_pera_type)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetPeraType(Handle handle, int set_pera_type)"
    },
    {
      "namespace": "chr",
      "declaration": "int GetPeraType(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void FinishPera(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void WaitPeraEnd(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 CalcRotVec(Handle handle, math::Vec3& vec)"
    },
    {
      "namespace": "chr",
      "declaration": "void Set2ndRotZ_Fast(Handle handle, f32 z)"
    },
    {
      "namespace": "chr",
      "declaration": "void Set2ndRotY_Fast(Handle handle, f32 y)"
    },
    {
      "namespace": "chr",
      "declaration": "void Set2ndRotX_Fast(Handle handle, f32 x)"
    },
    {
      "namespace": "chr",
      "declaration": "void Set2ndRot_Fast(Handle handle, const math::Vec3& rot)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRotZ_Fast(Handle handle, f32 z)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRotY_Fast(Handle handle, f32 y)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRotX_Fast(Handle handle, f32 x)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRot_Fast(Handle handle, const math::Vec3& rot)"
    },
    {
      "namespace": "chr",
      "declaration": "void Set2ndRotZ(Handle handle, f32 deg)"
    },
    {
      "namespace": "chr",
      "declaration": "void Set2ndRotY(Handle handle, f32 deg)"
    },
    {
      "namespace": "chr",
      "declaration": "void Set2ndRotX(Handle handle, f32 deg)"
    },
    {
      "namespace": "chr",
      "declaration": "void Set2ndRot(Handle handle, math::Vec3& vec)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 Get2ndRotZ(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 Get2ndRotY(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 Get2ndRotX(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 Get2ndRot(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRotOrder(Handle handle, s32 order)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRotCenter(Handle handle, math::Vec3 pos)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetRotCenter(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRotZ(Handle handle, as_f32 z)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRotY(Handle handle, as_f32 y)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRotX(Handle handle, as_f32 x)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRot(Handle handle, math::Vec3& vec)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetRotZ(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetRotY(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetRotX(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetRot(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetDir (Handle handle, f32 dir, bool direct = false)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetDirVec(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "float GetDir(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableBackFace(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableBackFace(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsDoingPeraFlip(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "bool CheckLookLeft(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "bool CheckLookFront(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void UnlockLook(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void LockLook(Handle handle, const math::Vec3& target_pos)"
    },
    {
      "namespace": "chr",
      "declaration": "void LockLook(Handle handle, Handle target)"
    },
    {
      "namespace": "chr",
      "declaration": "void LookToFront(Handle handle, Handle target, bool direct = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void LookToFront(Handle handle, const math::Vec3& target_pos, bool direct = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void LookTo(Handle handle, Handle target, bool direct = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void LookTo(Handle handle, const math::Vec3& target_pos, bool direct = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void LookTo(Handle handle, float x, float z, bool direct = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void LookSetMayaRotY(Handle handle, const float mayaRotY, int dir, bool direct=false)"
    },
    {
      "namespace": "chr",
      "declaration": "void Look(Handle handle, int dir, bool direct=false)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetUniqueDir(Handle handle, int look_dir, float dir)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetFlat(Handle handle, bool flat)"
    },
    {
      "namespace": "chr",
      "declaration": "void FlipRight(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void FlipLeft(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void FaceBack(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void FaceFront(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void UnfixFrontDir(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void FixFrontDir(Handle handle, float dir)"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsFixPeraDir(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void FixPeraDir(Handle handle, bool is_fix, bool reset_internal_dir=false)"
    },
    {
      "namespace": "chr",
      "declaration": "void Rot(Handle handle, float rot, bool direct=false)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableSlowdown(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableSlowdown(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableSpeedup(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableSpeedup(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpSubLanding(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpSubTop(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpSubFirst(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void VerticalJumpToMSecEx(Handle handle, f32 move_msec, const math::Vec3 & end_pos=chr::JUMP_STAY_POS, f32 start_adjust_base_y = -1.0f, f32 end_adjust_base_y = -1.0f, f32 height_limit_min = -1.0f, f32 height_limit_max = -1.0f, f32 height_rate = 1.0f, s32 start_bezier_form_curveType = math::bezier::CurveType_Quadratic, s32 end_bezier_form_curveType = math::bezier::CurveType_Quadratic, s32 start_bezier_move_curveType = math::bezier::CurveType_Quadratic, s32 end_bezier_move_curveType = math::bezier::CurveType_Quadratic)"
    },
    {
      "namespace": "chr",
      "declaration": "void VerticalJumpToMSec(Handle handle, f32 move_msec, const math::Vec3 & end_pos=chr::JUMP_STAY_POS, f32 adjust_base_y = -1.0f, f32 height_limit_min = -1.0f, f32 height_limit_max = -1.0f, s32 bezier_form_curveType = math::bezier::CurveType_Quadratic, s32 bezier_move_curveType = math::bezier::CurveType_Quadratic)"
    },
    {
      "namespace": "chr",
      "declaration": "void VerticalJumpToEx(Handle handle, f32 speed = -1.0f, const math::Vec3 & end_pos=chr::JUMP_STAY_POS, f32 start_adjust_base_y = -1.0f, f32 end_adjust_base_y = -1.0f, f32 height_limit_min = -1.0f, f32 height_limit_max = -1.0f, f32 height_rate = 1.0f, s32 start_bezier_form_curveType = math::bezier::CurveType_Quadratic, s32 end_bezier_form_curveType = math::bezier::CurveType_Quadratic, s32 start_bezier_move_curveType = math::bezier::CurveType_Quadratic, s32 end_bezier_move_curveType = math::bezier::CurveType_Quadratic)"
    },
    {
      "namespace": "chr",
      "declaration": "void VerticalJumpTo(Handle handle, f32 speed = -1.0f, const math::Vec3 & end_pos=chr::JUMP_STAY_POS, f32 adjust_base_y = -1.0f, f32 height_limit_min = -1.0f, f32 height_limit_max = -1.0f, s32 bezier_form_curveType = math::bezier::CurveType_Quadratic, s32 bezier_move_curveType = math::bezier::CurveType_Quadratic)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpFallToMSec_EventFall(Handle handle, float move_msec, const math::Vec3 & ePos)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpFallToMSec_FreeFall(Handle handle, float move_msec, const math::Vec3 & ePos, bool _safety_abyss=true)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpFallToMSec(Handle handle, float move_msec, const math::Vec3 & ePos)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpUpToMSec(Handle handle, float move_msec, const math::Vec3 & ePos)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpToMSec_EventFall(Handle handle, float move_msec, const math::Vec3 & ePos=chr::JUMP_STAY_POS, float _height=0.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpToMSec_FreeFall(Handle handle, float move_msec, const math::Vec3 & ePos=chr::JUMP_STAY_POS, float _height=0.0f, bool _safety_abyss=true)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpToMSec(Handle handle, float move_msec, const math::Vec3 & ePos=chr::JUMP_STAY_POS, float _height=0.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpFallTo_EventFall(Handle handle, math::Vec3 & ePos)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpFallTo_FreeFall(Handle handle, math::Vec3 & ePos, bool _safety_abyss=true)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpFallTo(Handle handle, math::Vec3 & ePos)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpUpTo(Handle handle, math::Vec3 & ePos)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpTo_Speed_EventFall(Handle handle, math::Vec3 & ePos=chr::JUMP_STAY_POS, float _height=0.0f, float speed = 0.3f)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpTo_Speed_FreeFall_SafetyAbyss_ColIgnoreFlag(Handle handle, math::Vec3 & ePos=chr::JUMP_STAY_POS, float _height=0.0f, float speed = 0.3f, bool _safety_y_dist_abyss=true, bool _safety_y_dist_abyss=false, float abyss_y_dist=1000, float abyss_y=-1000, as_u64 ignore_flag=hit::COL_FLAG_IGNORE_NPC_MASK)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpTo_Speed_FreeFall(Handle handle, math::Vec3 & ePos=chr::JUMP_STAY_POS, float _height=0.0f, float speed = 0.3f, bool _safety_abyss=true)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpTo_Speed(Handle handle, math::Vec3 & ePos=chr::JUMP_STAY_POS, float _height=0.0f, float speed = 0.3f)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpTo_EventFall(Handle handle, math::Vec3 & ePos=chr::JUMP_STAY_POS, float _height=0.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpTo_FreeFall(Handle handle, math::Vec3 & ePos=chr::JUMP_STAY_POS, float _height=0.0f, bool _safety_abyss=true)"
    },
    {
      "namespace": "chr",
      "declaration": "void JumpTo(Handle handle, math::Vec3 & ePos=chr::JUMP_STAY_POS, float _height=0.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailToSpeed_Height_Anime(Handle handle, s32 &work, f32 move_speed, Handle target, f32 trail_r, string walkAnime, string runAnime, string stayAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailToSpeed_Height(Handle handle, s32 &work, f32 move_speed, Handle target, f32 trail_r)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailToSpeed_Height_Anime(Handle handle, s32 &work, f32 move_speed, const math::Vec3& pos, f32 trail_r, string walkAnime, string runAnime, string stayAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailToSpeed_Height(Handle handle, s32 &work, f32 move_speed, const math::Vec3& pos, f32 trail_r)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailToSpeed_Anime(Handle handle, s32 &work, f32 move_speed, Handle target, f32 trail_r, string walkAnime, string runAnime, string stayAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailToSpeed(Handle handle, s32 &work, f32 move_speed, Handle target, f32 trail_r)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailToSpeed_Anime(Handle handle, s32 &work, f32 move_speed, const math::Vec3& pos, f32 trail_r, string walkAnime, string runAnime, string stayAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailToSpeed(Handle handle, s32 &work, f32 move_speed, const math::Vec3& pos, f32 trail_r)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailTo_Height_Anime(Handle handle, s32 &work, Handle target, f32 trail_r, string walkAnime, string runAnime, string stayAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailTo_Height(Handle handle, s32 &work, Handle target, f32 trail_r)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailTo_Height_Anime(Handle handle, s32 &work, const math::Vec3& pos, f32 trail_r, string walkAnime, string runAnime, string stayAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailTo_Height(Handle handle, s32 &work, const math::Vec3& pos, f32 trail_r)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailTo_Anime(Handle handle, s32 &work, Handle target, f32 trail_r, string walkAnime, string runAnime, string stayAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailTo(Handle handle, s32 &work, Handle target, f32 trail_r)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailTo_Anime(Handle handle, s32 &work, const math::Vec3& pos, f32 trail_r, string walkAnime, string runAnime, string stayAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "bool TrailTo(Handle handle, s32 &work, const math::Vec3& pos, f32 trail_r)"
    },
    {
      "namespace": "chr",
      "declaration": "bool CheckStalledTrail(Handle handle, s32 &work)"
    },
    {
      "namespace": "chr",
      "declaration": "void InitTrail(Handle handle, s32 &work)"
    },
    {
      "namespace": "chr",
      "declaration": "void WalkDistanceMSec_Anime(Handle handle, float move_msec, float dist, string walkAnime, string runAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void WalkDistanceMSec(Handle handle, float move_msec, float dist)"
    },
    {
      "namespace": "chr",
      "declaration": "void WalkDistance_Anime(Handle handle, float dist, string walkAnime, string runAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void WalkDistance(Handle handle, float dist)"
    },
    {
      "namespace": "chr",
      "declaration": "void WalkToMSec_Height_Anime(Handle handle, float move_msec, const math::Vec3& pos, string walkAnime, string runAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void WalkToMSec_Height(Handle handle, float move_msec, const math::Vec3& pos)"
    },
    {
      "namespace": "chr",
      "declaration": "void WalkToMSec_Anime(Handle handle, float move_msec, math::Vec3 pos, string walkAnime, string runAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void WalkToMSec(Handle handle, float move_msec, math::Vec3 pos)"
    },
    {
      "namespace": "chr",
      "declaration": "void WalkTo_Height_Anime(Handle handle, const math::Vec3& pos, string walkAnime, string runAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void WalkTo_Height(Handle handle, const math::Vec3& pos)"
    },
    {
      "namespace": "chr",
      "declaration": "void WalkTo_Anime(Handle handle, const math::Vec3& pos, string walkAnime, string runAnime, bool always_walk = false)"
    },
    {
      "namespace": "chr",
      "declaration": "void WalkTo(Handle handle, const math::Vec3& pos)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ_Speed(Handle handle, const math::Vec3 & pos, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ_Speed(Handle handle, const math::Vec3 & pos, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ_Speed(Handle handle, const math::Vec3 & pos, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ_Speed(Handle handle, const math::Vec3 & pos, s32 type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ(Handle handle, const math::Vec3 & pos, f32 msec, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ(Handle handle, const math::Vec3 & pos, f32 msec, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ(Handle handle, const math::Vec3 & pos, f32 msec, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ(Handle handle, const math::Vec3 & pos, f32 msec=0.0f, s32 type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ_Speed(Handle handle, f32 tx, f32 tz, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ_Speed(Handle handle, f32 tx, f32 tz, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ_Speed(Handle handle, f32 tx, f32 tz, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ_Speed(Handle handle, f32 tx, f32 tz, s32 type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ(Handle handle, f32 tx, f32 tz, f32 msec, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ(Handle handle, f32 tx, f32 tz, f32 msec, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ(Handle handle, f32 tx, f32 tz, f32 msec, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosXZ(Handle handle, f32 tx, f32 tz, f32 msec=0.0f, s32 type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosZ_Speed(Handle handle, f32 tz, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosZ_Speed(Handle handle, f32 tz, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosZ_Speed(Handle handle, f32 tz, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosZ_Speed(Handle handle, f32 tz, int type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosZ(Handle handle, f32 tz, f32 msec, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosZ(Handle handle, f32 tz, f32 msec, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosZ(Handle handle, f32 tz, f32 msec, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosZ(Handle handle, f32 tz, f32 msec=0.0f, int type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosY_Speed(Handle handle, f32 ty, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosY_Speed(Handle handle, f32 ty, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosY_Speed(Handle handle, f32 ty, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosY_Speed(Handle handle, f32 ty, int type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosY(Handle handle, f32 ty, f32 msec, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosY(Handle handle, f32 ty, f32 msec, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosY(Handle handle, f32 ty, f32 msec, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosY(Handle handle, f32 ty, f32 msec=0.0f, int type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosX_Speed(Handle handle, f32 tx, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosX_Speed(Handle handle, f32 tx, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosX_Speed(Handle handle, f32 tx, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosX_Speed(Handle handle, f32 tx, int type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosX(Handle handle, f32 tx, f32 msec, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosX(Handle handle, f32 tx, f32 msec, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosX(Handle handle, f32 tx, f32 msec, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePosX(Handle handle, f32 tx, f32 msec=0.0f, int type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos_Speed(Handle handle, const math::Vec3 & pos, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos_Speed(Handle handle, const math::Vec3 & pos, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos_Speed(Handle handle, const math::Vec3 & pos, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos_Speed(Handle handle, const math::Vec3 & pos, s32 type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos(Handle handle, const math::Vec3 & pos, f32 msec, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos(Handle handle, const math::Vec3 & pos, f32 msec, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos(Handle handle, const math::Vec3 & pos, f32 msec, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos(Handle handle, const math::Vec3 & pos, f32 msec=0.0f, s32 type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos_Speed(Handle handle, f32 tx, f32 ty, f32 tz, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos_Speed(Handle handle, f32 tx, f32 ty, f32 tz, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos_Speed(Handle handle, f32 tx, f32 ty, f32 tz, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos_Speed(Handle handle, f32 tx, f32 ty, f32 tz, int type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos(Handle handle, f32 tx, f32 ty, f32 tz, f32 msec, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos(Handle handle, f32 tx, f32 ty, f32 tz, f32 msec, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos(Handle handle, f32 tx, f32 ty, f32 tz, f32 msec, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "chr",
      "declaration": "void MovePos(Handle handle, f32 tx, f32 ty, f32 tz, f32 msec=0.0f, int type=math::MOVE_TYPE_LINEAR, f32 pow=1.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetRunSpeed(Handle handle, f32 spd)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetRunSpeed(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetVelocity(Handle handle, const math::Vec3& v)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetVelocity(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAccelSpeed(Handle handle, f32 spd)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetAccelSpeed(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetMoveSpeed(Handle handle, f32 spd)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetMoveSpeed(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAccessSize(Handle handle, math::Vec3 v)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetAccessSize(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetAccessDepth(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetAccessHeight(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetAccessWidth(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAccessAngle(Handle handle, f32 angle_range)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAccessOffsetPos(Handle handle, math::Vec3 v)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetAccessOffsetPosZ(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetAccessOffsetPosY(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "as_f32 GetAccessOffsetPosX(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 GetAccessOffsetPos(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableAccessRange( Handle handle )"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableAccessRange( Handle handle )"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAccessRangePlus( Handle handle, float plus_range )"
    },
    {
      "namespace": "chr",
      "declaration": "bool IsEnableEventPull(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableEventPull(Handle handle)"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableEventPull(Handle handle, int pull_msec, int pull_recover_msec = 0)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAccessLimit(Handle handle, float dir, float range = 180.0f)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAccessBalloonDir(Handle handle, int balloon_dir)"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAccessBalloonOffsHeight( Handle handle, float offs_height )"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAccessBalloonOffsRate( Handle handle, float offs_rate )"
    },
    {
      "namespace": "chr",
      "declaration": "void SetAccessBalloonType(Handle handle, s32 balloon_type, s32 action_type = chr::AccessType_Auto)"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableAccess( Handle handle )"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableAccess( Handle handle )"
    },
    {
      "namespace": "chr",
      "declaration": "void CreateAccess( Handle handle )"
    },
    {
      "namespace": "chr",
      "declaration": "void SetWindRotScale( Handle handle, float scale )"
    },
    {
      "namespace": "chr",
      "declaration": "void SetWindRotSpeed( Handle handle, float speed )"
    },
    {
      "namespace": "chr",
      "declaration": "void SetWindRotType( Handle handle, const string& rot_type )"
    },
    {
      "namespace": "chr",
      "declaration": "void DisableWind( Handle handle, float fade_msec )"
    },
    {
      "namespace": "chr",
      "declaration": "void EnableWind( Handle handle, float fade_msec )"
    },
    {
      "namespace": "sobj",
      "declaration": "Handle GetHandle(const string& name)"
    },
    {
      "namespace": "lobj",
      "declaration": "Handle GetHandle(const string& name)"
    },
    {
      "namespace": "mobj",
      "declaration": "Handle GetHandle(const string& name)"
    },
    {
      "namespace": "gmap",
      "declaration": "Handle GetHandle()"
    },
    {
      "namespace": "item",
      "declaration": "Handle GetHandle(const string& name)"
    },
    {
      "namespace": "navigator",
      "declaration": "Handle GetHandle()"
    },
    {
      "namespace": "party",
      "declaration": "Handle GetHandle(const string& name)"
    },
    {
      "namespace": "hariko",
      "declaration": "Handle GetHandle(const string& name)"
    },
    {
      "namespace": "npc",
      "declaration": "Handle GetHandle(const string& name)"
    },
    {
      "namespace": "player",
      "declaration": "Handle GetHandle()"
    },
    {
      "namespace": "chr",
      "declaration": "Handle GetHandle(const string& name)"
    },
    {
      "namespace": "cases",
      "declaration": "void Kill(ObjHandle handle)"
    },
    {
      "namespace": "cases",
      "declaration": "void SetAccessBalloonOffset(ObjHandle handle, math::Vec3 offset)"
    },
    {
      "namespace": "cases",
      "declaration": "void EnableFlag(ObjHandle handle, int flag)"
    },
    {
      "namespace": "cases",
      "declaration": "void EnableFlag(const ::string& name, int flag)"
    },
    {
      "namespace": "cases",
      "declaration": "void Uncancel(ObjHandle handle)"
    },
    {
      "namespace": "cases",
      "declaration": "void Uncancel(const ::string& name, const ::string& func_name=string())"
    },
    {
      "namespace": "cases",
      "declaration": "void Uncancel(const ::string& name, const any& class_obj, const ::string& func_name=string())"
    },
    {
      "namespace": "cases",
      "declaration": "void Cancel(ObjHandle handle)"
    },
    {
      "namespace": "cases",
      "declaration": "void Cancel(::string& name, ::string& func_name=string())"
    },
    {
      "namespace": "cases",
      "declaration": "void Cancel(::string& name, const any& class_obj, ::string& func_name=string())"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHoleFallArg(const ::string& name, const ::string& hole_name, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHoleFallArg(const ::string& name, const ::string& hole_name, const any& class_obj, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHoleFall(const ::string& name, const ::string& hole_name, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHoleFall(const ::string& name, const ::string& hole_name, const any& class_obj, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHoleFallArg(const ::string& name, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHoleFallArg(const ::string& name, const any& class_obj, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHoleFall(const ::string& name, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHoleFall(const ::string& name, const any& class_obj, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "void ResetVariableIsTrue(ObjHandle handle)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrueArg(const ::string& name, const ::string& func_name, any& arg, GetterVariableIsTrueCallback_Const ref getter)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrueArg(const string& name, const any& class_obj, const string& func_name, any& arg, GetterVariableIsTrueCallback_Const ref getter)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrue(const ::string& name, const ::string& func_name, GetterVariableIsTrueCallback_Const ref getter)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrue(const string& name, const any& class_obj, const string& func_name, GetterVariableIsTrueCallback_Const ref getter)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrueArg(const ::string& name, const ::string& func_name, any& arg, GetterVariableIsTrueCallback ref getter)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrueArg(const string& name, const any& class_obj, const string& func_name, any& arg, GetterVariableIsTrueCallback ref getter)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrue(const ::string& name, const ::string& func_name, GetterVariableIsTrueCallback ref getter)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrue(const string& name, const any& class_obj, const string& func_name, GetterVariableIsTrueCallback ref getter)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrueArg(const ::string& name, const ::string& func_name, any& arg, as::Variable& flag)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrueArg(const string& name, const any& class_obj, const string& func_name, any& arg, as::Variable& flag)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrue(const ::string& name, const ::string& func_name, as::Variable& flag)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrue(const string& name, const any& class_obj, const string& func_name, as::Variable& flag)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrueArg(const ::string& name, const ::string& func_name, any& arg, bool& flag)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrueArg(const string& name, const any& class_obj, const string& func_name, any& arg, bool& flag)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrue(const ::string& name, const ::string& func_name, bool& flag)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryVariableIsTrue(const string& name, const any& class_obj, const string& func_name, bool& flag)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryAreaOutArg (const ::string& name, const ::string& hit_name, const ::string& func_name, any& arg, int hit_place=-1)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryAreaOutArg (const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, any& arg, int hit_place=-1)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryAreaOut (const ::string& name, const ::string& hit_name, const ::string& func_name, int hit_place=-1)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryAreaOut (const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, int hit_place=-1)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryAreaInArg (const ::string& name, const ::string& hit_name, const ::string& func_name, any& arg, int hit_place=-1)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryAreaInArg (const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, any& arg, int hit_place=-1)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryAreaIn (const ::string& name, const ::string& hit_name, const ::string& func_name, int hit_place=-1)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryAreaIn (const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, int hit_place=-1)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallPartyArg(const string& name, const string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallPartyArg(const string& name, const any& class_obj, const string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallParty(const string& name, const string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallParty(const string& name, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallReturnArg(const string& name, const string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallReturnArg(const string& name, const any& class_obj, const string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallReturn(const string& name, const string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallReturn(const string& name, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallMapArg(const string& name, const string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallMapArg(const string& name, const any& class_obj, const string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallMap(const string& name, const string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallMap(const string& name, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallNaviArg(const string& name, const string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallNaviArg(const string& name, const any& class_obj, const string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallNavi(const string& name, const string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryCallNavi(const string& name, const any& class_obj, const string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHoleRepairArg(const ::string& name, const ::string& hole_dispos_name, const ::string& func_name, any& arg, bool wait_complete=true)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHoleRepairArg(const ::string& name, const ::string& hole_dispos_name, const any& class_obj, const ::string& func_name, any& arg, bool wait_complete=true)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHoleRepair(const ::string& name, const ::string& hole_dispos_name, const ::string& func_name, bool wait_complete=true)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHoleRepair(const ::string& name, const ::string& hole_dispos_name, const any& class_obj, const ::string& func_name, bool wait_complete=true)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryPlayerPressedArg(const ::string& name, const ::string& hit_name, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryPlayerPressedArg(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryPlayerPressed(const ::string& name, const ::string& hit_name, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryPlayerPressed(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryPlayerCrushedArg(const ::string& name, const ::string& hit_name, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryPlayerCrushedArg(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryPlayerCrushed(const ::string& name, const ::string& hit_name, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryPlayerCrushed(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryNpcOtherTalkArg(const ::string& name, npc::Handle talk_npc, const ::string& target_name, int hit_place, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryNpcOtherTalkArg(const ::string& name, npc::Handle talk_npc, const ::string& target_name, int hit_place, const any& class_obj, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryNpcOtherTalk(const ::string& name, npc::Handle talk_npc, const ::string& target_name, int hit_place, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryNpcOtherTalk(const ::string& name, npc::Handle talk_npc, const ::string& target_name, int hit_place, const any& class_obj, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryNpcOtherTalkArg(const ::string& name, npc::Handle talk_npc, chr::Handle target_chr, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryNpcOtherTalkArg(const ::string& name, npc::Handle talk_npc, chr::Handle target_chr, const any& class_obj, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryNpcOtherTalk(const ::string& name, npc::Handle talk_npc, chr::Handle target_chr, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryNpcOtherTalk(const ::string& name, npc::Handle talk_npc, chr::Handle target_chr, const any& class_obj, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryAccessArg(const ::string& name, const ::string& hit_name, const ::string& func_name, any& arg, s32 balloon_type=chr::BalloonType_access, s32 hit_place=hit::HIT_PLACE_FRONT)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryAccessArg(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, any& arg, s32 balloon_type=chr::BalloonType_access, s32 hit_place=hit::HIT_PLACE_FRONT)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryAccess(const ::string& name, const ::string& hit_name, const ::string& func_name, s32 balloon_type=chr::BalloonType_access, s32 hit_place=hit::HIT_PLACE_FRONT)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryAccess(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, s32 balloon_type=chr::BalloonType_access, s32 hit_place=hit::HIT_PLACE_FRONT)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryMapReleaseArg(const ::string& name, const ::string& hit_name, const ::string& func_name, any& arg, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryMapReleaseArg(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, any& arg, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryMapRelease(const ::string& name, const ::string& hit_name, const ::string& func_name, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryMapRelease(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryReleaseArg(const ::string& name, const ::string& hit_name, const ::string& func_name, any& arg, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryReleaseArg(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, any& arg, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryRelease(const ::string& name, const ::string& hit_name, const ::string& func_name, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryRelease(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHitBodyArg(const ::string& name, const ::string& hit_name, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHitBodyArg(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHitBody(const ::string& name, const ::string& hit_name, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHitBody(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryMapHitArg(const ::string& name, const ::string& hit_name, const ::string& func_name, any& arg, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryMapHitArg(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, any& arg, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryMapHit(const ::string& name, const ::string& hit_name, const ::string& func_name, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryMapHit(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHitArg(const ::string& name, const ::string& hit_name, const ::string& func_name, any& arg, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHitArg(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, any& arg, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHit(const ::string& name, const ::string& hit_name, const ::string& func_name, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle EntryHit(const ::string& name, const ::string& hit_name, const any& class_obj, const ::string& func_name, int hit_place)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle DbgEntryTestArg(const ::string& name, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle DbgEntryTestArg(const ::string& name, const any& class_obj, const ::string& func_name, any& arg)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle DbgEntryTest(const ::string& name, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle DbgEntryTest(const ::string& name, const any& class_obj, const ::string& func_name)"
    },
    {
      "namespace": "cases",
      "declaration": "ObjHandle GetHandle(const string& name)"
    },
    {
      "namespace": "cam",
      "declaration": "void MainProcess()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetScreenToWorldPos(const math::Vec3& screen, chr::Handle handle, const math::Vec3& offset, as_f32 scale )"
    },
    {
      "namespace": "cam",
      "declaration": "bool IsScreenPosNoEft(const math::Vec3& world)"
    },
    {
      "namespace": "cam",
      "declaration": "bool IsScreenPos(const math::Vec3& world)"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetScreenPosNoEft(const math::Vec3& world)"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetScreenPosNoEft(const math::Vec3& world, bool& result)"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetScreenPos(const math::Vec3& world)"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetScreenPos(const math::Vec3& world, bool& result)"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetResultProjectionFar()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetResultProjectionNear()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetResultProjectionFovyRad()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetResultProjectionFovyDeg()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetResultViewExtTargetRotDegOffset(void)"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetResultViewExtTargetDistanceScale(as_f32 scale)"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetResultViewExtPosOffset(math::Vec3 offset)"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetResultViewTargetDistance()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetResultViewTargetRotRad()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetResultViewTargetRotDeg()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetResultViewRotRad()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetResultViewRotDeg()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetResultViewTwistRad()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetResultViewTwistDeg()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetResultViewUp()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetResultViewAt()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetResultViewEye()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetResultRoll()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetResultDirFoward()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetResultDirRight()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetResultDir()"
    },
    {
      "namespace": "cam",
      "declaration": "void ForceUpdatePera()"
    },
    {
      "namespace": "cam",
      "declaration": "void WaitChangeMove()"
    },
    {
      "namespace": "cam",
      "declaration": "void WaitChangeState()"
    },
    {
      "namespace": "cam",
      "declaration": "bool IsChangeState()"
    },
    {
      "namespace": "cam",
      "declaration": "void PeriodState_Step(as_f32 changeStep, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "cam",
      "declaration": "void PeriodState_Step(as_f32 changeStep, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "cam",
      "declaration": "void PeriodState_Step(as_f32 changeStep, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "cam",
      "declaration": "void PeriodState_Step(as_f32 changeStep, u32 channel=math::MOVE_TYPE_SIN, as_f32 moveTypePow=1.0f)"
    },
    {
      "namespace": "cam",
      "declaration": "void PeriodState_Msec(as_f32 changeMsec, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "cam",
      "declaration": "void PeriodState_Msec(as_f32 changeMsec, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "cam",
      "declaration": "void PeriodState_Msec(as_f32 changeMsec, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "cam",
      "declaration": "void PeriodState_Msec(as_f32 changeMsec, u32 channel=math::MOVE_TYPE_SIN, as_f32 moveTypePow=1.0f)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Step(::string stateName, as_f32 changeStep, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Step(::string stateName, as_f32 changeStep, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Step(::string stateName, as_f32 changeStep, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Step(::string stateName, as_f32 changeStep, u32 channel=math::MOVE_TYPE_SIN, as_f32 moveTypePow=1.0f)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Msec(::string stateName, as_f32 changeMsec, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Msec(::string stateName, as_f32 changeMsec, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Msec(::string stateName, as_f32 changeMsec, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Msec(::string stateName, as_f32 changeMsec, u32 channel=math::MOVE_TYPE_SIN, as_f32 moveTypePow=1.0f)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Step(int stateLevel, as_f32 changeStep, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Step(int stateLevel, as_f32 changeStep, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Step(int stateLevel, as_f32 changeStep, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Step(int stateLevel, as_f32 changeStep, u32 moveType=math::MOVE_TYPE_SIN, as_f32 moveTypePow=1.0f)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Msec(int stateLevel, as_f32 changeMsec, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Msec(int stateLevel, as_f32 changeMsec, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Msec(int stateLevel, as_f32 changeMsec, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "cam",
      "declaration": "void RevertState_Msec(int stateLevel, as_f32 changeMsec, u32 moveType=math::MOVE_TYPE_SIN, as_f32 moveTypePow=1.0f)"
    },
    {
      "namespace": "cam",
      "declaration": "void PopState_Step(as_f32 changeStep, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "cam",
      "declaration": "void PopState_Step(as_f32 changeStep, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "cam",
      "declaration": "void PopState_Step(as_f32 changeStep, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "cam",
      "declaration": "void PopState_Step(as_f32 changeStep, u32 moveType=math::MOVE_TYPE_SIN, as_f32 moveTypePow=1.0f)"
    },
    {
      "namespace": "cam",
      "declaration": "void PopState_Msec(as_f32 changeMsec, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "cam",
      "declaration": "void PopState_Msec(as_f32 changeMsec, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "cam",
      "declaration": "void PopState_Msec(as_f32 changeMsec, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "cam",
      "declaration": "void PopState_Msec(as_f32 changeMsec, u32 moveType=math::MOVE_TYPE_SIN, as_f32 moveTypePow=1.0f)"
    },
    {
      "namespace": "cam",
      "declaration": "void PushState_Step(as_f32 changeStep, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "cam",
      "declaration": "void PushState_Step(as_f32 changeStep, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "cam",
      "declaration": "void PushState_Step(as_f32 changeStep, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "cam",
      "declaration": "void PushState_Step(as_f32 changeStep=0.0f, u32 moveType=math::MOVE_TYPE_SIN, as_f32 moveTypePow=1.0f)"
    },
    {
      "namespace": "cam",
      "declaration": "void PushState_Msec(as_f32 changeMsec, math::bezier::EasingParam& bezier)"
    },
    {
      "namespace": "cam",
      "declaration": "void PushState_Msec(as_f32 changeMsec, array<math::bezier::EasingParam>& bezier_array)"
    },
    {
      "namespace": "cam",
      "declaration": "void PushState_Msec(as_f32 changeMsec, math::RoundedNonuniformSpline& rns)"
    },
    {
      "namespace": "cam",
      "declaration": "void PushState_Msec(as_f32 changeMsec=0.0f, u32 moveType=math::MOVE_TYPE_SIN, as_f32 moveTypePow=1.0f)"
    },
    {
      "namespace": "cam",
      "declaration": "void ClearProjectionZoom( void )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetProjectionZoom(as_f32 centerX, as_f32 centerY, as_f32 scale, as_f32 alpha, bool clipping )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetProjectionFar(as_f32 v)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetProjectionNear(as_f32 v)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetProjectionFovyRad(as_f32 rad)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetProjectionFovyDeg(as_f32 deg)"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetProjectionZoomAlpha( void )"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetProjectionZoomScale( void )"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetProjectionZoomCenterY( void )"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetProjectionZoomCenterX( void )"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetProjectionFar()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetProjectionNear()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetProjectionFovyRad()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetProjectionFovyDeg()"
    },
    {
      "namespace": "cam",
      "declaration": "void CalcViewTargetRad()"
    },
    {
      "namespace": "cam",
      "declaration": "void CalcViewTargetDeg()"
    },
    {
      "namespace": "cam",
      "declaration": "void CalcViewRotCamRad()"
    },
    {
      "namespace": "cam",
      "declaration": "void CalcViewRotCamDeg()"
    },
    {
      "namespace": "cam",
      "declaration": "void CalcViewAimRad()"
    },
    {
      "namespace": "cam",
      "declaration": "void CalcViewAimDeg()"
    },
    {
      "namespace": "cam",
      "declaration": "void CalcViewLookAt()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewExtTargetRotDegOffset(math::Vec3 offsetDeg)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewExtTargetDistanceScale(as_f32 scale)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewExtPosOffset(math::Vec3 offset)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewTargetDistance(as_f32 distance)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewTargetRotRad(math::Vec3 rad)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewTargetRotDeg(math::Vec3 deg)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewRotRad(math::Vec3 rad)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewRotDeg(math::Vec3 deg)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewTwistRad(as_f32 rad)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewTwistDeg(as_f32 deg)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewUp(math::Vec3 up)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewAt(math::Vec3 at)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewEye(math::Vec3 eye)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewTargetRad( const math::Vec3 at, const math::Vec3 targetRotRad, as_f32 targetDistance )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewTargetDeg( const math::Vec3 at, const math::Vec3 targetRotDeg, as_f32 targetDistance )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewRotCamRad( const math::Vec3 eye, const math::Vec3 rotRad )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewRotCamDeg( const math::Vec3 eye, const math::Vec3 rotDeg )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewAimRad( const math::Vec3 eye, const math::Vec3 at, as_f32 twistRad )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewAimDeg( const math::Vec3 eye, const math::Vec3 at, as_f32 twistDeg )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetViewLookAt( const math::Vec3 eye, const math::Vec3 up, const math::Vec3 at )"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetViewExtTargetRotDegOffset(void)"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetViewExtTargetDistanceScale()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetViewExtPosOffset()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetViewTargetDistance()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetViewTargetRotRad()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetViewTargetRotDeg()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetRotRad()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetRotDeg()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetViewTwistRad()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetViewTwistDeg()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetViewUp()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetViewAt()"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetViewEye()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetAnim(chr::Handle asChrHandle, int animIdx=0, ::string sceneAnimCameraName=\"\")"
    },
    {
      "namespace": "cam",
      "declaration": "void UseAnim(bool use)"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetListenerPos()"
    },
    {
      "namespace": "cam",
      "declaration": "void EnableListener()"
    },
    {
      "namespace": "cam",
      "declaration": "void MoveListener( as_f32 x0, as_f32 y0, as_f32 z0, as_f32 x1, as_f32 y1, as_f32 z1, as_f32 ms, int type )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetModeDefaultAlwaysHomingPlayer(bool v)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetListenerMode_FixXYZ( as_f32 x, as_f32 y, as_f32 z )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetListenerMode_NearXZ( as_f32 x, as_f32 z )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetListenerMode_Scale( as_f32 scale )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetListenerMode_HomingY()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetListenerMode_Default()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetMayaParam_old(as_f32 x, as_f32 y, as_f32 z, as_f32 rx, as_f32 ry, as_f32 rz, as_f32 fovy=0.0f, as_f32 near=0.0f, as_f32 far=0.0f)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetMayaParam(as_f32 x, as_f32 y, as_f32 z, as_f32 rx, as_f32 ry, as_f32 rz, as_f32 fovy=0.0f, as_f32 near=0.0f, as_f32 far=0.0f)"
    },
    {
      "namespace": "cam",
      "declaration": "bool IsUseShiftY()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetUseShiftY(bool v)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetShiftYMaxAccel(float v)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetShiftYMaxSpeed(float v)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetShiftYReserveCount(float v)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetShiftYRateZScale(float v)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetShiftYRate(float v)"
    },
    {
      "namespace": "cam",
      "declaration": "float GetShiftYMaxAccel()"
    },
    {
      "namespace": "cam",
      "declaration": "float GetShiftYMaxSpeed()"
    },
    {
      "namespace": "cam",
      "declaration": "float GetShiftYReserveCount()"
    },
    {
      "namespace": "cam",
      "declaration": "float GetShiftYRateZScale()"
    },
    {
      "namespace": "cam",
      "declaration": "float GetShiftYRate()"
    },
    {
      "namespace": "cam",
      "declaration": "void ResetShiftTranslateY()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetAutoCenteringShiftTranslateY(bool v)"
    },
    {
      "namespace": "cam",
      "declaration": "bool IsAutoCenteringShiftTranslateY()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetUseShiftTranslateY(bool v)"
    },
    {
      "namespace": "cam",
      "declaration": "bool IsUseShiftTranslateY()"
    },
    {
      "namespace": "cam",
      "declaration": "bool IsUseShiftX()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetUseShiftX(bool v)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetShiftXMaxAccel(float v)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetShiftXMaxSpeed(float v)"
    },
    {
      "namespace": "cam",
      "declaration": "void SetShiftXReserveCount(float v)"
    },
    {
      "namespace": "cam",
      "declaration": "float GetShiftXMaxAccel()"
    },
    {
      "namespace": "cam",
      "declaration": "float GetShiftXMaxSpeed()"
    },
    {
      "namespace": "cam",
      "declaration": "float GetShiftXReserveCount()"
    },
    {
      "namespace": "cam",
      "declaration": "void ResetShiftTranslateX()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetAutoCenteringShiftTranslateX(bool v)"
    },
    {
      "namespace": "cam",
      "declaration": "bool IsAutoCenteringShiftTranslateX()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetUseShiftTranslateX(bool v)"
    },
    {
      "namespace": "cam",
      "declaration": "bool IsUseShiftTranslateX()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetIgnoreCompOnce()"
    },
    {
      "namespace": "cam",
      "declaration": "as_f32 GetCurrentCompRate()"
    },
    {
      "namespace": "cam",
      "declaration": "::string GetCurrentCompEndRoadCurveName()"
    },
    {
      "namespace": "cam",
      "declaration": "::string GetCurrentCompStartRoadCurveName()"
    },
    {
      "namespace": "cam",
      "declaration": "::string GetCurrentRoadCurveName()"
    },
    {
      "namespace": "cam",
      "declaration": "void ResetCameraTarget(chr::Handle chr_handle = player::GetHandle())"
    },
    {
      "namespace": "cam",
      "declaration": "void RoadReset(bool callResetCameraTarget, bool recoverPlaySearch)"
    },
    {
      "namespace": "cam",
      "declaration": "void RoadReset(bool callResetCameraTarget = true)"
    },
    {
      "namespace": "cam",
      "declaration": "math::Vec3 GetRoadTargetPos( void )"
    },
    {
      "namespace": "cam",
      "declaration": "void SetRoadTargetPos( math::Vec3 &pos )"
    },
    {
      "namespace": "cam",
      "declaration": "chr::Handle GetRoadTargetChr()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetRoadTargetChr(chr::Handle chr)"
    },
    {
      "namespace": "cam",
      "declaration": "void UseRoad(bool use)"
    },
    {
      "namespace": "cam",
      "declaration": "::string GetStateName()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetStateName(::string name)"
    },
    {
      "namespace": "cam",
      "declaration": "int GetStateLevel()"
    },
    {
      "namespace": "cam",
      "declaration": "void SetCharacterBlendPhase(chr::Handle handle)"
    },
    {
      "namespace": "cam",
      "declaration": "void StopShake(u32 channel=0)"
    },
    {
      "namespace": "cam",
      "declaration": "void StartShake_Msec(as_f32 w, as_f32 h, as_f32 msec, u32 channel=0)"
    },
    {
      "namespace": "cam",
      "declaration": "void StartShake_Step(as_f32 w, as_f32 h, as_f32 steps, u32 channel=0)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "string GetCaption(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsAttackAttrGodHand(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsAttackAttrMagicIce(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsAttackAttrMagicFire(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsAttackAttrMagicWater(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsAttackAttrMagicEarth(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsAttackAttrBeast(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsAttackAttrBullet(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsAttackAttrPoiHammer(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsAttackAttrHammer(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsAttackAttrJump(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetDamageTypeNoEvent(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetOrgRndAP(const PartsHandle& handle, as_s32 aclv)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetRndAP(const PartsHandle& handle, as_s32 aclv)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetRndAP(const PartsHandle& handle, as_s32 aclv, as_s32 val)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetOrgAP(const PartsHandle& handle, as_s32 aclv)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetAP(const PartsHandle& handle, as_s32 aclv)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetAP(const PartsHandle& handle, as_s32 aclv, as_s32 val)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetOrgRndAP(const UnitHandle& handle, as_s32 aclv)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetRndAP(const UnitHandle& handle, as_s32 aclv)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void AddRndAP(const UnitHandle& handle, as_s32 aclv, as_s32 val)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetRndAP(const UnitHandle& handle, as_s32 aclv, as_s32 val)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetOrgAP(const UnitHandle& handle, as_s32 aclv)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetAP(const UnitHandle& handle, as_s32 aclv)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void AddAP(const UnitHandle& handle, as_s32 aclv, as_s32 val)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetAP(const UnitHandle& handle, as_s32 aclv, as_s32 val)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "string GetDamagedTypeArgStr(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetDamagedTypeArgInt(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s64 GetDamagedEffect(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsDamageLast(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsDamageNormal(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsDamageAttackAttrGodHand(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsDamageAttackAttrMagicIce(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsDamageAttackAttrMagicFire(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsDamageAttackAttrMagicWater(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsDamageAttackAttrMagicEarth(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsDamageAttackAttrBeast(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsDamageAttackAttrPoiHammer(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsDamageAttackAttrHammer(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsDamageAttackAttrJump(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetRealDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "string GetDamageID(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "PartsHandle GetDamageAngleParts(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "PartsHandle GetDamageParts(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "UnitHandle GetDamageUnit(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "PartsHandle GetDamageAttackParts(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "UnitHandle GetDamageAttackUnit(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "string GetDamageResultStr(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetDamageResult(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetAttackRealDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetAttackDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "string GetAttackResultStr(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "string GetAttackResultStr(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetAttackResult(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetAttackResult(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetAcType(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetAcType(const UnitHandle& handle, as_s32 type)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void ResetAcType(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetAcPower(const UnitHandle& handle, as_s32 lv)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetAcFrame(const UnitHandle& handle, as_s32 lv)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetAcLevel(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetAcLevel(const PartsHandle& handle, as_s32 lv)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void NextAcLevel(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void ResetAcLevel(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetAcLevel(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetAcLevel(const UnitHandle& handle, as_s32 lv)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void NextAcLevel(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void ResetAcLevel(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool CheckGuardAttack(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool CheckGuardAttack(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool CheckCounterAttack(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool CheckCounterAttack(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 LastAttack(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 LastAttack(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 NormalAttack(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 NormalAttack(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 PreAttack(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 PreAttack(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void UpdateEndurance(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 HasHitTarget(const UnitHandle& handle, const UnitHandle& target)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "bool IsHitTarget(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackPinchHomePosition(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackPinchPosition(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttack2ndHomePosition(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttack2ndPosition(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackLowHomePosition(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackLowPosition(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackHomePosition(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackPosition(const PartsHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackPinchHomePosition(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackPinchPosition(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttack2ndHomePosition(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttack2ndPosition(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackPoiHomePosition(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackPoiPosition(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackLowHomePosition(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackLowPosition(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackHomePosition(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "math::Vec3 GetTargetAttackPosition(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void GetTargetUnit(const PartsHandle& handle, as_s32 no, UnitHandle& t_uh, PartsHandle& t_uph)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void GetTargetUnit(const UnitHandle& handle, as_s32 no, UnitHandle& t_uh, PartsHandle& t_uph)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void GetTargetUnit(const PartsHandle& handle, as_s32 no, UnitHandle& t_uh)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void GetTargetUnit(const UnitHandle& handle, as_s32 no, UnitHandle& t_uh)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void GetHitTargetList(const UnitHandle& handle, array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetTargetNum(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "as_s32 GetTargetNum(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SortTargetNearOutSide(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SortTargetNearCenterSide(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SortTargetRandom(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SortTargetNear(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "int SelectHitTarget(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void Sampling(const UnitHandle& handle, const UnitHandle& t_uh, const PartsHandle& t_uph)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void Sampling(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void Sampling(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "string GetID(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void Change(const UnitHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void Copy(const UnitHandle& handle, const PartsHandle& parts)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetupNoAntiDamage(const PartsHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void Setup(const PartsHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetupCounterAntiDamage(const UnitHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetupCounter(const UnitHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetupDirBossNoAntiDamage(const UnitHandle& handle, const string& id, as_f32 dir)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetupDirBoss(const UnitHandle& handle, const string& id, as_f32 dir)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetupDirNoAntiDamage(const UnitHandle& handle, const string& id, as_f32 dir)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetupDir(const UnitHandle& handle, const string& id, as_f32 dir)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetupBossNoAntiDamage(const UnitHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetupBoss(const UnitHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void SetupNoAntiDamage(const UnitHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "void Setup(const UnitHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::util",
      "declaration": "bool CheckWin()"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetAudienceList(array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetPartyList(array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "math::Vec3 ConvertWorldToScreen(const math::Vec3 pos)"
    },
    {
      "namespace": "btl::util",
      "declaration": "bool IsBuddyHint()"
    },
    {
      "namespace": "btl::util",
      "declaration": "bool IsEnableBuddy()"
    },
    {
      "namespace": "btl::util",
      "declaration": "void WaitBusyBuddy()"
    },
    {
      "namespace": "btl::util",
      "declaration": "void ExitBuddy()"
    },
    {
      "namespace": "btl::util",
      "declaration": "void EnterBuddy()"
    },
    {
      "namespace": "btl::util",
      "declaration": "bool IsPlayerUsedMagicEarth()"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetTreasureHeartPanelList(array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "bool IsUnitOnRangePos(const RangePos& pos)"
    },
    {
      "namespace": "btl::util",
      "declaration": "bool IsPanelOnRangePos_Drop(const RangePos& pos)"
    },
    {
      "namespace": "btl::util",
      "declaration": "bool IsPanelOnRangePos(const RangePos& pos)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetPanelListOnRangePos(const RangePos& pos, array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "bool IsPanelOnHomeRangePos(RangePos pos)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetInvalidPanelList(array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetHoldPanelList(array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetPanelListOnHomeRangePos(const RangePos& pos, array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetPanelListOnRing(int32_t ringNo, array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetFixPanelList(array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetSpecialPanelList(array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetMagicPanelList(array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetPanelList(int32_t type, array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetPanelList(array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void DeleteObject(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void WaitEntryObject(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::util",
      "declaration": "UnitHandle EntryObject(const string& id)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void DeleteNpc(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void WaitEntryNpc(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::util",
      "declaration": "UnitHandle EntryNpc(const string& name, const string& id)"
    },
    {
      "namespace": "btl::util",
      "declaration": "UnitHandle EntryNpcSceneFade(const string& id)"
    },
    {
      "namespace": "btl::util",
      "declaration": "UnitHandle EntryNpc(const string& id)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void DeleteEnemyWithWait(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void DeleteEnemy(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void WaitEntryEnemy(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::util",
      "declaration": "UnitHandle EntryEnemy(const string& name, const string& id)"
    },
    {
      "namespace": "btl::util",
      "declaration": "UnitHandle EntryEnemy(const string& id)"
    },
    {
      "namespace": "btl::util",
      "declaration": "bool IsAliveUnit(const string& name)"
    },
    {
      "namespace": "btl::util",
      "declaration": "bool IsBusyEnemyScriptAttack()"
    },
    {
      "namespace": "btl::util",
      "declaration": "bool IsAliveUnit(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetEnemyListOnRangePos(const RangePos& pos, array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetEnemyListGroupUnitID(int group, const string& unit, array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetEnemyListGroup(int group, array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::util",
      "declaration": "void GetEnemyList(array<UnitHandle>& list, bool dead=false)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ResumeFuncEscapeJump(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void PauseFuncEscapeJump(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsStateWarawaraAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsStateDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsStateAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsStateIdle(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeStateDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeStateAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsBusyFuncEpisodeTalk(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsBusyScriptNoTouchPad(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsBusyFuncStartMoveRing(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsBusyFuncReturnHome(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsBusyFuncDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsBusyFuncDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsBusyFuncWeaponAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsBusyFuncAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncMoveHitSpecial(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncWarawaraAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncFormationAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncMessage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncReturnHome(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncWeaponAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncAnime(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncMain(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncExit(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitFuncEnter(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void StopFuncMessage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void StopFuncReturnHome(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void StopFuncDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void StopFuncAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void StopFuncAnime(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void StopFuncMain(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void StopFuncExit(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void StopFuncEnter(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncMoveHitSpecial(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitWaveBattleEncount(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncWaveBattleEncount(const UnitHandle& handle, const as::Variable& arg1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncWarawaraAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncFormationAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncMessage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncReturnHome(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncAttack(const UnitHandle& handle, const as::Variable& arg1, const as::Variable& arg2)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncAttack(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncAnime(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncMain(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncExit(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncEnter(const UnitHandle& handle, const as::Variable& arg1, const as::Variable& arg2)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncEnter(const UnitHandle& handle, const as::Variable& arg1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncEnter(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RunFuncPreEnter(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void MarioJumpPosMsec(const UnitHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir, as_s32 type)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void MarioJumpPos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir, as_s32 type)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void _MarioJumpPos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, as_s32 type)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void WaitWeaponScript(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void StopWeaponScript(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void RunWeaponScript(const PartsHandle& handle, const as::Variable& arg0=as::Variable(), const as::Variable& arg1=as::Variable())"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void WaitFuncAttack(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void StopFuncAttack(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void RunFuncAttack(const PartsHandle& handle, const as::Variable& arg0=as::Variable(), const as::Variable& arg1=as::Variable())"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_s32 GetBaseAnimeCh(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetBaseAnimeCh(const PartsHandle& handle, as_s32 ch)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetBlendCh(const PartsHandle& handle, as_s32 ch)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetBlendAnime(const PartsHandle& handle, float weight, int ch=-1)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsAnimeLoopTiming(const PartsHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsAnimeLooped(const PartsHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void WaitAnimeLoopTiming(const PartsHandle& parts, int ch=-1)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void WaitAnimeLooped(const PartsHandle& parts, int ch=-1)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetEndFrameAnime(const PartsHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetFrameAnime(const PartsHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetFrameAnime(const PartsHandle& handle, float frame, int ch=-1)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetSpeedAnime(const PartsHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetSpeedAnime(const PartsHandle& handle, float spd, int ch=-1)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void DestroyAnime(const PartsHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool ChangePoseForce(const PartsHandle& handle, const string& anime, int ch=-1, float blend=0.0f, bool gap=true)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool ChangePose(const PartsHandle& handle, const string& anime, int ch=-1, float blend=0.0f, bool gap=true)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool ChangeAnimeForce(const PartsHandle& handle, const string& anime, const string& next_anime, int ch=-1, float blend=0.0f)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool ChangeAnimeForce(const PartsHandle& handle, const string& anime, int ch=-1, float blend=0.0f)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool ChangeAnime(const PartsHandle& handle, const string& anime, const string& next_anime, int ch=-1, float blend=0.0f)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool ChangeAnime(const PartsHandle& handle, const string& anime, int ch=-1, float blend=0.0f)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ChangeAnimeState(const PartsHandle& handle, const string& anime)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "string GetAnime(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "string GetAnimeState(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void FlyPosMsec(const PartsHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type, bool syncAnime=true)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void FlyPos(const PartsHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type, bool syncAnime=true)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void _FlyPos(const PartsHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type, bool syncAnime)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void FallContinue(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void FallPosMsec(const PartsHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void FallPos(const PartsHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void _FallPos(const PartsHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void JumpPosMsec(const PartsHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void JumpPos(const PartsHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void _JumpPos(const PartsHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void MovePosMsec(const PartsHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir, bool syncAnime=true)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void MovePos(const PartsHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir, bool syncAnime=true)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void _MovePos(const PartsHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, bool syncAnime)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void _MovePos(const PartsHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, as_s32 type, bool syncAnime)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void Dir(const PartsHandle& handle, as_f32 dir, as_f32 msec)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void Rotate(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z, as_f32 msec)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ResetFallAcc(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetFallAcc(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetFallAcc(const PartsHandle& handle, as_f32 acc)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ResetOrgCursorPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ResetOrgAttackPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetStainEffectDirtAlpha(const PartsHandle& handle, f32 alpha)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetStainEffectWhiteAlpha(const PartsHandle& handle, f32 alpha)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetStainEffectWrinkleAlpha(const PartsHandle& handle, f32 alpha)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SunShadowOn(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SunShadowOff(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void DropShadowOn(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void DropShadowOff(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ShadowOn(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ShadowOff(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsDataShadowCheck(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetParamSoftRubber(const PartsHandle& handle, as_f32 rate, as_f32 speed, as_f32 fb)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetupSoftRubber(const PartsHandle& handle, as_f32 rate, as_f32 speed, as_f32 fb)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetTextUI(const PartsHandle& handle, const string& name, const string& msg)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetupUI(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void UpdateOptimizeModeNone(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void UpdateOptimizeModeFull(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void EnableSoundActor(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void DisableForceEarlyUpdate(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void EnableForceEarlyUpdate(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void UnmaskFromGfxFilter(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void MaskFromGfxFilter(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ClearBellows(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetBellows(const PartsHandle& handle, const PartsHandle& target1, const string& target1_name, const PartsHandle& target2, const string& target2_name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void CopyHole(const PartsHandle& from, const PartsHandle& to)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void CloseHole(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OpenHole(const PartsHandle& handle, const string& name, float size)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void AddHoleComponent(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetLeaderFollowLocator(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetCursorFollowLocator(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_s32 GetAngleTargetParts(const PartsHandle& handle, const UnitHandle& uh)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetHammerCameraDirOffset(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetHammerCameraDirOffset(const PartsHandle& handle, as_f32 offset)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetJumpCameraDirOffset(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetJumpCameraDirOffset(const PartsHandle& handle, as_f32 offset)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetHammerOffsset(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetHammerOffset(const PartsHandle& handle, as_f32 offset)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetCursorPoiPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetCursorPoiPos(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetCursorPoiPos(const PartsHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetDispCursorLowPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetCursorLowPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetCursorLowPos(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetCursorLowPos(const PartsHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetDispCursorPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetCursorPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetCursorPos(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetCursorPos(const PartsHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ResetAttack2ndPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetDispAttackPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetAttackPinchPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetAttackPinchPos(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetAttackPinchPos(const PartsHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetAttack2ndPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetAttack2ndPos(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetAttack2ndPos(const PartsHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetAttackPoiPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetAttackPoiPos(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetAttackPoiPos(const PartsHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetAttackLowPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetAttackLowPos(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetAttackLowPos(const PartsHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetAttackPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetAttackPos(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetAttackPos(const PartsHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetLUT(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ReplaceTexture(const PartsHandle& handle, const string& name, const string& color)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ReplaceMainAlbedoColor(const PartsHandle& handle, const string& color)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void UpdateBoneEnableLocator(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetLocatorPos(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetLocatorPos(const PartsHandle& handle, const string& name, float x, float y, float z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetLocatorPos(const PartsHandle& handle, const string& name, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetLocatorRot(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetLocatorRot(const PartsHandle& handle, const string& name, float x, float y, float z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetLocatorRot(const PartsHandle& handle, const string& name, const math::Vec3& scale)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetLocatorWorldScale(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetLocatorScale(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetLocatorScale(const PartsHandle& handle, const string& name, float x, float y, float z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetLocatorScale(const PartsHandle& handle, const string& name, const math::Vec3& scale)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetLocatorLocalPos(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetLocatorWorldPos(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsShowBoneLocator(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void HideBoneLocator(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ShowBoneLocator(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsShowLocator(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void HideLocator(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ShowLocator(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void CreateLocator(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetFollowPos(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetFollowPos(const PartsHandle& handle, const math::Vec3& rot)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetFollowRot(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetFollowRot(const PartsHandle& handle, const math::Vec3& rot)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsFollow(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ClearFollow(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetFollow(const PartsHandle& handle, const MobjHandle& target, const string& name, bool pos_only=false)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetFollow(int ch, const PartsHandle& handle, const string& name, const PartsHandle& target, const string& target_name, bool pos_only=false)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetFollow(const PartsHandle& handle, const string& name, const PartsHandle& target, const string& target_name, bool pos_only=false)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetFollow(const PartsHandle& handle, const PartsHandle& target, const string& name, bool pos_only=false)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void DisableHitCheck(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void EnableHitCheck(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ClearHitCheckUnit(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnHitCheckPlayerAndEnemy(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnHitCheckNpc(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnHitCheckEnemy(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void OnHitCheckPlayer(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetSize(const PartsHandle& handle, as_f32 w, as_f32 h, as_f32 d)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetWidth(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetWidth(const PartsHandle& handle, as_f32 width)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetHeight(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetHeight(const PartsHandle& handle, as_f32 height)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ChangeAnglePartsData(const PartsHandle& handle, as_s32 angle, const string& id)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void ChangePartsData(const PartsHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetMaterialParam(const PartsHandle& handle, const string& name, as_f32 v)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetMaterialParam(const PartsHandle& handle, const string& name, const math::Vec3& v)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void FaceRight(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void FaceLeft(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void FaceBack(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void FaceFront(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetPeraTypeOlivia(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetPeraTypeNoFlip(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetPeraTypeFixFront(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetPeraTypeDirectRotY(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetPeraTypeChr3D(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetPeraTypeBackModel(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetPeraTypeNormal(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetPeraTypeNone(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetShow(const PartsHandle& handle, bool show)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "bool IsShow(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void Hide(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void Show(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "string GetPartsID(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "string GetName(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetName(const PartsHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetHomeDir(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetHomeDir(const PartsHandle& handle, as_f32 dir)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetDir(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetDirectDir(const PartsHandle& handle, as_f32 dir)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetDir(const PartsHandle& handle, as_f32 dir)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetRotCenter(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetRotZ(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetRotY(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_f32 GetRotX(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void GetRot(const PartsHandle& handle, as_f32& x, as_f32& y, as_f32& z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetRotZ(const PartsHandle& handle, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetRotY(const PartsHandle& handle, as_f32 y)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetRotX(const PartsHandle& handle, as_f32 x)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetRot(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void GetScale(const PartsHandle& handle, as_f32& x, as_f32& y, as_f32& z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetScale(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetScale(const PartsHandle& handle, const math::Vec3& scale)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetBaseRot(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetBaseRot(const PartsHandle& handle, const math::Vec3& rot)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetBaseScale(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetBaseScale(const PartsHandle& handle, const math::Vec3& scale)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetOffsetPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetOffsetPos(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetOffsetPos(const PartsHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetPos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetPos(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetPos(const PartsHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "math::Vec3 GetHomePos(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetHomePos(const PartsHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "void SetHomePos(const PartsHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "as_s32 GetAnglePartsNo(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "PartsHandle GetAnglePartsHandle(const PartsHandle& handle, as_s32 angle)"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "UnitHandle GetParent(const PartsHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EntryActionListPlayerType(const UnitHandle& handle, const string& func, const string& comment)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EntryActionListSceneType(const UnitHandle& handle, const string& func, const string& comment)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EntryActionListStatusType(const UnitHandle& handle, const string& func, const string& comment)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EntryActionListFormationType(const UnitHandle& handle, const string& funcPlan, const string& funcExec, const string& comment)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EntryActionListActionType(const UnitHandle& handle, const string& func, const string& comment)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetBlendAnime(const UnitHandle& handle, const PartsHandle& parts, float weight, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAnimeLoopTiming(const UnitHandle& handle, const PartsHandle& parts, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAnimeLooped(const UnitHandle& handle, const PartsHandle& parts, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitAnimeLoopTiming(const UnitHandle& handle, const PartsHandle& parts, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitAnimeLooped(const UnitHandle& handle, const PartsHandle& parts, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetFrameAnime(const UnitHandle& handle, const PartsHandle& parts, float frame, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetSpeedAnime(const UnitHandle& handle, const PartsHandle& parts, float spd, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void DestroyAnime(const UnitHandle& handle, const PartsHandle& parts, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangePoseForce(const UnitHandle& handle, const PartsHandle& parts, const string& anime, int ch=-1, float blend=0.0f, bool gap=true)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangePose(const UnitHandle& handle, const PartsHandle& parts, const string& anime, int ch=-1, float blend=0.0f, bool gap=true)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeAnimeForce(const UnitHandle& handle, const PartsHandle& parts, const string& anime, const string& next_anime, int ch=-1, float blend=0.0f)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeAnimeForce(const UnitHandle& handle, const PartsHandle& parts, const string& anime, int ch=-1, float blend=0.0f)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeAnime(const UnitHandle& handle, const PartsHandle& parts, const string& anime, const string& next_anime, int ch=-1, float blend=0.0f)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeAnime(const UnitHandle& handle, const PartsHandle& parts, const string& anime, int ch=-1, float blend=0.0f)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeAnimeState(const UnitHandle& handle, const PartsHandle& parts, const string& anime)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAnimeLoopTiming(const UnitHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAnimeLooped(const UnitHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitAnimeLoopTiming(const UnitHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitAnimeLooped(const UnitHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetBlendAnime(const UnitHandle& handle, float weight, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "float GetEndFrameAnime(const UnitHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "float GetFrameAnime(const UnitHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetFrameAnime(const UnitHandle& handle, float frame, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetSpeedAnime(const UnitHandle& handle, float spd, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void DestroyAnime(const UnitHandle& handle, int ch=-1)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangePoseForce(const UnitHandle& handle, const string& anime, int ch=-1, float blend=0.0f, bool gap=true)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangePose(const UnitHandle& handle, const string& anime, int ch=-1, float blend=0.0f, bool gap=true)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeAnimeForce(const UnitHandle& handle, const string& anime, const string& next_anime, int ch=-1, float blend=0.0f)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeAnimeForce(const UnitHandle& handle, const string& anime, int ch=-1, float blend=0.0f)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeAnime(const UnitHandle& handle, const string& anime, const string& next_anime, int ch=-1, float blend=0.0f)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeAnime(const UnitHandle& handle, const string& anime, int ch=-1, float blend=0.0f)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeAnimeState(const UnitHandle& handle, const string& anime)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void MoveDisposSlideMsec(const UnitHandle& handle, const math::Vec3& tpos, as_f32 ms)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void MoveDisposSlide(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void MoveDisposMsec(const UnitHandle& handle, const math::Vec3& tpos, as_f32 ms)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void MoveDispos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void _MoveDispos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void _MoveDisposSlide(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void FlyPosMsec(const UnitHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type, bool syncAnime=true)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void FlyPos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type, bool syncAnime=true)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void _FlyPos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, as_f32 mode, as_f32 slide, as_s32 type, bool syncAnime)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void Fall(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void FallContinue(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void FallPosMsec(const UnitHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void FallPos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void _FallPos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void JumpPosMsec(const UnitHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void JumpPos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void _JumpPos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void MovePosMsec(const UnitHandle& handle, const math::Vec3& tpos, as_f32 ms, bool fixedDir, bool syncAnime=true)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void MovePos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, bool fixedDir, bool syncAnime=true)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void _MovePos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, bool syncAnime)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void _MovePos(const UnitHandle& handle, const math::Vec3& tpos, as_f32 spd, as_f32 ms, bool fixedDir, as_s32 type, bool syncAnime)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void Dir(const UnitHandle& handle, as_f32 dir, as_f32 msec)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void Rotate(const UnitHandle& handle, as_f32 x, as_f32 y, as_f32 z, as_f32 msec)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ResetFallAcc(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetFallAcc(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetFallAcc(const UnitHandle& handle, as_f32 acc)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsScene2d(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_s32 GetTotalDamage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsBingoBonus(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void TurnUnitWithCheck(const UnitHandle& handle, const UnitHandle& target)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAutoBuddyCtrl(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsAutoBuddyCtrl()"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OffAutoBuddyCtrl()"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnAutoBuddyCtrl()"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetAttackPri(const UnitHandle& handle, as_s32 pri)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_s32 GetAttackPri(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ClearFollow(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetFollow(const UnitHandle& handle, const PartsHandle& target, const string& name, bool pos_only=false)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetFollow(const UnitHandle& handle, const UnitHandle& target, bool pos_only=false)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsPinch(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeUnitData(const UnitHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "float GetLeaderDispOffset(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetLeaderDispOffset(const UnitHandle& handle, float height)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetLeaderID(const UnitHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "string GetLeaderID(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetPanelSubType(const UnitHandle& handle, as_s32 type)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_s32 GetPanelSubType(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_s32 GetPanelType(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "string GetSetDataArg2(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "string GetSetDataArg1(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "string GetSetDataArg(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void DeleteParts(const UnitHandle& handle, const PartsHandle& parts)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void WaitEntryParts(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "PartsHandle EntryParts(const UnitHandle& handle, const string& id)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ResetPanel(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void DisableHitCheck(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EnableHitCheck(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ClearHitCheckUnit(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnHitCheckEnemyAndNpc(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnHitCheckPlayerAndEnemy(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnHitCheckNpc(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnHitCheckEnemy(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnHitCheckPlayer(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ClearShapeObjGroup(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnShapeObjGroupNone(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnShapeObjGroup(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnShapeObjGroupNpc(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnShapeObjGroupEnemy(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void OnShapeObjGroupPlayer(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ResetTimer(const UnitHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetTimer(const UnitHandle& handle, const string& name, as_s32 time)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsStopTimer(const UnitHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool CheckTimer(const UnitHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void ChangeBodyParts(const UnitHandle& handle, const PartsHandle& parts)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsPanel(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsNPC(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsEnemy(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsParty(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsNavi(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsPlayer(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetShow(const UnitHandle& handle, bool show)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsShow(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void Hide(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void Show(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_s32 GetOptionInt(const UnitHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetOptionFloat(const UnitHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "string GetOptionString(const UnitHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "string GetSubUnitID(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "string GetMainUnitID(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_s32 GetUnitNo(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "string GetUnitID(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "string GetName(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetName(const UnitHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool CanAction(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetMinHP(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetMinHP(const UnitHandle& handle, as_f32 hp)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetUnitDataMaxHP(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetOrgMaxHP(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetMaxHP(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetMaxHP(const UnitHandle& handle, as_f32 hp)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetHP(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetHP(const UnitHandle& handle, as_f32 hp)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetSize(const UnitHandle& handle, as_f32 w, as_f32 h, as_f32 d)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetWidth(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetWidth(const UnitHandle& handle, as_f32 width)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetHeight(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetHeight(const UnitHandle& handle, as_f32 height)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetGroupId(const UnitHandle& handle, as_s32 group)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_s32 GetGroupId(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsEscape(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void Escape(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void RecoverDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsEventDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void EventDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsDummyDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void DummyDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsPreDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void PreDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool IsDead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void Dead(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetPeraTypeFixFront(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetPeraTypeOlivia(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetPeraTypeNoFlip(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetPeraTypeChr3D(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetPeraTypeBackModel(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetPeraTypeNormal(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetPeraTypeNone(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "float GetHomeRangeDirOutside(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "float GetRangeDirOutside(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "float GetHomeRangeDir(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "float GetRangeDir(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "RangePos GetRangePos(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "RangePos GetHomeRangePos(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void UpdateRangePosHome(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void UpdateRangePos(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetThisName(const UnitHandle& handle, const string& ns, const string& name)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetThis(const UnitHandle& handle, const string& ns, const string& name, ?&in)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool GetThis(const UnitHandle& handle, ?&out)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "any& GetThis(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as::Variable& GetVariable(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "bool HasVariable(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetHomeDir(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetHomeDir(const UnitHandle& handle, as_f32 dir)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetDir(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetDirectDir(const UnitHandle& handle, as_f32 dir)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetDir(const UnitHandle& handle, as_f32 dir)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetRotCenter(const UnitHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetRotZ(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetRotY(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "as_f32 GetRotX(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void GetRot(const UnitHandle& handle, as_f32& x, as_f32& y, as_f32& z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetRotZ(const UnitHandle& handle, as_f32 z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetRotY(const UnitHandle& handle, as_f32 y)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetRotX(const UnitHandle& handle, as_f32 x)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetRot(const UnitHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void GetScale(const UnitHandle& handle, as_f32& x, as_f32& y, as_f32& z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetScale(const UnitHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetScale(const UnitHandle& handle, const math::Vec3& scale)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "math::Vec3 GetBaseRot(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetBaseRot(const UnitHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetBaseRot(const UnitHandle& handle, const math::Vec3& rot)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetBaseScale(const UnitHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetBaseScale(const UnitHandle& handle, const math::Vec3& scale)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "math::Vec3 GetOffsetPos(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetOffsetPos(const UnitHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetOffsetPos(const UnitHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "math::Vec3 GetBingoBonusPos(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "math::Vec3 GetTargetPos(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetTargetPos(const UnitHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetTargetPos(const UnitHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "math::Vec3 GetPos(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetPos(const UnitHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetPos(const UnitHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "math::Vec3 GetHomePos(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetHomePos(const UnitHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetHomePos(const UnitHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetBeastPartsHandle(const UnitHandle& handle, const PartsHandle& parts)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "PartsHandle GetBeastPartsHandle(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "void SetCameraPartsHandle(const UnitHandle& handle, const PartsHandle& parts)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "PartsHandle GetCameraPartsHandle(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "PartsHandle GetPartsHandle(const UnitHandle& handle, as_s32 no)"
    },
    {
      "namespace": "btl::unit",
      "declaration": "PartsHandle GetBodyPartsHandle(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool IsItemEmpty()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void MagicCircleWaitStartup()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void MagicCircleStartup()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool IsSkip()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OutSkip()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void InSkip()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void SetSongAnswer(const string& answer1, const string& answer2, const string& answer3, const string& answer4)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CloseBossAction()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OpenBossAction(const string& msg)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CloseEnemyAction()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OpenEnemyAction(const string& msg)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void ClosePartyAction()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OpenPartyAction(const string& msg)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void ClosePlayerAction()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OpenPlayerAction(const string& msg)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OffHole(const RangePos& rangePos)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OnHole(const RangePos& rangePos)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void TargetCursorDisable()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void TargetCursorEnable()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AmuletHideAntiDamage()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AmuletShowAntiDamage()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AmuletStartAntiDamage()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AmuletOutCaptionHpUp()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AmuletOutCaptionTimeUp()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "math::Vec3 AddHpGetPos()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddHpSetPos(as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddHpLeftOut()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddHpRightOut()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddHpLeftIn()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "as_s32 AddHpGetHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddHpSetHP(as_s32 num)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddHpSubHP(as_s32 num)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddHpAddHP(as_s32 num)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool WaitAddTimerAnimeEnd()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddTimerConfirmMode()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "math::Vec3 AddTimerGetPos()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddTimerSetPos(as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddTimerRightOut()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddTimerLeftIn()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "as_s32 AddTimerGetTime()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddTimerSetTime(as_s32 num)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddTimerSubTime(as_s32 num)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddTimerAddTime(as_s32 num)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddTimerSubCoin(as_s32 num)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddTimerSetCoin(as_s32 num)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "as_s32 CheerSlotGetEffectLv()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "math::Vec3 CheerSlotGetPos()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CheerSlotSetPos(as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CheerSlotRightOut()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "as_s32 CheerSlotGetCoin()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CheerSlotSetCoin(as_s32 num)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CheerSlotSubCoin(as_s32 num)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CheerSlotAddCoin(as_s32 num)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void NotificationNews(const string& item)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool IsEndMaxHpUp()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void SetMaxHP(as_f32 hp)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void SetPosContolGuide_End(const math::Vec3 pos)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void FakeDamageStar(const math::Vec3 pos, as_f32 damage)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void InHUD()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OutHUD()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void InEnemyHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OutEnemyHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool isShowEnemyHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void InControlGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OutControlGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool isShowControlGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void InAttackGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OutAttackGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool isShowAttackGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void InMoveRingNum()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OutMoveRingNum()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool isShowMoveRingNum()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void QuickInTemporary_ActionName()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void InTemporary_MagicRingGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void InTemporary_AttackGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void InTemporary_MoveRingNum()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void InTemporary()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void NonAttackGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void OutTemporary()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void HideButtonA()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void DispButtonA(const UnitHandle& handle, const math::Vec3& offset, as_f32 frame)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "EffectHandle GetBlockHandle(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "EffectHandle GetBlockHandle(const RangePos& rangePos)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "int GetRingControl()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void SetRingControl(const as_s32 control)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void ChangeRingPattern(const as_s32 pattern)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void ChangeRingSize(const as_s32 size)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void WaitChangeRingType()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void ChangeRingType(const as_s32 type)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool IsOnRangeArea(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void GodHandOperationControlNoGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void GodHandOperationControlGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void HideControlGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void ShowControlGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void UnsetControlGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void SetupControlGuide()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CaptionResetPos(as_s32 type)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CaptionSetPos(as_s32 type, as_f32 offsetX, as_f32 offsetY, as_f32 offsetZ)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool IsNone()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void WaitCaption(as_s32 type)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CaptionOut(as_s32 type, const string& msg)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CaptionIn(as_s32 type, const string& msg, as_f32 offsetY)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CaptionHide(as_s32 type)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CaptionOut(as_s32 type)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void CaptionIn(as_s32 type)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool IsBusyEnemyDamageHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void UnlockEnemyHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void LockEnemyHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void DisableAlwaysDispMaxHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void EnableAlwaysDispMaxHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void ClearDummyHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void SetDummyHP(as_f32 hp)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void SetDummyMaxHP(as_f32 hp)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "as_f32 GetOffsetMaxHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "as_f32 GetOffsetHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void SetOffsetMaxHP(as_f32 hp)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void SetOffsetHP(as_f32 hp)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "as_f32 GetEnemyMaxHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "as_f32 GetEnemyHP()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void StopLaboTimer()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void StartLaboTimer()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void HideMoveRingTime()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void ShowMoveRingTime()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void AddMoveRingTime(as_s32 num)"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void StopMoveRingTime()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "void StartMoveRingTime()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "as_s32 GetMoveRingTime()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool IsMoveRingTimeUp()"
    },
    {
      "namespace": "btl::ui",
      "declaration": "bool IsMoveRingStartTime()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void SetQTESuccess()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void SetAttackIntervalCount(as_s32 count)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void SetAttackIntervalTime(as_s32 time)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsWaitSeqAttackPlayer()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void SetWaitSeqAttackPlayer(bool wait)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "int GetMoveRingNumLeft()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "int GetMoveRingPassTime()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "int GetMoveRingTimeLeft()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsEndMoveRingTime()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsStartMoveRingTime()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSlidePanel(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsBusyForceButton()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ForceButton(as_s32 btn)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsBusyForceMoveRingSlide()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ForceMoveSlide(as_s32 dir)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ForceMoveRing(as_s32 dir)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsBusyForceSelectRingSlide()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ForceSelectSlideNo(as_s32 no)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ForceSelectRingNo(as_s32 no)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ForceSelectCmd(const string& id)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsLockMoveRing()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ForceUnlockMoveRing()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void UnlockMoveRing()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void LockMoveRing()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqMovePlayerNone()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqMovePlayerJunkenDraw()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqMovePlayerJunkenLose()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqMovePlayerJunkenWin()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqMovePlayerJunkenNow()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqEndTurn()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqEnemyTurn()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqSugorokuMovePlayer()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqAttackPlayer()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqIdle()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqDraw()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqWin()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqStartTurn()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ChangeSeqStartBattle()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool CheckForceSlideRing(int no)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ForceFastSlideRing(int no, int vec)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ForceSlideRing(int no, int vec)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool CheckForceRotateRing(int no)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ForceFastRotateRing(int no, int vec)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void ForceRotateRing(int no, int vec)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "as_s32 GetMoveRingSelectRingMode()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void SetMoveRingSelectRingNo(as_s32 no)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "as_s32 GetMoveRingSelectSlideNo()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "as_s32 GetMoveRingSelectRingNo()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void SetRetrySelectCmd(bool retry)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void SetRetryMoveRingAfterMovePlayer(int count=999)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "void SetRetryMoveRing(int count=999)"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool isBuddyHintPhase()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqActionList()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqEndTurn()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqCheer()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqDraw()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqEscape()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqLose()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqWin()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMoveRingPrevTurnSuccess()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMovePlayerJunkenDraw()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMovePlayerJunkenLose()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMovePlayerJunkenWin()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMovePlayerJunkenNow()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMovePlayer()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMoveRingGameOver()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMoveRingAllClear()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMoveRingAnswerAction()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMoveRingTimeOver()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMoveRingMiss()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMoveRingSuccess()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqMoveRing()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqShuffleRing()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqSelectCmd()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqFirstAttackEnemy()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqAttackEnemy()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqAttackPlayer()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqFirstAttackPlayer()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqStartTurn()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqStartBattle()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqEnter()"
    },
    {
      "namespace": "btl::seq",
      "declaration": "bool IsSeqIdle()"
    },
    {
      "namespace": "btl::range",
      "declaration": "void SetDirUnit(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::range",
      "declaration": "void SetSelectDir(as_f32 dir)"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 CheckOnSlide(const math::Vec3& pos)"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 CheckOnSlide(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 CheckOnRing(const math::Vec3& pos)"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 CheckOnRing(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 GetAngleUnitDir(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::range",
      "declaration": "void HideRangeSelectArea()"
    },
    {
      "namespace": "btl::range",
      "declaration": "void ShowRangeSelectArea()"
    },
    {
      "namespace": "btl::range",
      "declaration": "void UpdateRangePosUnit(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::range",
      "declaration": "void GetUnitArea(const UnitHandle& handle, const RangePos& pos, array<RangePos>& list)"
    },
    {
      "namespace": "btl::range",
      "declaration": "void GetUnitArea(const UnitHandle& handle, array<RangePos>& list)"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 CalcDistance(const RangePos& src, const RangePos& dst)"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 ComapreDepthNormalize(const RangePos& src, const RangePos& dst)"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 ComapreAngleNormalize(const RangePos& src, const RangePos& dst)"
    },
    {
      "namespace": "btl::range",
      "declaration": "bool IsStayUnit(as_s32 a, as_s32 d)"
    },
    {
      "namespace": "btl::range",
      "declaration": "bool IsStayOtherUnit(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::range",
      "declaration": "bool IsStayOtherUnit(const UnitHandle& handle, const RangePos& range)"
    },
    {
      "namespace": "btl::range",
      "declaration": "bool IsStayUnit(const RangePos& range)"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 GetRangeDivisionNum()"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 GetSlideNum()"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 GetRingNum()"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 GetRangeDepthMaxNum()"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 GetRangeDepthMax()"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 GetRangeDepthMinNum()"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 GetRangeDepthMin()"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 GetRangeMasuDepth()"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 GetRangeMasuAngle()"
    },
    {
      "namespace": "btl::range",
      "declaration": "as_s32 GetRangeSystemDepthNum()"
    },
    {
      "namespace": "btl::message",
      "declaration": "UnitHandle GetRecvGodHandMessageUnitHandle(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::message",
      "declaration": "UnitHandle GetRecvSubMessageUnitHandle(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::message",
      "declaration": "UnitHandle GetRecvMessageUnitHandle(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::message",
      "declaration": "as_s32 GetRecvGodHandMessage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::message",
      "declaration": "as_s32 GetRecvSubMessage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::message",
      "declaration": "as_s32 GetRecvMessage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::message",
      "declaration": "as_s32 GetSendGodHandMessage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::message",
      "declaration": "as_s32 GetSendSubMessage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::message",
      "declaration": "as_s32 GetSendMessage(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::message",
      "declaration": "void WaitProcGodHandMessage(const UnitHandle& handle, const UnitHandle& target)"
    },
    {
      "namespace": "btl::message",
      "declaration": "void WaitProcSubMessage(const UnitHandle& handle, const UnitHandle& target)"
    },
    {
      "namespace": "btl::message",
      "declaration": "void WaitProcMessage(const UnitHandle& handle, const UnitHandle& target)"
    },
    {
      "namespace": "btl::message",
      "declaration": "void SendGodHandMessage(UnitHandle& handle, const UnitHandle& target, as_s32 code, const as::Variable& arg0=as::Variable(), const as::Variable& arg1=as::Variable())"
    },
    {
      "namespace": "btl::message",
      "declaration": "void SendSubMessage(UnitHandle& handle, const UnitHandle& target, as_s32 code)"
    },
    {
      "namespace": "btl::message",
      "declaration": "void SendMessage(UnitHandle& handle, const UnitHandle& target, as_s32 code, const as::Variable& arg0=as::Variable(), const as::Variable& arg1=as::Variable())"
    },
    {
      "namespace": "btl::message",
      "declaration": "void Setup(UnitHandle& handle)"
    },
    {
      "namespace": "btl::map",
      "declaration": "string GetID(const MapHandle& handle)"
    },
    {
      "namespace": "btl::map",
      "declaration": "bool IsW4C2()"
    },
    {
      "namespace": "btl::map",
      "declaration": "bool IsW3C4()"
    },
    {
      "namespace": "btl::map",
      "declaration": "bool IsW3G2()"
    },
    {
      "namespace": "btl::map",
      "declaration": "bool IsDark()"
    },
    {
      "namespace": "btl::map",
      "declaration": "bool IsCenterBaseGroundUp()"
    },
    {
      "namespace": "btl::map",
      "declaration": "void SetCenterBaseY(as_f32 height)"
    },
    {
      "namespace": "btl::map",
      "declaration": "as_f32 GetCenterBaseY()"
    },
    {
      "namespace": "btl::map",
      "declaration": "void WaitAnimeLoopTiming(const MapHandle& handle, int ch=0)"
    },
    {
      "namespace": "btl::map",
      "declaration": "void WaitAnimeLooped(const MapHandle& handle, int ch=0)"
    },
    {
      "namespace": "btl::map",
      "declaration": "void SetSpeedAnime(const MapHandle& handle, float spd, int ch=0)"
    },
    {
      "namespace": "btl::map",
      "declaration": "as_f32 GetFrameAnime(const MapHandle& handle, int ch=0)"
    },
    {
      "namespace": "btl::map",
      "declaration": "void SetFrameAnime(const MapHandle& handle, float frame, int ch=0)"
    },
    {
      "namespace": "btl::map",
      "declaration": "void ChangeAnimeForce(const MapHandle& handle, const string& anime, int ch=0)"
    },
    {
      "namespace": "btl::map",
      "declaration": "void ChangeAnime(const MapHandle& handle, const string& anime, int ch=0)"
    },
    {
      "namespace": "btl::map",
      "declaration": "void UpdateBoneEnableLocator(const MapHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::map",
      "declaration": "math::Vec3 GetLocatorPos(const MapHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::map",
      "declaration": "void SetLocatorPos(const MapHandle& handle, const string& name, float x, float y, float z)"
    },
    {
      "namespace": "btl::map",
      "declaration": "void SetLocatorPos(const MapHandle& handle, const string& name, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::map",
      "declaration": "math::Vec3 GetLocatorLocalPos(const MapHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::map",
      "declaration": "math::Vec3 GetLocatorWorldPos(const MapHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::map",
      "declaration": "bool IsShowLocator(const MapHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::map",
      "declaration": "void HideLocator(const MapHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::map",
      "declaration": "void ShowLocator(const MapHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::map",
      "declaration": "void CreateLocator(const MapHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::map",
      "declaration": "void Hide()"
    },
    {
      "namespace": "btl::map",
      "declaration": "void Show()"
    },
    {
      "namespace": "btl::item",
      "declaration": "void SetSpeedAnime(ItemHandle& handle, float spd, int ch=0)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void ChangeAnime(ItemHandle& handle, const string& anime, int ch=0)"
    },
    {
      "namespace": "btl::item",
      "declaration": "bool IsTail()"
    },
    {
      "namespace": "btl::item",
      "declaration": "bool IsIceFlower()"
    },
    {
      "namespace": "btl::item",
      "declaration": "bool IsFireFlower()"
    },
    {
      "namespace": "btl::item",
      "declaration": "bool IsKinoko()"
    },
    {
      "namespace": "btl::item",
      "declaration": "void SetShow(const ItemHandle& handle, bool show)"
    },
    {
      "namespace": "btl::item",
      "declaration": "bool IsShow(const ItemHandle& handle)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void Hide(const ItemHandle& handle)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void Show(const ItemHandle& handle)"
    },
    {
      "namespace": "btl::item",
      "declaration": "math::Vec3 GetPos(const ItemHandle& handle)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void SetPos(const ItemHandle& handle, math::Vec3& pos)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void Destroy(const ItemHandle& handle)"
    },
    {
      "namespace": "btl::item",
      "declaration": "void WaitEntry(const ItemHandle& handle)"
    },
    {
      "namespace": "btl::item",
      "declaration": "ItemHandle EntryBound(const string& name, const string& id, float dly, float pow, float pitch)"
    },
    {
      "namespace": "btl::item",
      "declaration": "ItemHandle EntryBound(const string& name, const string& id, float dly, float pow)"
    },
    {
      "namespace": "btl::item",
      "declaration": "ItemHandle EntryBound(const string& name, const string& id, float dly)"
    },
    {
      "namespace": "btl::item",
      "declaration": "ItemHandle EntryBound(const string& name, const string& id)"
    },
    {
      "namespace": "btl::item",
      "declaration": "ItemHandle EntryBound(const string& id)"
    },
    {
      "namespace": "btl::item",
      "declaration": "ItemHandle Entry(const string& name, const string& id)"
    },
    {
      "namespace": "btl::item",
      "declaration": "ItemHandle Entry(const string& id)"
    },
    {
      "namespace": "btl::formation",
      "declaration": "void GetCurrentFormationNoStartupUnitList(array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::formation",
      "declaration": "void ReserveCurrentFormation()"
    },
    {
      "namespace": "btl::formation",
      "declaration": "void GetCurrentFormationMemberUnitList(array<UnitHandle>& list)"
    },
    {
      "namespace": "btl::formation",
      "declaration": "void SetCurrentFormationGroupId(as_s32 id)"
    },
    {
      "namespace": "btl::formation",
      "declaration": "as_s32 GetCurrentFormationGroupId()"
    },
    {
      "namespace": "btl::formation",
      "declaration": "void ResetCurrentFormation()"
    },
    {
      "namespace": "btl::formation",
      "declaration": "UnitHandle GetCurrentFormationNearUnit(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::formation",
      "declaration": "UnitHandle GetCurrentFormationLeaderUnit()"
    },
    {
      "namespace": "btl::formation",
      "declaration": "void SetCurrentFormationLeaderUnit(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::formation",
      "declaration": "bool IsStartup(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::formation",
      "declaration": "void ResetStartup(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::formation",
      "declaration": "void SetStartup(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::formation",
      "declaration": "void SetGroupId(const UnitHandle& handle, as_s32 group)"
    },
    {
      "namespace": "btl::formation",
      "declaration": "as_s32 GetGroupId(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::formation",
      "declaration": "as_s32 GetMaxFormationNo()"
    },
    {
      "namespace": "btl::formation",
      "declaration": "as_s32 GetCurrentFormationNo()"
    },
    {
      "namespace": "btl::formation",
      "declaration": "void SetCurrentFormationNo(as_s32 no)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetBlendAnime(const EffectHandle& handle, float weight, int ch=0)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void WaitAnimeLoopTiming(const EffectHandle& handle, int ch=0)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void WaitAnimeLooped(const EffectHandle& handle, int ch=0)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetSpeedAnime(const EffectHandle& handle, float spd, int ch=0)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "float GetEndFrameAnime(const EffectHandle& handle, int ch=0)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "as_f32 GetFrameAnime(const EffectHandle& handle, int ch=0)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFrameAnime(const EffectHandle& handle, float frame, int ch=0)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void ChangeAnimeForce(const EffectHandle& handle, const string& anime, int ch=0, float blend=0.0f)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void ChangeAnime(const EffectHandle& handle, const string& anime, int ch=0, float blend=0.0f)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void ChangeLayer(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetDrawPassForwardPreModel(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void ShadowOff(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void ShadowOn(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void UpdateOptimizeModeNone(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void UpdateOptimizeModeFull(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void DisableSoundSignal(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void EnableSoundSignal(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void DisableHideNear(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetHideNearLocator(const EffectHandle& handle, const string& loc)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void EnableHideNear(const EffectHandle& handle, as_f32 z)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetLUT(const EffectHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void ReplaceTexture(const EffectHandle& handle, const string& name, const string& color)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void ReplaceMainAlbedoColor(const EffectHandle& handle, const string& color)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetMaterialParam(const EffectHandle& handle, const string& name, as_f32 v)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetMaterialParam(const EffectHandle& handle, const string& name, const math::Vec3& v)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "math::Vec3 GetLocatorLocalPos(const EffectHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "math::Vec3 GetLocatorWorldPos(const EffectHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "bool IsShowBoneLocator(const EffectHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void HideBoneLocator(const EffectHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void ShowBoneLocator(const EffectHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "bool IsShowLocator(const EffectHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void HideLocator(const EffectHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void ShowLocator(const EffectHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void CreateLocator(const EffectHandle& handle, const string& name)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void ClearFollow(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "math::Vec3 GetFollowPos(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollowPos(const EffectHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollowPos(const EffectHandle& handle, const math::Vec3& rot)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "math::Vec3 GetFollowRot(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollowRot(const EffectHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollowRot(const EffectHandle& handle, const math::Vec3& rot)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "math::Vec3 GetFollowScale(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollowScale(const EffectHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollowScale(const EffectHandle& handle, const math::Vec3& scale)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetLiveFollow(const EffectHandle& handle, UnitHandle& unit)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollow(const EffectHandle& handle, ItemHandle& item, bool pos_only=false, bool no_visible=false)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollow(const EffectHandle& handle, MapHandle& map, const string& name, bool pos_only=false, bool no_visible=false)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollow(const EffectHandle& handle, PartsHandle& parts, const string& name, bool pos_only=false, bool no_visible=false, bool update=true)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollow(const EffectHandle& handle, PartsHandle& parts, bool pos_only=false, bool no_visible=false)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollow(const EffectHandle& handle, UnitHandle& unit, bool pos_only=false, bool no_visible=false)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollow(const EffectHandle& handle, EffectHandle& unit, const string& name, bool pos_only=false, bool no_visible=false)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetFollow(const EffectHandle& handle, EffectHandle& unit, bool pos_only=false, bool no_visible=false)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetRotateOrderZXY(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetBillboardTypeY(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetShow(const EffectHandle& handle, bool show)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "bool IsShow(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void Hide(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void Show(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetRotCenter(const EffectHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "math::Vec3 GetBaseRot(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetBaseRot(const EffectHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetBaseRot(const EffectHandle& handle, const math::Vec3& rot)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "as_f32 GetRotZ(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "as_f32 GetRotY(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "as_f32 GetRotX(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "math::Vec3 GetRot(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetRotZ(const EffectHandle& handle, as_f32 z)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetRotY(const EffectHandle& handle, as_f32 y)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetRotX(const EffectHandle& handle, as_f32 x)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetRot(const EffectHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetRot(const EffectHandle& handle, const math::Vec3& rot)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "math::Vec3 GetScale(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetScale(const EffectHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetScale(const EffectHandle& handle, const math::Vec3& scale)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetDirectDir(const EffectHandle& handle, as_f32 dir)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "float GetDir(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetDir(const EffectHandle& handle, as_f32 dir)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "math::Vec3 GetOffsetPos(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetOffsetPos(const EffectHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetOffsetPos(const EffectHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "math::Vec3 GetPos(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetPos(const EffectHandle& handle, as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void SetPos(const EffectHandle& handle, const math::Vec3& pos)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void Stop(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void Delete(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "void WaitEntry(const EffectHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle EntryMobj(const string& name, const string& flag_name)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle EntryItem(const string& name, const string& flag_name, const UnitHandle& handle)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle EntryItem(const string& name, const string& flag_name)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle Entry(const string& name, const string& flag_name, const PartsHandle& uph, const math::Vec3& offset=math::Vec3::Zero(), as_f32 scale=1.0f, as_f32 rotY=0.0f)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle Entry(const string& name, const string& flag_name, const UnitHandle& uh, const math::Vec3& offset=math::Vec3::Zero(), as_f32 scale=1.0f, as_f32 rotY=0.0f)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle EntryModel3D(const string& name, const string& id)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle EntryModel3D(const string& name, const string& folder, const string& model)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle EntryModel2D3D(const string& name, const string& id)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle EntryModel2D3D(const string& name, const string& folder, const string& model)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle EntryModel2D(const string& name, const string& id)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle EntryModel2D(const string& name, const string& folder, const string& model)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle Entry(const string& name, const string& flag_name, float x, float y, float z, as_f32 scale=1.0f, as_f32 rotY=0.0f)"
    },
    {
      "namespace": "btl::effect",
      "declaration": "EffectHandle Entry(const string& name, const string& flag_name, const math::Vec3& offset=math::Vec3::Zero(), as_f32 scale=1.0f, as_f32 rotY=0.0f)"
    },
    {
      "namespace": "btl::config",
      "declaration": "bool IsFastSetup()"
    },
    {
      "namespace": "btl::config",
      "declaration": "as_f32 GetGameBaseSpeed()"
    },
    {
      "namespace": "btl::config",
      "declaration": "void EnableCameraOverview()"
    },
    {
      "namespace": "btl::config",
      "declaration": "void EnableCameraTPS()"
    },
    {
      "namespace": "btl::config",
      "declaration": "void DisableAutoAC()"
    },
    {
      "namespace": "btl::config",
      "declaration": "void EnableAutoAC()"
    },
    {
      "namespace": "btl::config",
      "declaration": "void EnableDispAnswer()"
    },
    {
      "namespace": "btl::config",
      "declaration": "string GetConfigDataString(const string& name)"
    },
    {
      "namespace": "btl::config",
      "declaration": "as_f32 GetConfigDataFloat(const string& name)"
    },
    {
      "namespace": "btl::config",
      "declaration": "as_s32 GetConfigDataInt(const string& name)"
    },
    {
      "namespace": "btl::config",
      "declaration": "bool IsAgingMode()"
    },
    {
      "namespace": "btl::config",
      "declaration": "bool IsTestMode()"
    },
    {
      "namespace": "btl::config",
      "declaration": "as_s32 GetTutorialType()"
    },
    {
      "namespace": "btl::config",
      "declaration": "void SetTutorialType(as_s32 type)"
    },
    {
      "namespace": "btl::config",
      "declaration": "void DisableSlide()"
    },
    {
      "namespace": "btl::config",
      "declaration": "void EnableSlide()"
    },
    {
      "namespace": "btl::config",
      "declaration": "void DisableShuffleEffect()"
    },
    {
      "namespace": "btl::config",
      "declaration": "void EnableShuffleEffect()"
    },
    {
      "namespace": "btl::config",
      "declaration": "void SetMutekiEnemy(bool muteki)"
    },
    {
      "namespace": "btl::config",
      "declaration": "void SetMutekiPlayer(bool muteki)"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "void ReturnHomeAllAudience()"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "bool IsDrawRoot()"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "as_s32 GetOutsideKinopioNum()"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "as_s32 GetSleepKinopioMaxNum()"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "as_s32 GetSleepKinopioNum()"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "void GetCheerMessage(const UnitHandle& handle, int klind, array<string>& list)"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "void SetCheerTerms(as_s32 terms)"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "as_s32 GetCheerTerms()"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "as_s32 GetCheerType()"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "as_f32 GetCheerDir(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "as_s32 GetRescueSearchRealKNP()"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "as_s32 GetAudienceNum()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void EndShadowCtrl()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void StartShadowCtrl(const PartsHandle& uph, as_f32 z)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void ResumeCtrl()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void OnceStopCtrl()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetMoveRingOffsetDist(float dist)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetMoveRingOffsetPitch(float pitch)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetMoveRingOffsetPos(as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetMoveRingOffsetPos(const math::Vec3& pos)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void ChangeSubAnime(const PartsHandle& handle, as_s32 index, const string& name)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void ChangeSubAnime(as_s32 index, const string& name)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "float GetAnimeFrame()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "string GetAnimeName()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetAnimeScale(const math::Vec3& scale)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetAnimeScale(as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetSubAnimeFrame(as_f32 frame)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "float GetEndAnimeFrame()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetAnimeFrame(as_f32 frame)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetSubAnimeSpeed(as_f32 spd)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetAnimeSpeed(as_f32 spd)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "bool IsBindSubAnime()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "bool IsBindAnime()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void WaitEvent()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void WaitAnime()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void BindSubAnime()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void BindAnime(as_s32 type)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void ClearSubAnime()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void ClearAnime()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetSubAnime(const PartsHandle& handle, int index=0, const string& name=\"\")"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetAnime(const EffectHandle& handle, int index=0, const string& name=\"\")"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetAnime(const MapHandle& handle, int index=0, const string& name=\"\")"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetAnime(const PartsHandle& handle, int index=0, const string& name=\"\")"
    },
    {
      "namespace": "btl::camera",
      "declaration": "string GetEventCameraID()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "bool IsEvent()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "bool IsMoveRingLookDown()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "bool IsMoveRing()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "bool IsWin()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "bool IsFitY()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetFitY(bool fit)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetRate(as_f32 rate)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetEventDist(float dist)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetEventRoll(float roll)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetEventPitch(float pitch)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetEventDir(float dir)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetEventPos(const math::Vec3& pos)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "float GetEventDist()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "float GetEventRoll()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "float GetEventPitch()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "float GetEventDir()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "math::Vec3 GetEventPos()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Unlock()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Lock()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void CorrectVector(math::Vec3& vec)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetOffsetFovy(float fovy)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetOffsetDist(float dist)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetOffsetRoll(float roll)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetOffsetPitch(float pitch)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetOffsetDir(float dir)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetOffsetPos(as_f32 x, as_f32 y, as_f32 z)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetOffsetPos(const math::Vec3& pos)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "as_f32 GetOffsetFovy()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "as_f32 GetOffsetRoll()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "as_f32 GetOffsetPitch()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "as_f32 GetOffsetDist()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "as_f32 GetOffsetDir()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "math::Vec3 GetOffsetPos()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "as_f32 GetRoll()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "as_f32 GetPitch()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "as_f32 GetDist()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetDirDirect(float dir)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SetDir(float dir)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "as_f32 GetDir()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "math::Vec3 GetPos()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "math::Vec3 GetCameraPos()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void WaitMoving()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "bool IsMoving()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Shake(as_f32 w, as_f32 h, as_f32 msec)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Cheer()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void MoveDispos()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void FormationLeaderSide(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void FormationSide(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void FormationLookDown(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Formation(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Sideview(const UnitHandle& uh1, const UnitHandle& uh2)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void ItemTarget(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void HammerLesson(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void HammerTarget(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SugorokuGodHandUp()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SugorokuGodHand()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Hammer2Unit(const UnitHandle& uh1, const UnitHandle& uh2)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void JumpLesson(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void JumpTarget(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Jump2UnitLookAtPlayer(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Jump2Unit(const UnitHandle& uh1, const UnitHandle& uh2)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Fit2UnitLookAtPlayer(const UnitHandle& uh, as_f32 rate)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Fit2UnitLookAtPlayer(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Fit2UnitLesson(const UnitHandle& uh1, const UnitHandle& uh2)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Fit2Unit(const UnitHandle& uh1, const UnitHandle& uh2, as_f32 rate)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Fit2Unit(const UnitHandle& uh1, const UnitHandle& uh2)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void FitUnit(const UnitHandle& uh)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void MovePlayer()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void MoveRingLookDown()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void MoveRing()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SugorokuSelectCmd()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void SelectCmd()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Event(const string& id, const UnitHandle& uh, const PartsHandle& uph=PartsHandle())"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Event(const string& id)"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Win()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Magicview()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Overview()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void Free()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "as_f32 GetDebugCtrlDir()"
    },
    {
      "namespace": "btl::camera",
      "declaration": "void ResetDebugCtrl()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void DropExcellentCoin(const UnitHandle& handle)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void SetResult(as_s32 result)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "as_s32 GetResult()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "bool IsGurad()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void DisableEscape()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void EnableEscape()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "bool IsEnableJump()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void DisableJump()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void EnableJump()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void Guard()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void OutExcellentEffect()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void InExcellentEffect()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void ExcellentEffect()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void GreatEffect()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void NiceEffect()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void Excellent()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void Great()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void Nice()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void Combo()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "bool IsTimingStart()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "as_s32 TimingCheck()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void TimingEnd()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void TimingStart(as_f32 check_frame, as_f32 ok_frame, const math::Vec3& pos, as_f32 slow_frame=0, as_f32 slow_speed=1.0f, bool ok_skip=true)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "math::Vec3 GetOffsetRepeatA()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "math::Vec3 GetOffsetButtonA()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void TimingSetup()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void RepeatWait(as_s32 wait_frame)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "bool IsRepeatStart()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "as_s32 RepeatCount()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void RepeatEnd()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void RepeatStart(as_s32 check_frame, as_s32 ok_frame, const math::Vec3& pos, as_s32 ok_count, as_s32 slow_frame=0, as_f32 slow_speed=1.0f, bool ok_skip=true)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void RepeatSetup()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "as_s32 FlowerCheck(as_s32 lv1, as_s32 lv2, as_s32 lv3, as_s32 margin)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "as_s32 FlowerCheck(as_s32 ok_frame)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void FlowerEnd()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void FlowerWait(as_f32 frame)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void FlowerStart(as_s32 frame)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void FlowerSetup()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "as_s32 HammerCheck(as_s32 lv1, as_s32 lv2, as_s32 lv3, as_s32 margin)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "as_s32 HammerCheck(as_s32 ok_frame)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void HammerEnd()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void HammerWait(as_f32 frame)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void HammerStart(as_s32 frame)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void HammerSetup()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "as_s32 JumpCheck(as_s32 lv1, as_s32 lv2, as_s32 lv3, as_s32 lv4)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "as_s32 JumpCheck(as_s32 ok_frame)"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void JumpEnd()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void JumpStart()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void JumpSetup()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void ResumeGuard()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void OncestopGuard()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "bool IsGuardStart()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void GuardEnd()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void GuardStart()"
    },
    {
      "namespace": "btl::ac",
      "declaration": "void GuardSetup()"
    },
    {
      "namespace": "btl",
      "declaration": "void SetupMapResource()"
    },
    {
      "namespace": "btl",
      "declaration": "void UnsetMapResource()"
    },
    {
      "namespace": "btl",
      "declaration": "bool IsMessageNoMoveTurnOver()"
    },
    {
      "namespace": "btl",
      "declaration": "void OnMessageNoMoveTurnOver()"
    },
    {
      "namespace": "btl",
      "declaration": "bool IsMessageNoMove()"
    },
    {
      "namespace": "btl",
      "declaration": "void OnMessageNoMove()"
    },
    {
      "namespace": "btl",
      "declaration": "bool IsMessageNoMoveStan()"
    },
    {
      "namespace": "btl",
      "declaration": "void OnMessageNoMoveStan()"
    },
    {
      "namespace": "btl",
      "declaration": "bool IsMessageNoMoveIce()"
    },
    {
      "namespace": "btl",
      "declaration": "void OnMessageNoMoveIce()"
    },
    {
      "namespace": "btl",
      "declaration": "void ExitCallbackTest()"
    },
    {
      "namespace": "btl",
      "declaration": "as_f32 GetStickRY()"
    },
    {
      "namespace": "btl",
      "declaration": "as_f32 GetStickRX()"
    },
    {
      "namespace": "btl",
      "declaration": "as_f32 GetStickLY()"
    },
    {
      "namespace": "btl",
      "declaration": "as_f32 GetStickLX()"
    },
    {
      "namespace": "btl",
      "declaration": "void SetAgingStickR(as_f32 x, as_f32 y)"
    },
    {
      "namespace": "btl",
      "declaration": "void SetAgingStickL(as_f32 x, as_f32 y)"
    },
    {
      "namespace": "btl",
      "declaration": "void OnAgingButtonRepeatY()"
    },
    {
      "namespace": "btl",
      "declaration": "void OnAgingButtonRepeatB()"
    },
    {
      "namespace": "btl",
      "declaration": "void OnAgingButtonRepeatA()"
    },
    {
      "namespace": "btl",
      "declaration": "void OnAgingButtonTrigY()"
    },
    {
      "namespace": "btl",
      "declaration": "void OnAgingButtonTrigB()"
    },
    {
      "namespace": "btl",
      "declaration": "void OnAgingButtonTrigA()"
    },
    {
      "namespace": "btl",
      "declaration": "void OnAgingButtonY()"
    },
    {
      "namespace": "btl",
      "declaration": "void OnAgingButtonB()"
    },
    {
      "namespace": "btl",
      "declaration": "void OnAgingButtonA()"
    },
    {
      "namespace": "btl",
      "declaration": "as_s32 GetCounter()"
    },
    {
      "namespace": "btl",
      "declaration": "void End()"
    },
    {
      "namespace": "btl",
      "declaration": "void WaitRequestEndBattleSeq()"
    },
    {
      "namespace": "btl",
      "declaration": "void EndBattleSeq()"
    },
    {
      "namespace": "btl",
      "declaration": "void StartEnterBattleSeq(const as::Variable& arg1, const as::Variable& arg2)"
    },
    {
      "namespace": "btl",
      "declaration": "void StartBattleSeq(const as::Variable& arg1, const as::Variable& arg2)"
    },
    {
      "namespace": "btl",
      "declaration": "bool IsOnMapMode()"
    },
    {
      "namespace": "btl",
      "declaration": "void EndOnMapMode()"
    },
    {
      "namespace": "btl",
      "declaration": "void BeginOnMapEffectMode()"
    },
    {
      "namespace": "btl",
      "declaration": "void BeginOnMapMode()"
    },
    {
      "namespace": "btl",
      "declaration": "void Setup(const string& id)"
    },
    {
      "namespace": "btl",
      "declaration": "void WaitReadyStart()"
    },
    {
      "namespace": "btl",
      "declaration": "bool IsReadyStart()"
    },
    {
      "namespace": "btl",
      "declaration": "void SetGameSpeed(as_f32 spd)"
    },
    {
      "namespace": "btl",
      "declaration": "as_f32 GetGameSpeed()"
    },
    {
      "namespace": "btl",
      "declaration": "as_f32 GetDefaultFallAcc()"
    },
    {
      "namespace": "btl",
      "declaration": "as_s32 GetStartOption()"
    },
    {
      "namespace": "btl",
      "declaration": "as_s32 GetStartMode()"
    },
    {
      "namespace": "btl",
      "declaration": "as_s32 GetUniqueGroupId()"
    },
    {
      "namespace": "btl",
      "declaration": "bool IsEndBattle()"
    },
    {
      "namespace": "btl",
      "declaration": "void RequestEndBattleSeq()"
    },
    {
      "namespace": "btl",
      "declaration": "void RequestEndBattle()"
    },
    {
      "namespace": "btl",
      "declaration": "UnitHandle GetPanelHandle(const string& name)"
    },
    {
      "namespace": "btl",
      "declaration": "MapHandle GetMapHandle()"
    },
    {
      "namespace": "btl",
      "declaration": "EffectHandle GetEffectHandle(const string& name)"
    },
    {
      "namespace": "btl",
      "declaration": "UnitHandle GetNpcHandle(const string& name)"
    },
    {
      "namespace": "btl",
      "declaration": "UnitHandle GetEnemyHandle(const string& name)"
    },
    {
      "namespace": "btl",
      "declaration": "UnitHandle GetEnemyHandle(as_s32 no)"
    },
    {
      "namespace": "btl",
      "declaration": "UnitHandle GetEnemyHandle()"
    },
    {
      "namespace": "btl",
      "declaration": "UnitHandle GetPartyHandle(const string& name)"
    },
    {
      "namespace": "btl",
      "declaration": "UnitHandle GetPartyHandle(as_s32 no)"
    },
    {
      "namespace": "btl",
      "declaration": "UnitHandle GetPartyHandle()"
    },
    {
      "namespace": "btl",
      "declaration": "UnitHandle GetNavigatorHandle()"
    },
    {
      "namespace": "btl",
      "declaration": "UnitHandle GetBuddyHandle()"
    },
    {
      "namespace": "btl",
      "declaration": "UnitHandle GetPlayerHandle()"
    }
  ],
  "global_properties": [
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 REGION_ASIA"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 REGION_EUROPE"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 REGION_AMERICA"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 REGION_JAPAN"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 ALIGN_LEFT"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 ALIGN_CENTER"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 ALIGN_RIGHT"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 LOCATION_LEFT"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 LOCATION_CENTER"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 LOCATION_RIGHT"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 CREDIT_COMMAND"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 CREDIT_KARTMOVE"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 CREDIT_FRONTTREEFADE"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 CREDIT_BACKTREEFADE"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 CREDIT_BGANIMATION"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 CREDIT_PICTURE"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 CREDIT_ONEPERSON"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 CREDIT_TWOPERSONS"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 CREDIT_COMPANY"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 CREDIT_PART"
    },
    {
      "namespace": "ui::staffcredit",
      "declaration": "const as_s32 CREDIT_NONE"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "const as_s32 History2nd"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "const as_s32 History1st"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "const as_s32 PanelLR"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "const as_s32 PanelURDL"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "const as_s32 PanelUL"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "const as_s32 PanelDL"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "const as_s32 PanelDR"
    },
    {
      "namespace": "ui::puzzle",
      "declaration": "const as_s32 PanelUR"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "const as_s32 Mode_Trial"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "const as_s32 Mode_Drill"
    },
    {
      "namespace": "ui::battlelab",
      "declaration": "const as_s32 Mode_Cancel"
    },
    {
      "namespace": "ui::stampcard",
      "declaration": "const as_s32 Stamp_Stain"
    },
    {
      "namespace": "ui::stampcard",
      "declaration": "const as_s32 Stamp_Wrinkles"
    },
    {
      "namespace": "ui::stampcard",
      "declaration": "const as_s32 Stamp_Broken"
    },
    {
      "namespace": "ui::stampcard",
      "declaration": "const as_s32 Stamp_Cut"
    },
    {
      "namespace": "ui::guidemap",
      "declaration": "const as_s32 W5G1_SkySpaEast"
    },
    {
      "namespace": "ui::guidemap",
      "declaration": "const as_s32 W5G1_SkySpa"
    },
    {
      "namespace": "ui::guidemap",
      "declaration": "const as_s32 W4G1_Ocean"
    },
    {
      "namespace": "ui::guidemap",
      "declaration": "const as_s32 W4C1_StaffArea"
    },
    {
      "namespace": "ui::guidemap",
      "declaration": "const as_s32 W4C1_ControlRoom"
    },
    {
      "namespace": "ui::guidemap",
      "declaration": "const as_s32 W4C1_GuestArea"
    },
    {
      "namespace": "ui::guidemap",
      "declaration": "const as_s32 Arrow_Street"
    },
    {
      "namespace": "ui::guidemap",
      "declaration": "const as_s32 Arrow_Castle"
    },
    {
      "namespace": "ui::save",
      "declaration": "const as_s32 AUTO_SAVE_POS_Y"
    },
    {
      "namespace": "ui::save",
      "declaration": "const as_s32 AUTO_SAVE_POS_X"
    },
    {
      "namespace": "ui::timer",
      "declaration": "const as_s32 Layout_Boss"
    },
    {
      "namespace": "ui::timer",
      "declaration": "const as_s32 Layout_Top"
    },
    {
      "namespace": "ui::timer",
      "declaration": "const as_s32 Layout_BottomLeft"
    },
    {
      "namespace": "ui::timer",
      "declaration": "const as_s32 Layout_Bottom"
    },
    {
      "namespace": "ui::timer",
      "declaration": "const as_s32 Layout_Default"
    },
    {
      "namespace": "font",
      "declaration": "const as_s32 FontSura"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 EVENT_DESCRIPTION"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 EVENT_CHANGE_TYPE"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 EVENT_EXIT_ART_ZOOM"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 EVENT_INIT_ART_ZOOM"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 EVENT_CAMERA_SETUP"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 EVENT_SOUND_CANCEL"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 EVENT_SOUND_DECIDE"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 EVENT_ACTION"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 EVENT_EXIT_ZOOM"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 EVENT_INIT_ZOOM"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 EVENT_CHANGE_ZOOM"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 EVENT_CHANGE_PAGE"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 TYPE_ENTRANCE"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 TYPE_ENEMY"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 TYPE_KINOPIO"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 TYPE_COLLECTABLE"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 TYPE_SOUND"
    },
    {
      "namespace": "ui::museum",
      "declaration": "const as_s32 TYPE_ART"
    },
    {
      "namespace": "save",
      "declaration": "const as_s32 SaveTiming_Event"
    },
    {
      "namespace": "save",
      "declaration": "const as_s32 SaveTiming_Auto"
    },
    {
      "namespace": "save",
      "declaration": "const as_s32 SaveTiming_Block"
    },
    {
      "namespace": "save",
      "declaration": "const as_s32 SaveTiming_None"
    },
    {
      "namespace": "save",
      "declaration": "const as_s32 SLOT_MAX"
    },
    {
      "namespace": "save",
      "declaration": "const as_s32 SLOT_3"
    },
    {
      "namespace": "save",
      "declaration": "const as_s32 SLOT_2"
    },
    {
      "namespace": "save",
      "declaration": "const as_s32 SLOT_1"
    },
    {
      "namespace": "save",
      "declaration": "const as_s32 SLOT_0"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_StickL_RightUp"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_StickL_RightDown"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_StickL_LeftUp"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_StickL_LeftDown"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_ButtonZLZR_Push"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_ButtonZR_Push"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_ButtonZL_Push"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_ButtonZLZR_Release"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_SwingLeftRight"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_StickL_Push"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_StickL_LeftRight"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_StickL_Right"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_StickL_Left"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_StickL_Up"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_StickL_Down"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_StickL"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_ButtonA_Push"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_ButtonA"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_ButtonZLZR"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_ButtonZR"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_ButtonZL"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_SwingLeft"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_SwingRight"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_SwingDownBig"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_SwingDown"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonAnime_SwingUp"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Swing"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Spear"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Throw"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Loose"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Free"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Guard"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Twist"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Rub"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Pluck"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Lift"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Close"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_PeelOff"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Pull"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Cut"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Fold"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Round"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Hit"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Break"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Grasp"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 BalloonText_Grab"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 MODE_MANUAL"
    },
    {
      "namespace": "hand",
      "declaration": "const as_s32 MODE_DEFAULT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_CLOTHEXTRATHICKHARD"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_LEAFFALLENWATER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_CLOTHTHICKHARD"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_STONERATTLE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_WOODRATTLE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_METALPIPESMALL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_METALPIPEBIG"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_METALPIPE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_METALHOLLOWSMALL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_METALHOLLOWBIG"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_METALHOLLOW"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_STONEPLATE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_ICENOSLIP"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_GLASSBROKEN"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_MARIOOBJECT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_HIGHGRASS2"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_WATERRUNNING"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_WETLAND"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_CLOTHEXTRATHICK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_METALCANSMALL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_METALCAN"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_ROOFINGTILEWOOD"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_STRAW"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_BAMBOO"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_TOMEIBLOCKMARK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_LEAFFALLEN"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_VINYL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_MOMIJI"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_MAGICCIRCLEICE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_ROPE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_REALOIL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_SPECIALUSAGE4"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_SPECIALUSAGE3"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_SPECIALUSAGE2"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_SPECIALUSAGE1"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_ROOFINGTILE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_ASH"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_JUNGLEGRASS"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_GENERICSOFT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_GENERICHARD"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_BRICK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_HIGHGRASS"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_METALFENCE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_RUBBER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_POTTERYBIG"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_PAPERTHICK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_PAPER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_CLOTHSOFT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_CLOTHHARD"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_METALCHAIN"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_CARDBOARD"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_PLASTIC"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_SOILHARD"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_MAGICCIRCLE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_THORN"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_MUD"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_GOLD"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_CLOTH"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_STONEPROCESS"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_WIRE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_BUSH"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_TREEBIG"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_SQUIDINK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_PAMPASGRASS"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_TREESLIM"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_TREE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_WATERSHALLOW"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_OIL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_REALWATER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_REALICE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_REALSOIL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_LAVA"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_POTTERY"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_TATAMI"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_HOLE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_PAPERTAPE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_GLASS"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_SOIL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_LEAF"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_FLOWER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_CONCRETE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_GRAVEL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_CLOTHTHICK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_SNOW"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_ICE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_WATER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_SAND"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_METALPLATE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_METAL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_WOODPLATE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_WOOD"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_STONE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_GRASS2"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_GRASS"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_TURF"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 COL_MATERIAL_PLAIN"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_SLANTING"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_AUGOGEN_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_HOLE_SURFACE_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_UNCOLLECTABLEPAPER_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_VEHICLE_WHEEL_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_PLAYER_VEHICLE_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HINT_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_ITEM_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_PARTY_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HARIKO_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_NPCWEAPON_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_NPC_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_PAPER_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HAMMER_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_PLAYER_MASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_ITEMMESH"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HOLEWALLCOVER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HARIKOMESH"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_VEHICLEMESH"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HOLEBORDER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HOLEGUARDWALL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HOLEINNERWALL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HITONDASHATTACK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HOLEWALL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HOLESURFACE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_ICEPLATE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_NOPUSHUPWALL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_WEAPON"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_NOCAMERASHAKE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_ONDYNAMIC_NO_IGNOREROTATE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HINT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_NOGENERATEHOLE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_NORECOVERPOS"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_IGNOREHARIKO"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_ENEMYITEM"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_OUTLINE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_PRESIMPLIFY"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_SPECIALMESH"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_VEHICLEFORCEHIT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HARIKO"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_VEHICLE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_WATERSURFACE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_X_NOTPAINT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_X_INVISIBLE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_IGNOREPAPER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_X_ONLYPAINT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_IGNORENPC"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HEADBUTTEFFECT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_OTOTOGUARD"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_WALL"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_SOFT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_KAKURE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_ITEM"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_IGNOREITEM"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_NOTONMOVE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_IGNOREHANDLE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_X_INKMASK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_EMERGENCY"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_WEAK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_SLOPE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_SWINGHAMMER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_MARIOPAPER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_STRONG"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_MARIOHAMMER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HAMMERPAPER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_TOGE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_OTOTO"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_BOTHSIDES"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_PARTY"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_ENEMY"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_HAMMER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_TOMEI"
    },
    {
      "namespace": "hit",
      "declaration": "const as_u64 COL_FLAG_IGNORE_PAPER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HITOBJTYPE_AREA"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HITOBJTYPE_MAP"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HITOBJTYPE_PARTY"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HITOBJTYPE_ITEM"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HITOBJTYPE_ENEMY"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HITOBJTYPE_NPC"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HITOBJTYPE_MOBJ"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HITOBJTYPE_NOOBJ"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_DASHATTACK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_COL_SIDE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_ALL_FOOT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_PRESSED"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_HAMMER_TENKAI"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_HAMMER_SHAKE_RANGE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_HAMMER_IMPACT_RANGE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_HAMMER"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_BUTTON_TEAR_OFF"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_BUTTON_FRONT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_BUTTON"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_ACCESS_RANGE"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_PUSH"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_KNOCKUP"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_STAMP"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_ONGROUND"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_BACK"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_FRONT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_HEAD"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_FOOT"
    },
    {
      "namespace": "hit",
      "declaration": "const as_s32 HIT_PLACE_NONE"
    },
    {
      "namespace": "util::notice",
      "declaration": "const as_s32 PriorityLevel_Highest"
    },
    {
      "namespace": "util::notice",
      "declaration": "const as_s32 PriorityLevel_High"
    },
    {
      "namespace": "util::notice",
      "declaration": "const as_s32 PriorityLevel_Normal"
    },
    {
      "namespace": "util::notice",
      "declaration": "const as_s32 PriorityLevel_Low"
    },
    {
      "namespace": "util::notice",
      "declaration": "const as_s32 PriorityLevel_Lowest"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 RescueNpcIDCode_True"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 RescueNpcIDCode_False"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 RescueNpcIDCode_Error"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Attribute_Goaway"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Attribute_None"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingZ"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingY"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingX"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingW"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingV"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingU"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingT"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingS"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingR"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingQ"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingP"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingO"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingN"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingM"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingL"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingK"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingJ"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingI"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingH"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingG"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingF"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingE"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingD"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingC"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingB"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_WaitingA"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_Waiting"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_Delete"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_Last"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_Event"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_Second"
    },
    {
      "namespace": "util::search_knp",
      "declaration": "const as_s32 Phase_First"
    },
    {
      "namespace": "sys",
      "declaration": "const as_s32 Kaminote"
    },
    {
      "namespace": "sys",
      "declaration": "const as_s32 BtlUnit"
    },
    {
      "namespace": "sys",
      "declaration": "const as_s32 Btl"
    },
    {
      "namespace": "sys",
      "declaration": "const as_s32 DebugPause"
    },
    {
      "namespace": "sys",
      "declaration": "const as_s32 PAUSE"
    },
    {
      "namespace": "sys",
      "declaration": "const as_s32 MENU"
    },
    {
      "namespace": "sys",
      "declaration": "const as_s32 BERO"
    },
    {
      "namespace": "sys",
      "declaration": "const as_s32 ITEMGET"
    },
    {
      "namespace": "sys",
      "declaration": "const as_s32 STOP"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 DamageResult_Weak"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 DamageResult_Reflect"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 DamageResult_Normal"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 DamageResult_None"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 RoundTrip"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Loop"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Random"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Dead"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Event"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Lost"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Contact"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Attack"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Find"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Weak"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Damage"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Return"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Normal"
    },
    {
      "namespace": "hariko",
      "declaration": "const as_s32 Exit"
    },
    {
      "namespace": "navigator",
      "declaration": "float fLookDir_RightBack"
    },
    {
      "namespace": "navigator",
      "declaration": "float fLookDir_LeftBack"
    },
    {
      "namespace": "navigator",
      "declaration": "float fLookDir_Right"
    },
    {
      "namespace": "navigator",
      "declaration": "float fLookDir_Left"
    },
    {
      "namespace": "navigator",
      "declaration": "float fEntryDir_Back"
    },
    {
      "namespace": "navigator",
      "declaration": "float fEntryDir_Front"
    },
    {
      "namespace": "navigator",
      "declaration": "float fEntryDir_Right"
    },
    {
      "namespace": "navigator",
      "declaration": "float fEntryDir_Left"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 DisableActionType_All"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 DisableActionType_Default"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 MoveSpeed_Fast"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 MoveSpeed_Normal"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 LookDir_AutoBack"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 LookDir_Auto"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 LookDir_RightBack"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 LookDir_LeftBack"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 LookDir_Right"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 LookDir_Left"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 EntryType_Slow"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 EntryType_Quick"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 EntryType_Default"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 EntryDir_Back"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 EntryDir_Front"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 EntryDir_Right"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 EntryDir_Left"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 PosType_Event"
    },
    {
      "namespace": "navigator",
      "declaration": "const as_s32 PosType_TalkMario"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_ForceDamageStar"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_NoHP"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_JumpCrush"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_JumpSlider"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_Sub"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_KouraIn"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_Turn"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_Wing"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_Koura"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_TogeTop"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_Fire"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_Fly"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_Float"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_Ground"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_ATTR_None"
    },
    {
      "namespace": "btl::unit::parts",
      "declaration": "const as_u64 PARTS_STATUS_Direct"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u64 UNIT_STATUS_PanelInvalid"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u64 UNIT_STATUS_PanelHold"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u64 UNIT_STATUS_PanelFix"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u64 UNIT_STATUS_PanelEnable"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u64 UNIT_STATUS_PanelUsed"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u64 UNIT_STATUS_PanelSet"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u64 UNIT_STATUS_NoReturnHome"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u64 UNIT_STATUS_NextUnitAction"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u64 UNIT_STATUS_NoGuard"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u64 UNIT_STATUS_NoAction"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u64 UNIT_STATUS_Dead"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u32 UNIT_ATTR_FaceSide"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u32 UNIT_ATTR_FaceFront"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u32 UNIT_ATTR_BossReal"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u32 UNIT_ATTR_BossOrigami"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u32 UNIT_ATTR_Toge"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u32 UNIT_ATTR_Root"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u32 UNIT_ATTR_Fly"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u32 UNIT_ATTR_Float"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u32 UNIT_ATTR_Ground"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u32 UNIT_ATTR_ScopeJump"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_u32 UNIT_ATTR_ScopeHammer"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 AreaType_C"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 AreaType_B"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 AreaType_A"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 AreaType_None"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_FGroup"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_EGroup"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_DGroup"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_CGroup"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_BGroup"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_AGroup"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Panel6"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Panel5"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Panel4"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Panel3"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Panel2"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Panel1"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Goal6"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Goal5"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Goal4"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Goal3"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Goal2"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Goal1"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Heart"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Magic"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_MagicRainbow"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_MagicHand"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_MagicIce"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_MagicFire"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_MagicWater"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_MagicEarth"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Powerx2"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Commandx1"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Hint"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Bonus"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Recovery"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Attack"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Left"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Right"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_Out"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_In"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 BoardType_None"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelSubType_Treasure"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelSubType_Coin100"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelSubType_Coin10"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelSubType_Coin1"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelSubType_None"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_QuizGoal"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_PaperTrash"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Hole"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_TapeSlide"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_TapeRotate"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_KKThunder"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_LiteFire"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_RubberBand"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_BrittleIce"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Ice"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Cursor"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Spiral"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Fire"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_ItemHeartL"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_ItemHeartM"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_ItemHeartS"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_ItemCoin"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_MagicHand"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_MagicIce"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_MagicFire"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_MagicEarth"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_MagicWater"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_MagicRainbow"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Powerx2"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Commandx1"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Hint"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Bonus"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Recovery"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_JunkenPaa"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_JunkenChoki"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_JunkenGuu"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Attack"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Right"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Left"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_In"
    },
    {
      "namespace": "btl::MR",
      "declaration": "const as_s32 PanelType_Out"
    },
    {
      "namespace": "as",
      "declaration": "const as_s32 AS_RUNCTRL_PAUSE"
    },
    {
      "namespace": "as",
      "declaration": "const as_s32 AS_RUNCTRL_BATTLE_ENV"
    },
    {
      "namespace": "as",
      "declaration": "const as_s32 AS_RUNCTRL_BATTLE_UNIT"
    },
    {
      "namespace": "as",
      "declaration": "const as_s32 AS_RUNCTRL_BATTLE"
    },
    {
      "namespace": "as",
      "declaration": "const as_s32 AS_RUNCTRL_PEPALYZE"
    },
    {
      "namespace": "as",
      "declaration": "const as_s32 AS_RUNCTRL_MENU"
    },
    {
      "namespace": "as",
      "declaration": "const as_s32 AS_RUNCTRL_FIELD_ENV"
    },
    {
      "namespace": "as",
      "declaration": "const as_s32 AS_RUNCTRL_FIELD_NPC"
    },
    {
      "namespace": "as",
      "declaration": "const as_s32 AS_RUNCTRL_FIELD_ENEMY"
    },
    {
      "namespace": "as",
      "declaration": "const as_s32 AS_RUNCTRL_FIELD"
    },
    {
      "namespace": "as",
      "declaration": "const as_s32 AS_RUNCTRL_LEVEL1"
    },
    {
      "namespace": "util::Color4u8",
      "declaration": "as_u8 ElementMin"
    },
    {
      "namespace": "util::Color4u8",
      "declaration": "as_u8 ElementMax"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 StickState_Run"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 StickState_Walk"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 StickState_Stay"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_TorchFire"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_Dog"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_Thorn"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_Fall"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_MagmaFire"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_Magma"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_Ice"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_Sand"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_BlueFire"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_Fire"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_Doku"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_Toge"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_EnemyToge"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_Yoko"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 DamageType_Tate"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 StopPriority_Damage"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 StopPriority_Encount"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 StopPriority_Pepalyze"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 StopPriority_ItemGet"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 StopPriority_Stealth"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 StopPriority_MapLink"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 StopPriority_Event"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 StopPriority_System"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_BALLOON_FORCE_OFF"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_BATTLE_NO_MUTEKI"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_NG_FALL_JUMP"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_SET_DAMAGE_PARAM_REQUEST"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_SET_DAMAGE_PARAM"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_SPIN_JUMP_END"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_SPIN_JUMP"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_ICE_DAMAGE"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_NO_JUMP"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_NO_STICK_MOVE"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_DAMAGE"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_FIELD_STOP"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_STEALTH"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_CAMERA_NO_SHIFT"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_BATTLE"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_CAMERA_NO_FOLLOW"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_PEPALYZE_OK"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_ITEMGET"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_BALLOON_OFF_REQUEST"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_BALLOON_ON_REQUEST"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_BALLOON"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_TALK"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_EXIT"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_ENTER"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 EVENT_ACCESS_OK"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 ACTION_CONFETTI"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 ACTION_PULL_TAPE"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 ACTION_MENU"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 ACTION_FIRST_ATTACK"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 ACTION_TEAR_OFF"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 ACTION_SLOPE"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 ACTION_AWAWA"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 ACTION_OTOTO"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 ACTION_HAMMER"
    },
    {
      "namespace": "player",
      "declaration": "const as_s32 ACTION_JUMP"
    },
    {
      "namespace": "btl",
      "declaration": "const as_s32 BATTLE_RESULT_DRAW"
    },
    {
      "namespace": "btl",
      "declaration": "const as_s32 BATTLE_RESULT_ESCAPE"
    },
    {
      "namespace": "btl",
      "declaration": "const as_s32 BATTLE_RESULT_LOSE"
    },
    {
      "namespace": "btl",
      "declaration": "const as_s32 BATTLE_RESULT_WIN"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Encount"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Damage"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Fall"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Confetti"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Talk"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Draw"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_ExitByGimmick"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_ExitByDashAttack"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_ExitByFirstAttack"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_ExitByStar"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Exit"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_BattleGuest"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Escaped"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Return"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Lost"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Find"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Reaction"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Entry"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Main"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ActionType_Init"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 EventStateType_Through"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 EventStateType_Pause"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 EventStateType_Stop"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ExitReason_Pressed"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ExitReason_Gimmick"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ExitReason_FirstAttack"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ExitReason_ByStar"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ExitReason_ParentDead"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ExitReason_Battle"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ExitReason_None"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 RETURN_POINT_WATCH"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 RETURN_POINT_INIT"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 PROWL_ORDER_LOOP"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 PROWL_ORDER_RETURN"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 PROWL_SHAPE_CIRCLE"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 PROWL_SHAPE_RECT"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 PROWL_TYPE_LINE"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 PROWL_TYPE_ROUND"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 PROWL_TYPE_AREA"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 PROWL_TYPE_STOP"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ACTION_MUTEKI_FORCE_NOTIFY"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ACTION_STAR_TOLERANCE"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ACTION_MUTEKI_NO_HIT"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ACTION_HAMMER_TOLERANCE"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ACTION_STAMP_TOLERANCE"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ACTION_SEARCH"
    },
    {
      "namespace": "npc",
      "declaration": "const as_s32 ACTION_TALK"
    },
    {
      "namespace": "msg::y",
      "declaration": "int DOWN"
    },
    {
      "namespace": "msg::y",
      "declaration": "int CENTER"
    },
    {
      "namespace": "msg::y",
      "declaration": "int UP"
    },
    {
      "namespace": "msg::x",
      "declaration": "int RIGHT"
    },
    {
      "namespace": "msg::x",
      "declaration": "int CENTER"
    },
    {
      "namespace": "msg::x",
      "declaration": "int LEFT"
    },
    {
      "namespace": "msg",
      "declaration": "const as_s32 TogeFix_Center"
    },
    {
      "namespace": "msg",
      "declaration": "const as_s32 TogeFix_MiddleRight"
    },
    {
      "namespace": "msg",
      "declaration": "const as_s32 TogeFix_MiddleLeft"
    },
    {
      "namespace": "msg",
      "declaration": "const as_s32 TogeFix_Right"
    },
    {
      "namespace": "msg",
      "declaration": "const as_s32 TogeFix_Left"
    },
    {
      "namespace": "msg",
      "declaration": "const as_s32 TogeFix_Down"
    },
    {
      "namespace": "msg",
      "declaration": "const as_s32 TogeFix_Up"
    },
    {
      "namespace": "msg",
      "declaration": "const as_s32 TogeDir_Right"
    },
    {
      "namespace": "msg",
      "declaration": "const as_s32 TogeDir_Left"
    },
    {
      "namespace": "msg",
      "declaration": "const as_s32 TogeDir_Down"
    },
    {
      "namespace": "msg",
      "declaration": "const as_s32 TogeDir_Up"
    },
    {
      "namespace": "mobj",
      "declaration": "const as_s32 IGNORE_HOLE_LOCK_ACTION"
    },
    {
      "namespace": "mobj",
      "declaration": "const as_s32 IGNORE_HOLE_LOCK_ANIME"
    },
    {
      "namespace": "mobj",
      "declaration": "const as_s32 IGNORE_HOLE_LOCK_AACCESS"
    },
    {
      "namespace": "mobj",
      "declaration": "const as_s32 TexColorORANGE"
    },
    {
      "namespace": "mobj",
      "declaration": "const as_s32 TexColorBLACK"
    },
    {
      "namespace": "mobj",
      "declaration": "const as_s32 TexColorPURPLE"
    },
    {
      "namespace": "mobj",
      "declaration": "const as_s32 TexColorPINK"
    },
    {
      "namespace": "mobj",
      "declaration": "const as_s32 TexColorYELLOW"
    },
    {
      "namespace": "mobj",
      "declaration": "const as_s32 TexColorBLUE"
    },
    {
      "namespace": "mobj",
      "declaration": "const as_s32 TexColorGREEN"
    },
    {
      "namespace": "mobj",
      "declaration": "const as_s32 TexColorRED"
    },
    {
      "namespace": "math",
      "declaration": "float M_MSEC_TO_FRAME"
    },
    {
      "namespace": "math",
      "declaration": "float M_FRAME_TO_MSEC"
    },
    {
      "namespace": "math",
      "declaration": "float NaN"
    },
    {
      "namespace": "math",
      "declaration": "float INF"
    },
    {
      "namespace": "math",
      "declaration": "float M_RAD2DEG"
    },
    {
      "namespace": "math",
      "declaration": "float M_DEG2RAD"
    },
    {
      "namespace": "math",
      "declaration": "float PI"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 EaseType_EaseInOut"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 EaseType_EaseOut"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 EaseType_EaseIn"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 EaseType_Custom"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 CurveType_Bounce"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 CurveType_Elastic"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 CurveType_Back"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 CurveType_Circular"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 CurveType_Exponential"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 CurveType_Quintic"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 CurveType_Quartic"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 CurveType_Cubic"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 CurveType_Quadratic"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 CurveType_Sine"
    },
    {
      "namespace": "math::bezier",
      "declaration": "const as_s32 CurveType_Linear"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPEMAX"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_EASE_IN_OUT"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_SIN_DECEL"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_SIN_ACCEL"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_TRIPLE_SIN"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_DOUBLE_SIN"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_SIN"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_BOUND"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_BURURUN_DECEL"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_BURURUN"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_GEMINI"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_TRIPLE_DECEL"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_DOUBLE_DECEL"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_DECEL"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_TRIPLE_ACCEL"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_DOUBLE_ACCEL"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_ACCEL"
    },
    {
      "namespace": "math",
      "declaration": "const as_s32 MOVE_TYPE_LINEAR"
    },
    {
      "namespace": "math",
      "declaration": "f32 F32_MAX"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_DELETE_DIRECT"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_DELETE_SOFT"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 EntryType_Drop"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 EntryType_Normal"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 VanishType_time"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 VanishType_none"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 FromType_Stay"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 FromType_Saboten"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 FromType_Tree"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 FromType_Grass"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 FromType_Block"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 FromType_Default"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_FORCE_TOUCH_GET"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_NO_AUTO_COLLECT"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_EFFECT_POST_UPDATE"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_DYNAMIC"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_NO_RELATE_EFFECT"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_EFF_HIDE"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_NO_SYSTEM_FLAG"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_SEAL_NO_BACK"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_GET_SEQUENCE"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_NO_GET_COUNTER_ZERO"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_SET_HIRAHIRA"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_NO_GET"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_EFFECT"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_DISP_UI"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_ADD_POUCH"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_FALL_RANDOM"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_FIX_DROP_POS"
    },
    {
      "namespace": "item",
      "declaration": "const as_s32 ITEM_FLG_WALL_CHECK"
    },
    {
      "namespace": "gmap",
      "declaration": "int DIG_MAX_COUNT"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 LinkType_Pitfall"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 LinkType_Save"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 LinkType_Goal"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 LinkType_Door"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 LinkType_Dokan"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 LinkType_Bero"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 ExitArg_Param1"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 ExitArg_LinkID"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 EntryArg_Param1"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 EntryArg_LinkID"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 Shutter"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 CenterPush"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 CenterPull"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 RightPush"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 RightPull"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 LeftPush"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 LeftPull"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 JoinMode_JoinPos"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 JoinMode_JoinId"
    },
    {
      "namespace": "gmap",
      "declaration": "const as_s32 JoinMode_Default"
    },
    {
      "namespace": "fade",
      "declaration": "const as_s32 CH_Max"
    },
    {
      "namespace": "fade",
      "declaration": "const as_s32 CH_Retry"
    },
    {
      "namespace": "fade",
      "declaration": "const as_s32 CH_Skip"
    },
    {
      "namespace": "fade",
      "declaration": "const as_s32 CH_System"
    },
    {
      "namespace": "fade",
      "declaration": "const as_s32 CH_Field"
    },
    {
      "namespace": "dbg::text",
      "declaration": "const as_s32 AlignBottom"
    },
    {
      "namespace": "dbg::text",
      "declaration": "const as_s32 AlignTop"
    },
    {
      "namespace": "dbg::text",
      "declaration": "const as_s32 AlignHCenter"
    },
    {
      "namespace": "dbg::text",
      "declaration": "const as_s32 AlignRight"
    },
    {
      "namespace": "dbg::text",
      "declaration": "const as_s32 AlignLeft"
    },
    {
      "namespace": "dbg::DebugWindow",
      "declaration": "as_u32 InvalidWindowID"
    },
    {
      "namespace": "dbg::DebugWindow",
      "declaration": "as_u32 ScriptRootWindowID"
    },
    {
      "namespace": "dbg",
      "declaration": "const as_s32 JoinMode_JoinPos"
    },
    {
      "namespace": "dbg",
      "declaration": "const as_s32 JoinMode_JoinId"
    },
    {
      "namespace": "dbg",
      "declaration": "const as_s32 JoinMode_Default"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 UpdateOptimizeMode_Enable_MdlSrt_BV_Lct_WldSrt"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 UpdateOptimizeMode_Enable_MdlSrt_BV"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 UpdateOptimizeMode_Disable"
    },
    {
      "namespace": "chr",
      "declaration": "math::Vec3 JUMP_STAY_POS"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PullDir_Up"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PullDir_Down"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PullDir_Side"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PullDir_Auto"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AccessType_Pull"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AccessType_Talk"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AccessType_Normal"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AccessType_Auto"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonDir_Right"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonDir_Left"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonDir_Normal"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_jump"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_sit"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_start"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_save"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_eat"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_grab"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_out"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_look"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_push"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_down"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_up"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_holybeast"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_pick_up"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_godhand"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_hold"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_fishing"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_drop"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_put_in"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_pull_out"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_compare"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_close"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_in"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_ride"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_pull_strong"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_pull"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_hear"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_read"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_open"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_tear_off"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_access"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_talk"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 BalloonType_No"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AffectType_DroopingEyes"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AffectType_SlantedEyes"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AffectType_Trouble"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AffectType_Surprise"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AffectType_Sad"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AffectType_Anger"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AffectType_Terror"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AffectType_Panic"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AffectType_Joy"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 AffectType_Normal"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_BLOCK_PLAYER_JUMP_OVER"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_PLAYER_ACCESS_NO_RIDE"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_SKIP_PLAYER"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_LOCKED"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_HAMMER_DISABLE_SWING"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_PLAYER_JUMP_ADVANTAGE"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_SOFT_ENCOUNT"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_HAMMER_FRONT"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_HAMMER_SHAKE_RANGE"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_HAMMER_IMPACT_RANGE"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_HAMMER"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_PLAYER_PUSH"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_PLAYER_FOOT_ACCESS"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_PLAYER_TOUCH_ACCESS"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_PLAYER_FRONT_ACCESS"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_PLAYER_ACCESS"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_PLAYER_JUMP"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CHECK_FLG_PLAYER_BODY"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CorrectParty"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CorrectKanban"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CorrectLoose"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CorrectTight"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 CorrectNone"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ShapeSegment"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ShapeAAEllipse"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ShapeAABB"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ShapeSphere"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ShapeOBB"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ShapeYAOBB"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ShapeAACylinder"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 SPEED_DECEL"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 SPEED_ACCEL"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 SPEED_CONST"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 HIT_MOVE_REACTION_REFLECT"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 HIT_MOVE_REACTION_SLIDE"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 HIT_MOVE_REACTION_STOP"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 LOOK_BACK"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 LOOK_FRONT"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 LOOK_RIGHT_BACK"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 LOOK_LEFT_BACK"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 LOOK_RIGHT"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 LOOK_LEFT"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_Unique"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_Olivia"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_FixFront"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_Nothing"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_Slit_B1"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_Slit"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_DirectRotY"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_3D_NPC"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_3D"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_NoFlip"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_HaveBackModel"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_OrigamiYoko"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_Origami"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 PeraType_Normal"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 HIT_MAP_CEILING"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 HIT_MAP_WALL"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 HIT_MAP"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_NO_ROTATE_HIT"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_MATERIAL_TAPE"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_MOVE_SPEED_UNLIMITED"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_FAST_MOVE"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_NO_KUSYA"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_MATERIAL_STONE"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_MATERIAL_BUSH"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_MATERIAL_GRASS"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_MATERIAL_WATER"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_MATERIAL_METAL"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_MATERIAL_WOOD"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_MATERIAL_VERY_HARD"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_MATERIAL_HARD"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ATTR_KAKURE_BLOCK"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_FIX_SRT"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_FIX_TRANS"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_FIX_ROT"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_NO_CTRL"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_NO_PINCH"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_CHECK_MOBJ"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_NO_HITMAP"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_NO_TOUCH"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_NO_EFFECT"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_MUTEKI"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_EXIT"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_TALKING"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_TALKABLE"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_FALL"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_JUMP"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 STATUS_GROUND"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ROTATE_ZXY"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ROTATE_YXZ"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ROTATE_ZYX"
    },
    {
      "namespace": "chr",
      "declaration": "const as_s32 ROTATE_XYZ"
    },
    {
      "namespace": "chr",
      "declaration": "float EventDashSpeed"
    },
    {
      "namespace": "chr",
      "declaration": "float EventWalkSpeed"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 CasesObjLWArg_HitName"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 CasesObjLWArg_ObjName"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 FLG_FORCE_EXEC"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 FLG_NONPLAYABLE"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 FLG_CONTAINS_CHILD"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 FLG_BEGIN_MATCH"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 FLG_UNIQUE"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 FLG_OVER_WRITE"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 FLG_NEAREST_CHECK"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 FLG_WAIT"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 FLG_SYS_STOP"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 FLG_LOCK"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 FLG_ONCE"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 Priority_END"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 Priority_Delay"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 Priority_Normal"
    },
    {
      "namespace": "cases",
      "declaration": "const as_s32 Priority_Hurry"
    },
    {
      "namespace": "cam",
      "declaration": "int M_UI_RENDER_HEIGHT"
    },
    {
      "namespace": "cam",
      "declaration": "int M_UI_RENDER_WIDTH"
    },
    {
      "namespace": "cam",
      "declaration": "int M_FULL_RENDER_HEIGHT"
    },
    {
      "namespace": "cam",
      "declaration": "int M_FULL_RENDER_WIDTH"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 DamageEffect_RealExplode"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 DamageEffect_Real"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 DamageEffect_Paper"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 DamageEffect_NoEffect"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 DamageEffect_None"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_Murder"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_EarthGurad"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_Panic"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_SlideOut"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_SlideIn"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_Toge"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_BlowOutRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_Blow"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_FloatOutRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_Float"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_KouraBlown"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_KouraCrush"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_FallWing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_KouraAttack"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_Rise"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_Turn"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_Koura"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_CounterPoiHammerCatch"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_CounterBulletCatch"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_CounterCut"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_CounterIce"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_CounterJumpCrush"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_CounterJumpCatch"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_CounterJumpMiss"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_CounterJumpSlider"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_CounterSub"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_CounterFire"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_CounterToge"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastDamageMagicIce"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastDamageMagicFire"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastDamageMagicWater"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastDamageMagicEarth"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastDamageCut"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastDamageCrush"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastHandCrush"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastGuardOutRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastGuardKnockBackRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastDamageSideOutRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastDamageTopOutRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastDamageSideKnockBackRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastDamageTopKnockBackRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastNoDamageOutRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastNoDamageKnockBackRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastNoDamage"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastEscape"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastGuardShort"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastGuard"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastDamageSide"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_LastDamageTop"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamageMagicIce"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamageMagicFire"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamageMagicWater"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamageMagicEarth"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamageCut"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamageGolf"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamagePow"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamagePoiHammer"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamageCrush"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_HandCrush"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_NoDamageKnockBackRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_NoDamage"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_Escape"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_GuardShort"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_GuardKnockBackRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_Guard"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamageSideKnockBackRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamageTopKnockBackRing"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamageSide"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_DamageTop"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_NoEffect"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_Dead"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_Miss"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 RESULT_None"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 ACType_Excellent"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 ACType_Great"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 ACType_Nice"
    },
    {
      "namespace": "btl::weapon",
      "declaration": "const as_s32 ACType_None"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_s32 MarioJumpType_erticalLow2"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_s32 MarioJumpType_VerticalLow"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_s32 MarioJumpType_VerticalMiddle"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_s32 MarioJumpType_VerticalHigh"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_s32 MarioJumpType_VerticalHigh2"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_s32 MarioJumpType_Low2"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_s32 MarioJumpType_Low"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_s32 MarioJumpType_Middle"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_s32 MarioJumpType_High"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_s32 MarioJumpType_High2"
    },
    {
      "namespace": "btl::unit",
      "declaration": "const as_s32 MarioJumpType_Step"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_Caption1LineL"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_Readygo"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_CaptionL"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_ReadyGo"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_MagicRainbow"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_MagicIce"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_MagicFire"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_MagicWater"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_MagicEarth"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_MagicHand"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_JunkenGuard"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_JunkenDraw"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_JunkenLose"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_JunkenWin"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_JunkenPon"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_JunkenKen"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_JunkenJun"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_JunkenStart2_NoGyro"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_JunkenStart2"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_JunkenStart"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_RushTimeOut"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_RushStart"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 CaptionType_TimeupMoveRing"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 RingControl_LastBeast"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 RingControl_QuizSong"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 RingControl_Proper"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 RingPattern_QuizPictureC"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 RingPattern_QuizPictureB"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 RingPattern_QuizPictureA"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 RingPattern_Solid"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 RingSize_Middle"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 RingSize_Little"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 RingType_LastPicture"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 RingType_Picture"
    },
    {
      "namespace": "btl::ui",
      "declaration": "const as_s32 RingType_Default"
    },
    {
      "namespace": "btl::seq",
      "declaration": "const as_s32 Mode_Slide"
    },
    {
      "namespace": "btl::seq",
      "declaration": "const as_s32 Mode_Rotate"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_JunkenNow"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_Lose"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_Win"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_AttackEnemy"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_AttackPlayer"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_Cmd"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_PuzzleMiss"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_PuzzleSuccess"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_Puzzle"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_EnterBoss"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_FirstAttackEnemy"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_FirstAttackPlayer"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerMsgKind_Enter"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_Junken"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_BossKK"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_King"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_Stapler"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_Scissor"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_Punch"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_Tape"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_RubberBand"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_Pen"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_Ice"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_Fire"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_Water"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_Earth"
    },
    {
      "namespace": "btl::cheer",
      "declaration": "const as_s32 CheerType_Normal"
    },
    {
      "namespace": "btl::camera",
      "declaration": "const as_s32 CameraAnimeType_OverridePitchPosOffsetDir"
    },
    {
      "namespace": "btl::camera",
      "declaration": "const as_s32 CameraAnimeType_OverridePitchOffsetPosDir"
    },
    {
      "namespace": "btl::camera",
      "declaration": "const as_s32 CameraAnimeType_OverridePitchOffsetDir"
    },
    {
      "namespace": "btl::camera",
      "declaration": "const as_s32 CameraAnimeType_OverridePitchDir"
    },
    {
      "namespace": "btl::camera",
      "declaration": "const as_s32 CameraAnimeType_OverridePitch"
    },
    {
      "namespace": "btl::camera",
      "declaration": "const as_s32 CameraAnimeType_OverrideAll"
    },
    {
      "namespace": "btl::camera",
      "declaration": "const as_s32 CameraAnimeType_OffsetPosDir"
    },
    {
      "namespace": "btl::camera",
      "declaration": "const as_s32 CameraAnimeType_OffsetAll"
    },
    {
      "namespace": "btl::ac",
      "declaration": "const as_s32 ACResult_Slowly"
    },
    {
      "namespace": "btl::ac",
      "declaration": "const as_s32 ACResult_Early"
    },
    {
      "namespace": "btl::ac",
      "declaration": "const as_s32 ACResult_SlowlyNice"
    },
    {
      "namespace": "btl::ac",
      "declaration": "const as_s32 ACResult_Excellent"
    },
    {
      "namespace": "btl::ac",
      "declaration": "const as_s32 ACResult_Great"
    },
    {
      "namespace": "btl::ac",
      "declaration": "const as_s32 ACResult_Nice"
    },
    {
      "namespace": "btl::ac",
      "declaration": "const as_s32 ACResult_None"
    },
    {
      "namespace": "btl",
      "declaration": "const as_s32 StartOption_Turn"
    },
    {
      "namespace": "btl",
      "declaration": "const as_s32 StartOption_InKoura"
    },
    {
      "namespace": "btl",
      "declaration": "const as_s32 StartOption_None"
    },
    {
      "namespace": "btl",
      "declaration": "const as_s32 StartMode_StampToge"
    },
    {
      "namespace": "btl",
      "declaration": "const as_s32 StartMode_EnemyAttack"
    },
    {
      "namespace": "btl",
      "declaration": "const as_s32 StartMode_PlayerAttackJump"
    },
    {
      "namespace": "btl",
      "declaration": "const as_s32 StartMode_PlayerAttackHammer"
    },
    {
      "namespace": "btl",
      "declaration": "const as_s32 StartMode_Normal"
    }
  ],
  "funcdefs": [
    {
      "namespace": "util::notice",
      "declaration": "void NoticeCallback()"
    },
    {
      "namespace": "dbg",
      "declaration": "void SimpleCallback()"
    },
    {
      "namespace": "dbg",
      "declaration": "void DebugWindowCallback(DebugWindow& debug_window, any ref func_arg = null)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowVec3_Const_P(const math::Vec3 &value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowVec3_P(math::Vec3 &value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowVec3_Const_D(const math::Vec3 value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowVec3_D(math::Vec3 value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowF32_Const_P(const as_f32 &value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowF32_P(as_f32 &value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowF32_Const_D(const as_f32 value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowF32_D(as_f32 value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowS32_Const_P(const as_s32 &value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowS32_P(as_s32 &value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowS32_Const_D(const as_s32 value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowS32_D(as_s32 value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowBool_Const_P(const bool &value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowBool_P(bool &value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowBool_Const_D(const bool value)"
    },
    {
      "namespace": "dbg",
      "declaration": "void SetterDebugWindowBool_D(bool value)"
    },
    {
      "namespace": "dbg",
      "declaration": "const math::Vec3 &GetterDebugWindowVec3_Const_P()"
    },
    {
      "namespace": "dbg",
      "declaration": "math::Vec3 &GetterDebugWindowVec3_P()"
    },
    {
      "namespace": "dbg",
      "declaration": "const math::Vec3 GetterDebugWindowVec3_Const_D()"
    },
    {
      "namespace": "dbg",
      "declaration": "math::Vec3 GetterDebugWindowVec3_D()"
    },
    {
      "namespace": "dbg",
      "declaration": "const as_f32 &GetterDebugWindowF32_Const_P()"
    },
    {
      "namespace": "dbg",
      "declaration": "as_f32 &GetterDebugWindowF32_P()"
    },
    {
      "namespace": "dbg",
      "declaration": "const as_f32 GetterDebugWindowF32_Const_D()"
    },
    {
      "namespace": "dbg",
      "declaration": "as_f32 GetterDebugWindowF32_D()"
    },
    {
      "namespace": "dbg",
      "declaration": "const as_s32 &GetterDebugWindowS32_Const_P()"
    },
    {
      "namespace": "dbg",
      "declaration": "as_s32 &GetterDebugWindowS32_P()"
    },
    {
      "namespace": "dbg",
      "declaration": "const as_s32 GetterDebugWindowS32_Const_D()"
    },
    {
      "namespace": "dbg",
      "declaration": "as_s32 GetterDebugWindowS32_D()"
    },
    {
      "namespace": "dbg",
      "declaration": "const bool &GetterDebugWindowBool_Const_P()"
    },
    {
      "namespace": "dbg",
      "declaration": "bool &GetterDebugWindowBool_P()"
    },
    {
      "namespace": "dbg",
      "declaration": "const bool GetterDebugWindowBool_Const_D()"
    },
    {
      "namespace": "dbg",
      "declaration": "bool GetterDebugWindowBool_D()"
    },
    {
      "namespace": "dbg",
      "declaration": "bool EditableCheckerDebugWindow_D()"
    },
    {
      "namespace": "dbg",
      "declaration": "void TestCallback(f32 t, f32& x, f32& y)"
    },
    {
      "namespace": "cases",
      "declaration": "const bool GetterVariableIsTrueCallback_Const()"
    },
    {
      "namespace": "cases",
      "declaration": "bool GetterVariableIsTrueCallback()"
    }
  ]
}